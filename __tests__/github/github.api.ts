import {
  NamedType,
  Argument,
  Value,
  Field,
  InlineFragment,
  Operation,
  Selection,
  SelectionSet,
  Variable,
} from "../../src";

export enum AuditLogOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum CheckAnnotationLevel {
  FAILURE = "FAILURE",
  NOTICE = "NOTICE",
  WARNING = "WARNING",
}

export enum CheckConclusionState {
  ACTION_REQUIRED = "ACTION_REQUIRED",
  CANCELLED = "CANCELLED",
  FAILURE = "FAILURE",
  NEUTRAL = "NEUTRAL",
  SKIPPED = "SKIPPED",
  STALE = "STALE",
  STARTUP_FAILURE = "STARTUP_FAILURE",
  SUCCESS = "SUCCESS",
  TIMED_OUT = "TIMED_OUT",
}

export enum CheckRunType {
  ALL = "ALL",
  LATEST = "LATEST",
}

export enum CheckStatusState {
  COMPLETED = "COMPLETED",
  IN_PROGRESS = "IN_PROGRESS",
  QUEUED = "QUEUED",
  REQUESTED = "REQUESTED",
}

export enum CollaboratorAffiliation {
  ALL = "ALL",
  DIRECT = "DIRECT",
  OUTSIDE = "OUTSIDE",
}

export enum CommentAuthorAssociation {
  COLLABORATOR = "COLLABORATOR",
  CONTRIBUTOR = "CONTRIBUTOR",
  FIRST_TIMER = "FIRST_TIMER",
  FIRST_TIME_CONTRIBUTOR = "FIRST_TIME_CONTRIBUTOR",
  MANNEQUIN = "MANNEQUIN",
  MEMBER = "MEMBER",
  NONE = "NONE",
  OWNER = "OWNER",
}

export enum CommentCannotUpdateReason {
  ARCHIVED = "ARCHIVED",
  DENIED = "DENIED",
  INSUFFICIENT_ACCESS = "INSUFFICIENT_ACCESS",
  LOCKED = "LOCKED",
  LOGIN_REQUIRED = "LOGIN_REQUIRED",
  MAINTENANCE = "MAINTENANCE",
  VERIFIED_EMAIL_REQUIRED = "VERIFIED_EMAIL_REQUIRED",
}

export enum CommitContributionOrderField {
  COMMIT_COUNT = "COMMIT_COUNT",
  OCCURRED_AT = "OCCURRED_AT",
}

export enum DefaultRepositoryPermissionField {
  ADMIN = "ADMIN",
  NONE = "NONE",
  READ = "READ",
  WRITE = "WRITE",
}

export enum DeploymentOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum DeploymentState {
  ABANDONED = "ABANDONED",
  ACTIVE = "ACTIVE",
  DESTROYED = "DESTROYED",
  ERROR = "ERROR",
  FAILURE = "FAILURE",
  INACTIVE = "INACTIVE",
  IN_PROGRESS = "IN_PROGRESS",
  PENDING = "PENDING",
  QUEUED = "QUEUED",
  WAITING = "WAITING",
}

export enum DeploymentStatusState {
  ERROR = "ERROR",
  FAILURE = "FAILURE",
  INACTIVE = "INACTIVE",
  IN_PROGRESS = "IN_PROGRESS",
  PENDING = "PENDING",
  QUEUED = "QUEUED",
  SUCCESS = "SUCCESS",
}

export enum DiffSide {
  LEFT = "LEFT",
  RIGHT = "RIGHT",
}

export enum EnterpriseAdministratorInvitationOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum EnterpriseAdministratorRole {
  BILLING_MANAGER = "BILLING_MANAGER",
  OWNER = "OWNER",
}

export enum EnterpriseDefaultRepositoryPermissionSettingValue {
  ADMIN = "ADMIN",
  NONE = "NONE",
  NO_POLICY = "NO_POLICY",
  READ = "READ",
  WRITE = "WRITE",
}

export enum EnterpriseEnabledDisabledSettingValue {
  DISABLED = "DISABLED",
  ENABLED = "ENABLED",
  NO_POLICY = "NO_POLICY",
}

export enum EnterpriseEnabledSettingValue {
  ENABLED = "ENABLED",
  NO_POLICY = "NO_POLICY",
}

export enum EnterpriseMemberOrderField {
  CREATED_AT = "CREATED_AT",
  LOGIN = "LOGIN",
}

export enum EnterpriseMembersCanCreateRepositoriesSettingValue {
  ALL = "ALL",
  DISABLED = "DISABLED",
  NO_POLICY = "NO_POLICY",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum EnterpriseMembersCanMakePurchasesSettingValue {
  DISABLED = "DISABLED",
  ENABLED = "ENABLED",
}

export enum EnterpriseServerInstallationOrderField {
  CREATED_AT = "CREATED_AT",
  CUSTOMER_NAME = "CUSTOMER_NAME",
  HOST_NAME = "HOST_NAME",
}

export enum EnterpriseServerUserAccountEmailOrderField {
  EMAIL = "EMAIL",
}

export enum EnterpriseServerUserAccountOrderField {
  LOGIN = "LOGIN",
  REMOTE_CREATED_AT = "REMOTE_CREATED_AT",
}

export enum EnterpriseServerUserAccountsUploadOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum EnterpriseServerUserAccountsUploadSyncState {
  FAILURE = "FAILURE",
  PENDING = "PENDING",
  SUCCESS = "SUCCESS",
}

export enum EnterpriseUserAccountMembershipRole {
  MEMBER = "MEMBER",
  OWNER = "OWNER",
}

export enum EnterpriseUserDeployment {
  CLOUD = "CLOUD",
  SERVER = "SERVER",
}

export enum FileViewedState {
  DISMISSED = "DISMISSED",
  UNVIEWED = "UNVIEWED",
  VIEWED = "VIEWED",
}

export enum FundingPlatform {
  COMMUNITY_BRIDGE = "COMMUNITY_BRIDGE",
  CUSTOM = "CUSTOM",
  GITHUB = "GITHUB",
  ISSUEHUNT = "ISSUEHUNT",
  KO_FI = "KO_FI",
  LIBERAPAY = "LIBERAPAY",
  OPEN_COLLECTIVE = "OPEN_COLLECTIVE",
  OTECHIE = "OTECHIE",
  PATREON = "PATREON",
  TIDELIFT = "TIDELIFT",
}

export enum GistOrderField {
  CREATED_AT = "CREATED_AT",
  PUSHED_AT = "PUSHED_AT",
  UPDATED_AT = "UPDATED_AT",
}

export enum GistPrivacy {
  ALL = "ALL",
  PUBLIC = "PUBLIC",
  SECRET = "SECRET",
}

export enum GitSignatureState {
  BAD_CERT = "BAD_CERT",
  BAD_EMAIL = "BAD_EMAIL",
  EXPIRED_KEY = "EXPIRED_KEY",
  GPGVERIFY_ERROR = "GPGVERIFY_ERROR",
  GPGVERIFY_UNAVAILABLE = "GPGVERIFY_UNAVAILABLE",
  INVALID = "INVALID",
  MALFORMED_SIG = "MALFORMED_SIG",
  NOT_SIGNING_KEY = "NOT_SIGNING_KEY",
  NO_USER = "NO_USER",
  OCSP_ERROR = "OCSP_ERROR",
  OCSP_PENDING = "OCSP_PENDING",
  OCSP_REVOKED = "OCSP_REVOKED",
  UNKNOWN_KEY = "UNKNOWN_KEY",
  UNKNOWN_SIG_TYPE = "UNKNOWN_SIG_TYPE",
  UNSIGNED = "UNSIGNED",
  UNVERIFIED_EMAIL = "UNVERIFIED_EMAIL",
  VALID = "VALID",
}

export enum IdentityProviderConfigurationState {
  CONFIGURED = "CONFIGURED",
  ENFORCED = "ENFORCED",
  UNCONFIGURED = "UNCONFIGURED",
}

export enum IpAllowListEnabledSettingValue {
  DISABLED = "DISABLED",
  ENABLED = "ENABLED",
}

export enum IpAllowListEntryOrderField {
  ALLOW_LIST_VALUE = "ALLOW_LIST_VALUE",
  CREATED_AT = "CREATED_AT",
}

export enum IssueCommentOrderField {
  UPDATED_AT = "UPDATED_AT",
}

export enum IssueOrderField {
  COMMENTS = "COMMENTS",
  CREATED_AT = "CREATED_AT",
  UPDATED_AT = "UPDATED_AT",
}

export enum IssueState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

export enum IssueTimelineItemsItemType {
  ADDED_TO_PROJECT_EVENT = "ADDED_TO_PROJECT_EVENT",
  ASSIGNED_EVENT = "ASSIGNED_EVENT",
  CLOSED_EVENT = "CLOSED_EVENT",
  COMMENT_DELETED_EVENT = "COMMENT_DELETED_EVENT",
  CONNECTED_EVENT = "CONNECTED_EVENT",
  CONVERTED_NOTE_TO_ISSUE_EVENT = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  CROSS_REFERENCED_EVENT = "CROSS_REFERENCED_EVENT",
  DEMILESTONED_EVENT = "DEMILESTONED_EVENT",
  DISCONNECTED_EVENT = "DISCONNECTED_EVENT",
  ISSUE_COMMENT = "ISSUE_COMMENT",
  LABELED_EVENT = "LABELED_EVENT",
  LOCKED_EVENT = "LOCKED_EVENT",
  MARKED_AS_DUPLICATE_EVENT = "MARKED_AS_DUPLICATE_EVENT",
  MENTIONED_EVENT = "MENTIONED_EVENT",
  MILESTONED_EVENT = "MILESTONED_EVENT",
  MOVED_COLUMNS_IN_PROJECT_EVENT = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  PINNED_EVENT = "PINNED_EVENT",
  REFERENCED_EVENT = "REFERENCED_EVENT",
  REMOVED_FROM_PROJECT_EVENT = "REMOVED_FROM_PROJECT_EVENT",
  RENAMED_TITLE_EVENT = "RENAMED_TITLE_EVENT",
  REOPENED_EVENT = "REOPENED_EVENT",
  SUBSCRIBED_EVENT = "SUBSCRIBED_EVENT",
  TRANSFERRED_EVENT = "TRANSFERRED_EVENT",
  UNASSIGNED_EVENT = "UNASSIGNED_EVENT",
  UNLABELED_EVENT = "UNLABELED_EVENT",
  UNLOCKED_EVENT = "UNLOCKED_EVENT",
  UNMARKED_AS_DUPLICATE_EVENT = "UNMARKED_AS_DUPLICATE_EVENT",
  UNPINNED_EVENT = "UNPINNED_EVENT",
  UNSUBSCRIBED_EVENT = "UNSUBSCRIBED_EVENT",
  USER_BLOCKED_EVENT = "USER_BLOCKED_EVENT",
}

export enum LabelOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
}

export enum LanguageOrderField {
  SIZE = "SIZE",
}

export enum LockReason {
  OFF_TOPIC = "OFF_TOPIC",
  RESOLVED = "RESOLVED",
  SPAM = "SPAM",
  TOO_HEATED = "TOO_HEATED",
}

export enum MergeableState {
  CONFLICTING = "CONFLICTING",
  MERGEABLE = "MERGEABLE",
  UNKNOWN = "UNKNOWN",
}

export enum MilestoneOrderField {
  CREATED_AT = "CREATED_AT",
  DUE_DATE = "DUE_DATE",
  NUMBER = "NUMBER",
  UPDATED_AT = "UPDATED_AT",
}

export enum MilestoneState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

export enum OauthApplicationCreateAuditEntryState {
  ACTIVE = "ACTIVE",
  PENDING_DELETION = "PENDING_DELETION",
  SUSPENDED = "SUSPENDED",
}

export enum OperationType {
  ACCESS = "ACCESS",
  AUTHENTICATION = "AUTHENTICATION",
  CREATE = "CREATE",
  MODIFY = "MODIFY",
  REMOVE = "REMOVE",
  RESTORE = "RESTORE",
  TRANSFER = "TRANSFER",
}

export enum OrderDirection {
  ASC = "ASC",
  DESC = "DESC",
}

export enum OrgAddMemberAuditEntryPermission {
  ADMIN = "ADMIN",
  READ = "READ",
}

export enum OrgCreateAuditEntryBillingPlan {
  BUSINESS = "BUSINESS",
  BUSINESS_PLUS = "BUSINESS_PLUS",
  FREE = "FREE",
  TIERED_PER_SEAT = "TIERED_PER_SEAT",
  UNLIMITED = "UNLIMITED",
}

export enum OrgRemoveBillingManagerAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING = "SAML_EXTERNAL_IDENTITY_MISSING",
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY",
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
}

export enum OrgRemoveMemberAuditEntryMembershipType {
  ADMIN = "ADMIN",
  BILLING_MANAGER = "BILLING_MANAGER",
  DIRECT_MEMBER = "DIRECT_MEMBER",
  OUTSIDE_COLLABORATOR = "OUTSIDE_COLLABORATOR",
  UNAFFILIATED = "UNAFFILIATED",
}

export enum OrgRemoveMemberAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING = "SAML_EXTERNAL_IDENTITY_MISSING",
  SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY = "SAML_SSO_ENFORCEMENT_REQUIRES_EXTERNAL_IDENTITY",
  TWO_FACTOR_ACCOUNT_RECOVERY = "TWO_FACTOR_ACCOUNT_RECOVERY",
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
  USER_ACCOUNT_DELETED = "USER_ACCOUNT_DELETED",
}

export enum OrgRemoveOutsideCollaboratorAuditEntryMembershipType {
  BILLING_MANAGER = "BILLING_MANAGER",
  OUTSIDE_COLLABORATOR = "OUTSIDE_COLLABORATOR",
  UNAFFILIATED = "UNAFFILIATED",
}

export enum OrgRemoveOutsideCollaboratorAuditEntryReason {
  SAML_EXTERNAL_IDENTITY_MISSING = "SAML_EXTERNAL_IDENTITY_MISSING",
  TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE = "TWO_FACTOR_REQUIREMENT_NON_COMPLIANCE",
}

export enum OrgUpdateDefaultRepositoryPermissionAuditEntryPermission {
  ADMIN = "ADMIN",
  NONE = "NONE",
  READ = "READ",
  WRITE = "WRITE",
}

export enum OrgUpdateMemberAuditEntryPermission {
  ADMIN = "ADMIN",
  READ = "READ",
}

export enum OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility {
  ALL = "ALL",
  INTERNAL = "INTERNAL",
  NONE = "NONE",
  PRIVATE = "PRIVATE",
  PRIVATE_INTERNAL = "PRIVATE_INTERNAL",
  PUBLIC = "PUBLIC",
  PUBLIC_INTERNAL = "PUBLIC_INTERNAL",
  PUBLIC_PRIVATE = "PUBLIC_PRIVATE",
}

export enum OrganizationInvitationRole {
  ADMIN = "ADMIN",
  BILLING_MANAGER = "BILLING_MANAGER",
  DIRECT_MEMBER = "DIRECT_MEMBER",
  REINSTATE = "REINSTATE",
}

export enum OrganizationInvitationType {
  EMAIL = "EMAIL",
  USER = "USER",
}

export enum OrganizationMemberRole {
  ADMIN = "ADMIN",
  MEMBER = "MEMBER",
}

export enum OrganizationMembersCanCreateRepositoriesSettingValue {
  ALL = "ALL",
  DISABLED = "DISABLED",
  PRIVATE = "PRIVATE",
}

export enum OrganizationOrderField {
  CREATED_AT = "CREATED_AT",
  LOGIN = "LOGIN",
}

export enum PackageFileOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum PackageOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum PackageType {
  DEBIAN = "DEBIAN",
  DOCKER = "DOCKER",
  MAVEN = "MAVEN",
  NPM = "NPM",
  NUGET = "NUGET",
  PYPI = "PYPI",
  RUBYGEMS = "RUBYGEMS",
}

export enum PackageVersionOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum PinnableItemType {
  GIST = "GIST",
  ISSUE = "ISSUE",
  ORGANIZATION = "ORGANIZATION",
  PROJECT = "PROJECT",
  PULL_REQUEST = "PULL_REQUEST",
  REPOSITORY = "REPOSITORY",
  TEAM = "TEAM",
  USER = "USER",
}

export enum ProjectCardArchivedState {
  ARCHIVED = "ARCHIVED",
  NOT_ARCHIVED = "NOT_ARCHIVED",
}

export enum ProjectCardState {
  CONTENT_ONLY = "CONTENT_ONLY",
  NOTE_ONLY = "NOTE_ONLY",
  REDACTED = "REDACTED",
}

export enum ProjectColumnPurpose {
  DONE = "DONE",
  IN_PROGRESS = "IN_PROGRESS",
  TODO = "TODO",
}

export enum ProjectOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
  UPDATED_AT = "UPDATED_AT",
}

export enum ProjectState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

export enum ProjectTemplate {
  AUTOMATED_KANBAN_V2 = "AUTOMATED_KANBAN_V2",
  AUTOMATED_REVIEWS_KANBAN = "AUTOMATED_REVIEWS_KANBAN",
  BASIC_KANBAN = "BASIC_KANBAN",
  BUG_TRIAGE = "BUG_TRIAGE",
}

export enum PullRequestMergeMethod {
  MERGE = "MERGE",
  REBASE = "REBASE",
  SQUASH = "SQUASH",
}

export enum PullRequestOrderField {
  CREATED_AT = "CREATED_AT",
  UPDATED_AT = "UPDATED_AT",
}

export enum PullRequestReviewCommentState {
  PENDING = "PENDING",
  SUBMITTED = "SUBMITTED",
}

export enum PullRequestReviewDecision {
  APPROVED = "APPROVED",
  CHANGES_REQUESTED = "CHANGES_REQUESTED",
  REVIEW_REQUIRED = "REVIEW_REQUIRED",
}

export enum PullRequestReviewEvent {
  APPROVE = "APPROVE",
  COMMENT = "COMMENT",
  DISMISS = "DISMISS",
  REQUEST_CHANGES = "REQUEST_CHANGES",
}

export enum PullRequestReviewState {
  APPROVED = "APPROVED",
  CHANGES_REQUESTED = "CHANGES_REQUESTED",
  COMMENTED = "COMMENTED",
  DISMISSED = "DISMISSED",
  PENDING = "PENDING",
}

export enum PullRequestState {
  CLOSED = "CLOSED",
  MERGED = "MERGED",
  OPEN = "OPEN",
}

export enum PullRequestTimelineItemsItemType {
  ADDED_TO_PROJECT_EVENT = "ADDED_TO_PROJECT_EVENT",
  ASSIGNED_EVENT = "ASSIGNED_EVENT",
  AUTOMATIC_BASE_CHANGE_FAILED_EVENT = "AUTOMATIC_BASE_CHANGE_FAILED_EVENT",
  AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT = "AUTOMATIC_BASE_CHANGE_SUCCEEDED_EVENT",
  BASE_REF_CHANGED_EVENT = "BASE_REF_CHANGED_EVENT",
  BASE_REF_DELETED_EVENT = "BASE_REF_DELETED_EVENT",
  BASE_REF_FORCE_PUSHED_EVENT = "BASE_REF_FORCE_PUSHED_EVENT",
  CLOSED_EVENT = "CLOSED_EVENT",
  COMMENT_DELETED_EVENT = "COMMENT_DELETED_EVENT",
  CONNECTED_EVENT = "CONNECTED_EVENT",
  CONVERTED_NOTE_TO_ISSUE_EVENT = "CONVERTED_NOTE_TO_ISSUE_EVENT",
  CONVERT_TO_DRAFT_EVENT = "CONVERT_TO_DRAFT_EVENT",
  CROSS_REFERENCED_EVENT = "CROSS_REFERENCED_EVENT",
  DEMILESTONED_EVENT = "DEMILESTONED_EVENT",
  DEPLOYED_EVENT = "DEPLOYED_EVENT",
  DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT = "DEPLOYMENT_ENVIRONMENT_CHANGED_EVENT",
  DISCONNECTED_EVENT = "DISCONNECTED_EVENT",
  HEAD_REF_DELETED_EVENT = "HEAD_REF_DELETED_EVENT",
  HEAD_REF_FORCE_PUSHED_EVENT = "HEAD_REF_FORCE_PUSHED_EVENT",
  HEAD_REF_RESTORED_EVENT = "HEAD_REF_RESTORED_EVENT",
  ISSUE_COMMENT = "ISSUE_COMMENT",
  LABELED_EVENT = "LABELED_EVENT",
  LOCKED_EVENT = "LOCKED_EVENT",
  MARKED_AS_DUPLICATE_EVENT = "MARKED_AS_DUPLICATE_EVENT",
  MENTIONED_EVENT = "MENTIONED_EVENT",
  MERGED_EVENT = "MERGED_EVENT",
  MILESTONED_EVENT = "MILESTONED_EVENT",
  MOVED_COLUMNS_IN_PROJECT_EVENT = "MOVED_COLUMNS_IN_PROJECT_EVENT",
  PINNED_EVENT = "PINNED_EVENT",
  PULL_REQUEST_COMMIT = "PULL_REQUEST_COMMIT",
  PULL_REQUEST_COMMIT_COMMENT_THREAD = "PULL_REQUEST_COMMIT_COMMENT_THREAD",
  PULL_REQUEST_REVIEW = "PULL_REQUEST_REVIEW",
  PULL_REQUEST_REVIEW_THREAD = "PULL_REQUEST_REVIEW_THREAD",
  PULL_REQUEST_REVISION_MARKER = "PULL_REQUEST_REVISION_MARKER",
  READY_FOR_REVIEW_EVENT = "READY_FOR_REVIEW_EVENT",
  REFERENCED_EVENT = "REFERENCED_EVENT",
  REMOVED_FROM_PROJECT_EVENT = "REMOVED_FROM_PROJECT_EVENT",
  RENAMED_TITLE_EVENT = "RENAMED_TITLE_EVENT",
  REOPENED_EVENT = "REOPENED_EVENT",
  REVIEW_DISMISSED_EVENT = "REVIEW_DISMISSED_EVENT",
  REVIEW_REQUESTED_EVENT = "REVIEW_REQUESTED_EVENT",
  REVIEW_REQUEST_REMOVED_EVENT = "REVIEW_REQUEST_REMOVED_EVENT",
  SUBSCRIBED_EVENT = "SUBSCRIBED_EVENT",
  TRANSFERRED_EVENT = "TRANSFERRED_EVENT",
  UNASSIGNED_EVENT = "UNASSIGNED_EVENT",
  UNLABELED_EVENT = "UNLABELED_EVENT",
  UNLOCKED_EVENT = "UNLOCKED_EVENT",
  UNMARKED_AS_DUPLICATE_EVENT = "UNMARKED_AS_DUPLICATE_EVENT",
  UNPINNED_EVENT = "UNPINNED_EVENT",
  UNSUBSCRIBED_EVENT = "UNSUBSCRIBED_EVENT",
  USER_BLOCKED_EVENT = "USER_BLOCKED_EVENT",
}

export enum PullRequestUpdateState {
  CLOSED = "CLOSED",
  OPEN = "OPEN",
}

export enum ReactionContent {
  CONFUSED = "CONFUSED",
  EYES = "EYES",
  HEART = "HEART",
  HOORAY = "HOORAY",
  LAUGH = "LAUGH",
  ROCKET = "ROCKET",
  THUMBS_DOWN = "THUMBS_DOWN",
  THUMBS_UP = "THUMBS_UP",
}

export enum ReactionOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum RefOrderField {
  ALPHABETICAL = "ALPHABETICAL",
  TAG_COMMIT_DATE = "TAG_COMMIT_DATE",
}

export enum ReleaseOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
}

export enum RepoAccessAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoAddMemberAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoArchivedAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoChangeMergeSettingAuditEntryMergeType {
  MERGE = "MERGE",
  REBASE = "REBASE",
  SQUASH = "SQUASH",
}

export enum RepoCreateAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoDestroyAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepoRemoveMemberAuditEntryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum ReportedContentClassifiers {
  ABUSE = "ABUSE",
  DUPLICATE = "DUPLICATE",
  OFF_TOPIC = "OFF_TOPIC",
  OUTDATED = "OUTDATED",
  RESOLVED = "RESOLVED",
  SPAM = "SPAM",
}

export enum RepositoryAffiliation {
  COLLABORATOR = "COLLABORATOR",
  ORGANIZATION_MEMBER = "ORGANIZATION_MEMBER",
  OWNER = "OWNER",
}

export enum RepositoryContributionType {
  COMMIT = "COMMIT",
  ISSUE = "ISSUE",
  PULL_REQUEST = "PULL_REQUEST",
  PULL_REQUEST_REVIEW = "PULL_REQUEST_REVIEW",
  REPOSITORY = "REPOSITORY",
}

export enum RepositoryInteractionLimit {
  COLLABORATORS_ONLY = "COLLABORATORS_ONLY",
  CONTRIBUTORS_ONLY = "CONTRIBUTORS_ONLY",
  EXISTING_USERS = "EXISTING_USERS",
  NO_LIMIT = "NO_LIMIT",
}

export enum RepositoryInteractionLimitExpiry {
  ONE_DAY = "ONE_DAY",
  ONE_MONTH = "ONE_MONTH",
  ONE_WEEK = "ONE_WEEK",
  SIX_MONTHS = "SIX_MONTHS",
  THREE_DAYS = "THREE_DAYS",
}

export enum RepositoryInteractionLimitOrigin {
  ORGANIZATION = "ORGANIZATION",
  REPOSITORY = "REPOSITORY",
  USER = "USER",
}

export enum RepositoryInvitationOrderField {
  CREATED_AT = "CREATED_AT",
  INVITEE_LOGIN = "INVITEE_LOGIN",
}

export enum RepositoryLockReason {
  BILLING = "BILLING",
  MIGRATING = "MIGRATING",
  MOVING = "MOVING",
  RENAME = "RENAME",
}

export enum RepositoryOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
  PUSHED_AT = "PUSHED_AT",
  STARGAZERS = "STARGAZERS",
  UPDATED_AT = "UPDATED_AT",
}

export enum RepositoryPermission {
  ADMIN = "ADMIN",
  MAINTAIN = "MAINTAIN",
  READ = "READ",
  TRIAGE = "TRIAGE",
  WRITE = "WRITE",
}

export enum RepositoryPrivacy {
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RepositoryVisibility {
  INTERNAL = "INTERNAL",
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum RequestableCheckStatusState {
  COMPLETED = "COMPLETED",
  IN_PROGRESS = "IN_PROGRESS",
  QUEUED = "QUEUED",
}

export enum SamlDigestAlgorithm {
  SHA1 = "SHA1",
  SHA256 = "SHA256",
  SHA384 = "SHA384",
  SHA512 = "SHA512",
}

export enum SamlSignatureAlgorithm {
  RSA_SHA1 = "RSA_SHA1",
  RSA_SHA256 = "RSA_SHA256",
  RSA_SHA384 = "RSA_SHA384",
  RSA_SHA512 = "RSA_SHA512",
}

export enum SavedReplyOrderField {
  UPDATED_AT = "UPDATED_AT",
}

export enum SearchType {
  ISSUE = "ISSUE",
  REPOSITORY = "REPOSITORY",
  USER = "USER",
}

export enum SecurityAdvisoryEcosystem {
  COMPOSER = "COMPOSER",
  MAVEN = "MAVEN",
  NPM = "NPM",
  NUGET = "NUGET",
  PIP = "PIP",
  RUBYGEMS = "RUBYGEMS",
}

export enum SecurityAdvisoryIdentifierType {
  CVE = "CVE",
  GHSA = "GHSA",
}

export enum SecurityAdvisoryOrderField {
  PUBLISHED_AT = "PUBLISHED_AT",
  UPDATED_AT = "UPDATED_AT",
}

export enum SecurityAdvisorySeverity {
  CRITICAL = "CRITICAL",
  HIGH = "HIGH",
  LOW = "LOW",
  MODERATE = "MODERATE",
}

export enum SecurityVulnerabilityOrderField {
  UPDATED_AT = "UPDATED_AT",
}

export enum SponsorsTierOrderField {
  CREATED_AT = "CREATED_AT",
  MONTHLY_PRICE_IN_CENTS = "MONTHLY_PRICE_IN_CENTS",
}

export enum SponsorshipOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum SponsorshipPrivacy {
  PRIVATE = "PRIVATE",
  PUBLIC = "PUBLIC",
}

export enum StarOrderField {
  STARRED_AT = "STARRED_AT",
}

export enum StatusState {
  ERROR = "ERROR",
  EXPECTED = "EXPECTED",
  FAILURE = "FAILURE",
  PENDING = "PENDING",
  SUCCESS = "SUCCESS",
}

export enum SubscriptionState {
  IGNORED = "IGNORED",
  SUBSCRIBED = "SUBSCRIBED",
  UNSUBSCRIBED = "UNSUBSCRIBED",
}

export enum TeamDiscussionCommentOrderField {
  NUMBER = "NUMBER",
}

export enum TeamDiscussionOrderField {
  CREATED_AT = "CREATED_AT",
}

export enum TeamMemberOrderField {
  CREATED_AT = "CREATED_AT",
  LOGIN = "LOGIN",
}

export enum TeamMemberRole {
  MAINTAINER = "MAINTAINER",
  MEMBER = "MEMBER",
}

export enum TeamMembershipType {
  ALL = "ALL",
  CHILD_TEAM = "CHILD_TEAM",
  IMMEDIATE = "IMMEDIATE",
}

export enum TeamOrderField {
  NAME = "NAME",
}

export enum TeamPrivacy {
  SECRET = "SECRET",
  VISIBLE = "VISIBLE",
}

export enum TeamRepositoryOrderField {
  CREATED_AT = "CREATED_AT",
  NAME = "NAME",
  PERMISSION = "PERMISSION",
  PUSHED_AT = "PUSHED_AT",
  STARGAZERS = "STARGAZERS",
  UPDATED_AT = "UPDATED_AT",
}

export enum TeamRole {
  ADMIN = "ADMIN",
  MEMBER = "MEMBER",
}

export enum TopicSuggestionDeclineReason {
  NOT_RELEVANT = "NOT_RELEVANT",
  PERSONAL_PREFERENCE = "PERSONAL_PREFERENCE",
  TOO_GENERAL = "TOO_GENERAL",
  TOO_SPECIFIC = "TOO_SPECIFIC",
}

export enum UserBlockDuration {
  ONE_DAY = "ONE_DAY",
  ONE_MONTH = "ONE_MONTH",
  ONE_WEEK = "ONE_WEEK",
  PERMANENT = "PERMANENT",
  THREE_DAYS = "THREE_DAYS",
}

export enum UserStatusOrderField {
  UPDATED_AT = "UPDATED_AT",
}

export interface AcceptEnterpriseAdministratorInvitationInput {
  clientMutationId?: string;
  invitationId: string;
}

export interface AcceptTopicSuggestionInput {
  clientMutationId?: string;
  name: string;
  repositoryId: string;
}

export interface AddAssigneesToAssignableInput {
  assignableId: string;
  assigneeIds: string;
  clientMutationId?: string;
}

export interface AddCommentInput {
  body: string;
  clientMutationId?: string;
  subjectId: string;
}

export interface AddLabelsToLabelableInput {
  clientMutationId?: string;
  labelIds: string;
  labelableId: string;
}

export interface AddProjectCardInput {
  clientMutationId?: string;
  contentId?: string;
  note?: string;
  projectColumnId: string;
}

export interface AddProjectColumnInput {
  clientMutationId?: string;
  name: string;
  projectId: string;
}

export interface AddPullRequestReviewCommentInput {
  body: string;
  clientMutationId?: string;
  commitOID?: unknown;
  inReplyTo?: string;
  path?: string;
  position?: number;
  pullRequestId?: string;
  pullRequestReviewId?: string;
}

export interface AddPullRequestReviewInput {
  body?: string;
  clientMutationId?: string;
  comments?: DraftPullRequestReviewComment[];
  commitOID?: unknown;
  event?: PullRequestReviewEvent;
  pullRequestId: string;
  threads?: DraftPullRequestReviewThread[];
}

export interface AddPullRequestReviewThreadInput {
  body: string;
  clientMutationId?: string;
  line: number;
  path: string;
  pullRequestId?: string;
  pullRequestReviewId?: string;
  side?: DiffSide;
  startLine?: number;
  startSide?: DiffSide;
}

export interface AddReactionInput {
  clientMutationId?: string;
  content: ReactionContent;
  subjectId: string;
}

export interface AddStarInput {
  clientMutationId?: string;
  starrableId: string;
}

export interface ArchiveRepositoryInput {
  clientMutationId?: string;
  repositoryId: string;
}

export interface AuditLogOrder {
  direction?: OrderDirection;
  field?: AuditLogOrderField;
}

export interface CancelEnterpriseAdminInvitationInput {
  clientMutationId?: string;
  invitationId: string;
}

export interface ChangeUserStatusInput {
  clientMutationId?: string;
  emoji?: string;
  expiresAt?: unknown;
  limitedAvailability?: boolean;
  message?: string;
  organizationId?: string;
}

export interface CheckAnnotationData {
  annotationLevel: CheckAnnotationLevel;
  location: CheckAnnotationRange;
  message: string;
  path: string;
  rawDetails?: string;
  title?: string;
}

export interface CheckAnnotationRange {
  endColumn?: number;
  endLine: number;
  startColumn?: number;
  startLine: number;
}

export interface CheckRunAction {
  description: string;
  identifier: string;
  label: string;
}

export interface CheckRunFilter {
  appId?: number;
  checkName?: string;
  checkType?: CheckRunType;
  status?: CheckStatusState;
}

export interface CheckRunOutput {
  annotations?: CheckAnnotationData[];
  images?: CheckRunOutputImage[];
  summary: string;
  text?: string;
  title: string;
}

export interface CheckRunOutputImage {
  alt: string;
  caption?: string;
  imageUrl: unknown;
}

export interface CheckSuiteAutoTriggerPreference {
  appId: string;
  setting: boolean;
}

export interface CheckSuiteFilter {
  appId?: number;
  checkName?: string;
}

export interface ClearLabelsFromLabelableInput {
  clientMutationId?: string;
  labelableId: string;
}

export interface CloneProjectInput {
  body?: string;
  clientMutationId?: string;
  includeWorkflows: boolean;
  name: string;
  public?: boolean;
  sourceId: string;
  targetOwnerId: string;
}

export interface CloneTemplateRepositoryInput {
  clientMutationId?: string;
  description?: string;
  includeAllBranches?: boolean;
  name: string;
  ownerId: string;
  repositoryId: string;
  visibility: RepositoryVisibility;
}

export interface CloseIssueInput {
  clientMutationId?: string;
  issueId: string;
}

export interface ClosePullRequestInput {
  clientMutationId?: string;
  pullRequestId: string;
}

export interface CommitAuthor {
  emails?: string[];
  id?: string;
}

export interface CommitContributionOrder {
  direction: OrderDirection;
  field: CommitContributionOrderField;
}

export interface ContributionOrder {
  direction: OrderDirection;
}

export interface ConvertProjectCardNoteToIssueInput {
  body?: string;
  clientMutationId?: string;
  projectCardId: string;
  repositoryId: string;
  title?: string;
}

export interface CreateBranchProtectionRuleInput {
  allowsDeletions?: boolean;
  allowsForcePushes?: boolean;
  clientMutationId?: string;
  dismissesStaleReviews?: boolean;
  isAdminEnforced?: boolean;
  pattern: string;
  pushActorIds?: string[];
  repositoryId: string;
  requiredApprovingReviewCount?: number;
  requiredStatusCheckContexts?: string[];
  requiresApprovingReviews?: boolean;
  requiresCodeOwnerReviews?: boolean;
  requiresCommitSignatures?: boolean;
  requiresLinearHistory?: boolean;
  requiresStatusChecks?: boolean;
  requiresStrictStatusChecks?: boolean;
  restrictsPushes?: boolean;
  restrictsReviewDismissals?: boolean;
  reviewDismissalActorIds?: string[];
}

export interface CreateCheckRunInput {
  actions?: CheckRunAction[];
  clientMutationId?: string;
  completedAt?: unknown;
  conclusion?: CheckConclusionState;
  detailsUrl?: unknown;
  externalId?: string;
  headSha: unknown;
  name: string;
  output?: CheckRunOutput;
  repositoryId: string;
  startedAt?: unknown;
  status?: RequestableCheckStatusState;
}

export interface CreateCheckSuiteInput {
  clientMutationId?: string;
  headSha: unknown;
  repositoryId: string;
}

export interface CreateEnterpriseOrganizationInput {
  adminLogins: string;
  billingEmail: string;
  clientMutationId?: string;
  enterpriseId: string;
  login: string;
  profileName: string;
}

export interface CreateIpAllowListEntryInput {
  allowListValue: string;
  clientMutationId?: string;
  isActive: boolean;
  name?: string;
  ownerId: string;
}

export interface CreateIssueInput {
  assigneeIds?: string[];
  body?: string;
  clientMutationId?: string;
  issueTemplate?: string;
  labelIds?: string[];
  milestoneId?: string;
  projectIds?: string[];
  repositoryId: string;
  title: string;
}

export interface CreateProjectInput {
  body?: string;
  clientMutationId?: string;
  name: string;
  ownerId: string;
  repositoryIds?: string[];
  template?: ProjectTemplate;
}

export interface CreatePullRequestInput {
  baseRefName: string;
  body?: string;
  clientMutationId?: string;
  draft?: boolean;
  headRefName: string;
  maintainerCanModify?: boolean;
  repositoryId: string;
  title: string;
}

export interface CreateRefInput {
  clientMutationId?: string;
  name: string;
  oid: unknown;
  repositoryId: string;
}

export interface CreateRepositoryInput {
  clientMutationId?: string;
  description?: string;
  hasIssuesEnabled?: boolean;
  hasWikiEnabled?: boolean;
  homepageUrl?: unknown;
  name: string;
  ownerId?: string;
  teamId?: string;
  template?: boolean;
  visibility: RepositoryVisibility;
}

export interface CreateTeamDiscussionCommentInput {
  body: string;
  clientMutationId?: string;
  discussionId: string;
}

export interface CreateTeamDiscussionInput {
  body: string;
  clientMutationId?: string;
  private?: boolean;
  teamId: string;
  title: string;
}

export interface DeclineTopicSuggestionInput {
  clientMutationId?: string;
  name: string;
  reason: TopicSuggestionDeclineReason;
  repositoryId: string;
}

export interface DeleteBranchProtectionRuleInput {
  branchProtectionRuleId: string;
  clientMutationId?: string;
}

export interface DeleteDeploymentInput {
  clientMutationId?: string;
  id: string;
}

export interface DeleteIpAllowListEntryInput {
  clientMutationId?: string;
  ipAllowListEntryId: string;
}

export interface DeleteIssueCommentInput {
  clientMutationId?: string;
  id: string;
}

export interface DeleteIssueInput {
  clientMutationId?: string;
  issueId: string;
}

export interface DeleteProjectCardInput {
  cardId: string;
  clientMutationId?: string;
}

export interface DeleteProjectColumnInput {
  clientMutationId?: string;
  columnId: string;
}

export interface DeleteProjectInput {
  clientMutationId?: string;
  projectId: string;
}

export interface DeletePullRequestReviewCommentInput {
  clientMutationId?: string;
  id: string;
}

export interface DeletePullRequestReviewInput {
  clientMutationId?: string;
  pullRequestReviewId: string;
}

export interface DeleteRefInput {
  clientMutationId?: string;
  refId: string;
}

export interface DeleteTeamDiscussionCommentInput {
  clientMutationId?: string;
  id: string;
}

export interface DeleteTeamDiscussionInput {
  clientMutationId?: string;
  id: string;
}

export interface DeploymentOrder {
  direction: OrderDirection;
  field: DeploymentOrderField;
}

export interface DismissPullRequestReviewInput {
  clientMutationId?: string;
  message: string;
  pullRequestReviewId: string;
}

export interface DraftPullRequestReviewComment {
  body: string;
  path: string;
  position: number;
}

export interface DraftPullRequestReviewThread {
  body: string;
  line: number;
  path: string;
  side?: DiffSide;
  startLine?: number;
  startSide?: DiffSide;
}

export interface EnterpriseAdministratorInvitationOrder {
  direction: OrderDirection;
  field: EnterpriseAdministratorInvitationOrderField;
}

export interface EnterpriseMemberOrder {
  direction: OrderDirection;
  field: EnterpriseMemberOrderField;
}

export interface EnterpriseServerInstallationOrder {
  direction: OrderDirection;
  field: EnterpriseServerInstallationOrderField;
}

export interface EnterpriseServerUserAccountEmailOrder {
  direction: OrderDirection;
  field: EnterpriseServerUserAccountEmailOrderField;
}

export interface EnterpriseServerUserAccountOrder {
  direction: OrderDirection;
  field: EnterpriseServerUserAccountOrderField;
}

export interface EnterpriseServerUserAccountsUploadOrder {
  direction: OrderDirection;
  field: EnterpriseServerUserAccountsUploadOrderField;
}

export interface FollowUserInput {
  clientMutationId?: string;
  userId: string;
}

export interface GistOrder {
  direction: OrderDirection;
  field: GistOrderField;
}

export interface InviteEnterpriseAdminInput {
  clientMutationId?: string;
  email?: string;
  enterpriseId: string;
  invitee?: string;
  role?: EnterpriseAdministratorRole;
}

export interface IpAllowListEntryOrder {
  direction: OrderDirection;
  field: IpAllowListEntryOrderField;
}

export interface IssueCommentOrder {
  direction: OrderDirection;
  field: IssueCommentOrderField;
}

export interface IssueFilters {
  assignee?: string;
  createdBy?: string;
  labels?: string[];
  mentioned?: string;
  milestone?: string;
  since?: unknown;
  states?: IssueState[];
  viewerSubscribed?: boolean;
}

export interface IssueOrder {
  direction: OrderDirection;
  field: IssueOrderField;
}

export interface LabelOrder {
  direction: OrderDirection;
  field: LabelOrderField;
}

export interface LanguageOrder {
  direction: OrderDirection;
  field: LanguageOrderField;
}

export interface LinkRepositoryToProjectInput {
  clientMutationId?: string;
  projectId: string;
  repositoryId: string;
}

export interface LockLockableInput {
  clientMutationId?: string;
  lockReason?: LockReason;
  lockableId: string;
}

export interface MarkFileAsViewedInput {
  clientMutationId?: string;
  path: string;
  pullRequestId: string;
}

export interface MarkPullRequestReadyForReviewInput {
  clientMutationId?: string;
  pullRequestId: string;
}

export interface MergeBranchInput {
  authorEmail?: string;
  base: string;
  clientMutationId?: string;
  commitMessage?: string;
  head: string;
  repositoryId: string;
}

export interface MergePullRequestInput {
  authorEmail?: string;
  clientMutationId?: string;
  commitBody?: string;
  commitHeadline?: string;
  expectedHeadOid?: unknown;
  mergeMethod?: PullRequestMergeMethod;
  pullRequestId: string;
}

export interface MilestoneOrder {
  direction: OrderDirection;
  field: MilestoneOrderField;
}

export interface MinimizeCommentInput {
  classifier: ReportedContentClassifiers;
  clientMutationId?: string;
  subjectId: string;
}

export interface MoveProjectCardInput {
  afterCardId?: string;
  cardId: string;
  clientMutationId?: string;
  columnId: string;
}

export interface MoveProjectColumnInput {
  afterColumnId?: string;
  clientMutationId?: string;
  columnId: string;
}

export interface OrganizationOrder {
  direction: OrderDirection;
  field: OrganizationOrderField;
}

export interface PackageFileOrder {
  direction?: OrderDirection;
  field?: PackageFileOrderField;
}

export interface PackageOrder {
  direction?: OrderDirection;
  field?: PackageOrderField;
}

export interface PackageVersionOrder {
  direction?: OrderDirection;
  field?: PackageVersionOrderField;
}

export interface ProjectOrder {
  direction: OrderDirection;
  field: ProjectOrderField;
}

export interface PullRequestOrder {
  direction: OrderDirection;
  field: PullRequestOrderField;
}

export interface ReactionOrder {
  direction: OrderDirection;
  field: ReactionOrderField;
}

export interface RefOrder {
  direction: OrderDirection;
  field: RefOrderField;
}

export interface RegenerateEnterpriseIdentityProviderRecoveryCodesInput {
  clientMutationId?: string;
  enterpriseId: string;
}

export interface ReleaseOrder {
  direction: OrderDirection;
  field: ReleaseOrderField;
}

export interface RemoveAssigneesFromAssignableInput {
  assignableId: string;
  assigneeIds: string;
  clientMutationId?: string;
}

export interface RemoveEnterpriseAdminInput {
  clientMutationId?: string;
  enterpriseId: string;
  login: string;
}

export interface RemoveEnterpriseIdentityProviderInput {
  clientMutationId?: string;
  enterpriseId: string;
}

export interface RemoveEnterpriseOrganizationInput {
  clientMutationId?: string;
  enterpriseId: string;
  organizationId: string;
}

export interface RemoveLabelsFromLabelableInput {
  clientMutationId?: string;
  labelIds: string;
  labelableId: string;
}

export interface RemoveOutsideCollaboratorInput {
  clientMutationId?: string;
  organizationId: string;
  userId: string;
}

export interface RemoveReactionInput {
  clientMutationId?: string;
  content: ReactionContent;
  subjectId: string;
}

export interface RemoveStarInput {
  clientMutationId?: string;
  starrableId: string;
}

export interface ReopenIssueInput {
  clientMutationId?: string;
  issueId: string;
}

export interface ReopenPullRequestInput {
  clientMutationId?: string;
  pullRequestId: string;
}

export interface RepositoryInvitationOrder {
  direction: OrderDirection;
  field: RepositoryInvitationOrderField;
}

export interface RepositoryOrder {
  direction: OrderDirection;
  field: RepositoryOrderField;
}

export interface RequestReviewsInput {
  clientMutationId?: string;
  pullRequestId: string;
  teamIds?: string[];
  union?: boolean;
  userIds?: string[];
}

export interface RerequestCheckSuiteInput {
  checkSuiteId: string;
  clientMutationId?: string;
  repositoryId: string;
}

export interface ResolveReviewThreadInput {
  clientMutationId?: string;
  threadId: string;
}

export interface SavedReplyOrder {
  direction: OrderDirection;
  field: SavedReplyOrderField;
}

export interface SecurityAdvisoryIdentifierFilter {
  type: SecurityAdvisoryIdentifierType;
  value: string;
}

export interface SecurityAdvisoryOrder {
  direction: OrderDirection;
  field: SecurityAdvisoryOrderField;
}

export interface SecurityVulnerabilityOrder {
  direction: OrderDirection;
  field: SecurityVulnerabilityOrderField;
}

export interface SetEnterpriseIdentityProviderInput {
  clientMutationId?: string;
  digestMethod: SamlDigestAlgorithm;
  enterpriseId: string;
  idpCertificate: string;
  issuer?: string;
  signatureMethod: SamlSignatureAlgorithm;
  ssoUrl: unknown;
}

export interface SetOrganizationInteractionLimitInput {
  clientMutationId?: string;
  expiry?: RepositoryInteractionLimitExpiry;
  limit: RepositoryInteractionLimit;
  organizationId: string;
}

export interface SetRepositoryInteractionLimitInput {
  clientMutationId?: string;
  expiry?: RepositoryInteractionLimitExpiry;
  limit: RepositoryInteractionLimit;
  repositoryId: string;
}

export interface SetUserInteractionLimitInput {
  clientMutationId?: string;
  expiry?: RepositoryInteractionLimitExpiry;
  limit: RepositoryInteractionLimit;
  userId: string;
}

export interface SponsorsTierOrder {
  direction: OrderDirection;
  field: SponsorsTierOrderField;
}

export interface SponsorshipOrder {
  direction: OrderDirection;
  field: SponsorshipOrderField;
}

export interface StarOrder {
  direction: OrderDirection;
  field: StarOrderField;
}

export interface SubmitPullRequestReviewInput {
  body?: string;
  clientMutationId?: string;
  event: PullRequestReviewEvent;
  pullRequestId?: string;
  pullRequestReviewId?: string;
}

export interface TeamDiscussionCommentOrder {
  direction: OrderDirection;
  field: TeamDiscussionCommentOrderField;
}

export interface TeamDiscussionOrder {
  direction: OrderDirection;
  field: TeamDiscussionOrderField;
}

export interface TeamMemberOrder {
  direction: OrderDirection;
  field: TeamMemberOrderField;
}

export interface TeamOrder {
  direction: OrderDirection;
  field: TeamOrderField;
}

export interface TeamRepositoryOrder {
  direction: OrderDirection;
  field: TeamRepositoryOrderField;
}

export interface TransferIssueInput {
  clientMutationId?: string;
  issueId: string;
  repositoryId: string;
}

export interface UnarchiveRepositoryInput {
  clientMutationId?: string;
  repositoryId: string;
}

export interface UnfollowUserInput {
  clientMutationId?: string;
  userId: string;
}

export interface UnlinkRepositoryFromProjectInput {
  clientMutationId?: string;
  projectId: string;
  repositoryId: string;
}

export interface UnlockLockableInput {
  clientMutationId?: string;
  lockableId: string;
}

export interface UnmarkFileAsViewedInput {
  clientMutationId?: string;
  path: string;
  pullRequestId: string;
}

export interface UnmarkIssueAsDuplicateInput {
  canonicalId: string;
  clientMutationId?: string;
  duplicateId: string;
}

export interface UnminimizeCommentInput {
  clientMutationId?: string;
  subjectId: string;
}

export interface UnresolveReviewThreadInput {
  clientMutationId?: string;
  threadId: string;
}

export interface UpdateBranchProtectionRuleInput {
  allowsDeletions?: boolean;
  allowsForcePushes?: boolean;
  branchProtectionRuleId: string;
  clientMutationId?: string;
  dismissesStaleReviews?: boolean;
  isAdminEnforced?: boolean;
  pattern?: string;
  pushActorIds?: string[];
  requiredApprovingReviewCount?: number;
  requiredStatusCheckContexts?: string[];
  requiresApprovingReviews?: boolean;
  requiresCodeOwnerReviews?: boolean;
  requiresCommitSignatures?: boolean;
  requiresLinearHistory?: boolean;
  requiresStatusChecks?: boolean;
  requiresStrictStatusChecks?: boolean;
  restrictsPushes?: boolean;
  restrictsReviewDismissals?: boolean;
  reviewDismissalActorIds?: string[];
}

export interface UpdateCheckRunInput {
  actions?: CheckRunAction[];
  checkRunId: string;
  clientMutationId?: string;
  completedAt?: unknown;
  conclusion?: CheckConclusionState;
  detailsUrl?: unknown;
  externalId?: string;
  name?: string;
  output?: CheckRunOutput;
  repositoryId: string;
  startedAt?: unknown;
  status?: RequestableCheckStatusState;
}

export interface UpdateCheckSuitePreferencesInput {
  autoTriggerPreferences: CheckSuiteAutoTriggerPreference;
  clientMutationId?: string;
  repositoryId: string;
}

export interface UpdateEnterpriseAdministratorRoleInput {
  clientMutationId?: string;
  enterpriseId: string;
  login: string;
  role: EnterpriseAdministratorRole;
}

export interface UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseDefaultRepositoryPermissionSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseDefaultRepositoryPermissionSettingValue;
}

export interface UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanCreateRepositoriesSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  membersCanCreateInternalRepositories?: boolean;
  membersCanCreatePrivateRepositories?: boolean;
  membersCanCreatePublicRepositories?: boolean;
  membersCanCreateRepositoriesPolicyEnabled?: boolean;
  settingValue?: EnterpriseMembersCanCreateRepositoriesSettingValue;
}

export interface UpdateEnterpriseMembersCanDeleteIssuesSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanMakePurchasesSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseMembersCanMakePurchasesSettingValue;
}

export interface UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseOrganizationProjectsSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseProfileInput {
  clientMutationId?: string;
  description?: string;
  enterpriseId: string;
  location?: string;
  name?: string;
  websiteUrl?: string;
}

export interface UpdateEnterpriseRepositoryProjectsSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseTeamDiscussionsSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledDisabledSettingValue;
}

export interface UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput {
  clientMutationId?: string;
  enterpriseId: string;
  settingValue: EnterpriseEnabledSettingValue;
}

export interface UpdateIpAllowListEnabledSettingInput {
  clientMutationId?: string;
  ownerId: string;
  settingValue: IpAllowListEnabledSettingValue;
}

export interface UpdateIpAllowListEntryInput {
  allowListValue: string;
  clientMutationId?: string;
  ipAllowListEntryId: string;
  isActive: boolean;
  name?: string;
}

export interface UpdateIssueCommentInput {
  body: string;
  clientMutationId?: string;
  id: string;
}

export interface UpdateIssueInput {
  assigneeIds?: string[];
  body?: string;
  clientMutationId?: string;
  id: string;
  labelIds?: string[];
  milestoneId?: string;
  projectIds?: string[];
  state?: IssueState;
  title?: string;
}

export interface UpdateProjectCardInput {
  clientMutationId?: string;
  isArchived?: boolean;
  note?: string;
  projectCardId: string;
}

export interface UpdateProjectColumnInput {
  clientMutationId?: string;
  name: string;
  projectColumnId: string;
}

export interface UpdateProjectInput {
  body?: string;
  clientMutationId?: string;
  name?: string;
  projectId: string;
  public?: boolean;
  state?: ProjectState;
}

export interface UpdatePullRequestInput {
  assigneeIds?: string[];
  baseRefName?: string;
  body?: string;
  clientMutationId?: string;
  labelIds?: string[];
  maintainerCanModify?: boolean;
  milestoneId?: string;
  projectIds?: string[];
  pullRequestId: string;
  state?: PullRequestUpdateState;
  title?: string;
}

export interface UpdatePullRequestReviewCommentInput {
  body: string;
  clientMutationId?: string;
  pullRequestReviewCommentId: string;
}

export interface UpdatePullRequestReviewInput {
  body: string;
  clientMutationId?: string;
  pullRequestReviewId: string;
}

export interface UpdateRefInput {
  clientMutationId?: string;
  force?: boolean;
  oid: unknown;
  refId: string;
}

export interface UpdateRepositoryInput {
  clientMutationId?: string;
  description?: string;
  hasIssuesEnabled?: boolean;
  hasProjectsEnabled?: boolean;
  hasWikiEnabled?: boolean;
  homepageUrl?: unknown;
  name?: string;
  repositoryId: string;
  template?: boolean;
}

export interface UpdateSubscriptionInput {
  clientMutationId?: string;
  state: SubscriptionState;
  subscribableId: string;
}

export interface UpdateTeamDiscussionCommentInput {
  body: string;
  bodyVersion?: string;
  clientMutationId?: string;
  id: string;
}

export interface UpdateTeamDiscussionInput {
  body?: string;
  bodyVersion?: string;
  clientMutationId?: string;
  id: string;
  pinned?: boolean;
  title?: string;
}

export interface UpdateTopicsInput {
  clientMutationId?: string;
  repositoryId: string;
  topicNames: string;
}

export interface UserStatusOrder {
  direction: OrderDirection;
  field: UserStatusOrderField;
}

type IAssignee = IBot | IMannequin | IOrganization | IUser;

interface AssigneeSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends "Bot" | "Mannequin" | "Organization" | "User"
  >(
    type: F,
    select: (
      t: F extends "Bot"
        ? BotSelector
        : F extends "Mannequin"
        ? MannequinSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Assignee: AssigneeSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IAuditEntryActor = IBot | IOrganization | IUser;

interface AuditEntryActorSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Bot" | "Organization" | "User">(
    type: F,
    select: (
      t: F extends "Bot"
        ? BotSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const AuditEntryActor: AuditEntryActorSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type ICloser = ICommit | IPullRequest;

interface CloserSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Commit" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Commit"
        ? CommitSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Closer: CloserSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type ICreatedIssueOrRestrictedContribution =
  | ICreatedIssueContribution
  | IRestrictedContribution;

interface CreatedIssueOrRestrictedContributionSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends "CreatedIssueContribution" | "RestrictedContribution"
  >(
    type: F,
    select: (
      t: F extends "CreatedIssueContribution"
        ? CreatedIssueContributionSelector
        : F extends "RestrictedContribution"
        ? RestrictedContributionSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const CreatedIssueOrRestrictedContribution: CreatedIssueOrRestrictedContributionSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "CreatedIssueContribution": {
        return new InlineFragment(
          new NamedType("CreatedIssueContribution") as any,
          new SelectionSet(select(CreatedIssueContribution as any))
        );
      }

      case "RestrictedContribution": {
        return new InlineFragment(
          new NamedType("RestrictedContribution") as any,
          new SelectionSet(select(RestrictedContribution as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type ICreatedPullRequestOrRestrictedContribution =
  | ICreatedPullRequestContribution
  | IRestrictedContribution;

interface CreatedPullRequestOrRestrictedContributionSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends "CreatedPullRequestContribution" | "RestrictedContribution"
  >(
    type: F,
    select: (
      t: F extends "CreatedPullRequestContribution"
        ? CreatedPullRequestContributionSelector
        : F extends "RestrictedContribution"
        ? RestrictedContributionSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const CreatedPullRequestOrRestrictedContribution: CreatedPullRequestOrRestrictedContributionSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "CreatedPullRequestContribution": {
        return new InlineFragment(
          new NamedType("CreatedPullRequestContribution") as any,
          new SelectionSet(select(CreatedPullRequestContribution as any))
        );
      }

      case "RestrictedContribution": {
        return new InlineFragment(
          new NamedType("RestrictedContribution") as any,
          new SelectionSet(select(RestrictedContribution as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type ICreatedRepositoryOrRestrictedContribution =
  | ICreatedRepositoryContribution
  | IRestrictedContribution;

interface CreatedRepositoryOrRestrictedContributionSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends "CreatedRepositoryContribution" | "RestrictedContribution"
  >(
    type: F,
    select: (
      t: F extends "CreatedRepositoryContribution"
        ? CreatedRepositoryContributionSelector
        : F extends "RestrictedContribution"
        ? RestrictedContributionSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const CreatedRepositoryOrRestrictedContribution: CreatedRepositoryOrRestrictedContributionSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "CreatedRepositoryContribution": {
        return new InlineFragment(
          new NamedType("CreatedRepositoryContribution") as any,
          new SelectionSet(select(CreatedRepositoryContribution as any))
        );
      }

      case "RestrictedContribution": {
        return new InlineFragment(
          new NamedType("RestrictedContribution") as any,
          new SelectionSet(select(RestrictedContribution as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IEnterpriseMember = IEnterpriseUserAccount | IUser;

interface EnterpriseMemberSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "EnterpriseUserAccount" | "User">(
    type: F,
    select: (
      t: F extends "EnterpriseUserAccount"
        ? EnterpriseUserAccountSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const EnterpriseMember: EnterpriseMemberSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "EnterpriseUserAccount": {
        return new InlineFragment(
          new NamedType("EnterpriseUserAccount") as any,
          new SelectionSet(select(EnterpriseUserAccount as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IIpAllowListOwner = IEnterprise | IOrganization;

interface IpAllowListOwnerSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Enterprise" | "Organization">(
    type: F,
    select: (
      t: F extends "Enterprise"
        ? EnterpriseSelector
        : F extends "Organization"
        ? OrganizationSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const IpAllowListOwner: IpAllowListOwnerSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Enterprise": {
        return new InlineFragment(
          new NamedType("Enterprise") as any,
          new SelectionSet(select(Enterprise as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IIssueOrPullRequest = IIssue | IPullRequest;

interface IssueOrPullRequestSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const IssueOrPullRequest: IssueOrPullRequestSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IIssueTimelineItem =
  | IAssignedEvent
  | IClosedEvent
  | ICommit
  | ICrossReferencedEvent
  | IDemilestonedEvent
  | IIssueComment
  | ILabeledEvent
  | ILockedEvent
  | IMilestonedEvent
  | IReferencedEvent
  | IRenamedTitleEvent
  | IReopenedEvent
  | ISubscribedEvent
  | ITransferredEvent
  | IUnassignedEvent
  | IUnlabeledEvent
  | IUnlockedEvent
  | IUnsubscribedEvent
  | IUserBlockedEvent;

interface IssueTimelineItemSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends
      | "AssignedEvent"
      | "ClosedEvent"
      | "Commit"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "IssueComment"
      | "LabeledEvent"
      | "LockedEvent"
      | "MilestonedEvent"
      | "ReferencedEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "SubscribedEvent"
      | "TransferredEvent"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnsubscribedEvent"
      | "UserBlockedEvent"
  >(
    type: F,
    select: (
      t: F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "TransferredEvent"
        ? TransferredEventSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const IssueTimelineItem: IssueTimelineItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "TransferredEvent": {
        return new InlineFragment(
          new NamedType("TransferredEvent") as any,
          new SelectionSet(select(TransferredEvent as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IIssueTimelineItems =
  | IAddedToProjectEvent
  | IAssignedEvent
  | IClosedEvent
  | ICommentDeletedEvent
  | IConnectedEvent
  | IConvertedNoteToIssueEvent
  | ICrossReferencedEvent
  | IDemilestonedEvent
  | IDisconnectedEvent
  | IIssueComment
  | ILabeledEvent
  | ILockedEvent
  | IMarkedAsDuplicateEvent
  | IMentionedEvent
  | IMilestonedEvent
  | IMovedColumnsInProjectEvent
  | IPinnedEvent
  | IReferencedEvent
  | IRemovedFromProjectEvent
  | IRenamedTitleEvent
  | IReopenedEvent
  | ISubscribedEvent
  | ITransferredEvent
  | IUnassignedEvent
  | IUnlabeledEvent
  | IUnlockedEvent
  | IUnmarkedAsDuplicateEvent
  | IUnpinnedEvent
  | IUnsubscribedEvent
  | IUserBlockedEvent;

interface IssueTimelineItemsSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends
      | "AddedToProjectEvent"
      | "AssignedEvent"
      | "ClosedEvent"
      | "CommentDeletedEvent"
      | "ConnectedEvent"
      | "ConvertedNoteToIssueEvent"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "DisconnectedEvent"
      | "IssueComment"
      | "LabeledEvent"
      | "LockedEvent"
      | "MarkedAsDuplicateEvent"
      | "MentionedEvent"
      | "MilestonedEvent"
      | "MovedColumnsInProjectEvent"
      | "PinnedEvent"
      | "ReferencedEvent"
      | "RemovedFromProjectEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "SubscribedEvent"
      | "TransferredEvent"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnmarkedAsDuplicateEvent"
      | "UnpinnedEvent"
      | "UnsubscribedEvent"
      | "UserBlockedEvent"
  >(
    type: F,
    select: (
      t: F extends "AddedToProjectEvent"
        ? AddedToProjectEventSelector
        : F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "CommentDeletedEvent"
        ? CommentDeletedEventSelector
        : F extends "ConnectedEvent"
        ? ConnectedEventSelector
        : F extends "ConvertedNoteToIssueEvent"
        ? ConvertedNoteToIssueEventSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "DisconnectedEvent"
        ? DisconnectedEventSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "MarkedAsDuplicateEvent"
        ? MarkedAsDuplicateEventSelector
        : F extends "MentionedEvent"
        ? MentionedEventSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "MovedColumnsInProjectEvent"
        ? MovedColumnsInProjectEventSelector
        : F extends "PinnedEvent"
        ? PinnedEventSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "RemovedFromProjectEvent"
        ? RemovedFromProjectEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "TransferredEvent"
        ? TransferredEventSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnmarkedAsDuplicateEvent"
        ? UnmarkedAsDuplicateEventSelector
        : F extends "UnpinnedEvent"
        ? UnpinnedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const IssueTimelineItems: IssueTimelineItemsSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "AddedToProjectEvent": {
        return new InlineFragment(
          new NamedType("AddedToProjectEvent") as any,
          new SelectionSet(select(AddedToProjectEvent as any))
        );
      }

      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "CommentDeletedEvent": {
        return new InlineFragment(
          new NamedType("CommentDeletedEvent") as any,
          new SelectionSet(select(CommentDeletedEvent as any))
        );
      }

      case "ConnectedEvent": {
        return new InlineFragment(
          new NamedType("ConnectedEvent") as any,
          new SelectionSet(select(ConnectedEvent as any))
        );
      }

      case "ConvertedNoteToIssueEvent": {
        return new InlineFragment(
          new NamedType("ConvertedNoteToIssueEvent") as any,
          new SelectionSet(select(ConvertedNoteToIssueEvent as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "DisconnectedEvent": {
        return new InlineFragment(
          new NamedType("DisconnectedEvent") as any,
          new SelectionSet(select(DisconnectedEvent as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "MarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("MarkedAsDuplicateEvent") as any,
          new SelectionSet(select(MarkedAsDuplicateEvent as any))
        );
      }

      case "MentionedEvent": {
        return new InlineFragment(
          new NamedType("MentionedEvent") as any,
          new SelectionSet(select(MentionedEvent as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "MovedColumnsInProjectEvent": {
        return new InlineFragment(
          new NamedType("MovedColumnsInProjectEvent") as any,
          new SelectionSet(select(MovedColumnsInProjectEvent as any))
        );
      }

      case "PinnedEvent": {
        return new InlineFragment(
          new NamedType("PinnedEvent") as any,
          new SelectionSet(select(PinnedEvent as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "RemovedFromProjectEvent": {
        return new InlineFragment(
          new NamedType("RemovedFromProjectEvent") as any,
          new SelectionSet(select(RemovedFromProjectEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "TransferredEvent": {
        return new InlineFragment(
          new NamedType("TransferredEvent") as any,
          new SelectionSet(select(TransferredEvent as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnmarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("UnmarkedAsDuplicateEvent") as any,
          new SelectionSet(select(UnmarkedAsDuplicateEvent as any))
        );
      }

      case "UnpinnedEvent": {
        return new InlineFragment(
          new NamedType("UnpinnedEvent") as any,
          new SelectionSet(select(UnpinnedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IMilestoneItem = IIssue | IPullRequest;

interface MilestoneItemSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const MilestoneItem: MilestoneItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IOrgRestoreMemberAuditEntryMembership =
  | IOrgRestoreMemberMembershipOrganizationAuditEntryData
  | IOrgRestoreMemberMembershipRepositoryAuditEntryData
  | IOrgRestoreMemberMembershipTeamAuditEntryData;

interface OrgRestoreMemberAuditEntryMembershipSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends
      | "OrgRestoreMemberMembershipOrganizationAuditEntryData"
      | "OrgRestoreMemberMembershipRepositoryAuditEntryData"
      | "OrgRestoreMemberMembershipTeamAuditEntryData"
  >(
    type: F,
    select: (
      t: F extends "OrgRestoreMemberMembershipOrganizationAuditEntryData"
        ? OrgRestoreMemberMembershipOrganizationAuditEntryDataSelector
        : F extends "OrgRestoreMemberMembershipRepositoryAuditEntryData"
        ? OrgRestoreMemberMembershipRepositoryAuditEntryDataSelector
        : F extends "OrgRestoreMemberMembershipTeamAuditEntryData"
        ? OrgRestoreMemberMembershipTeamAuditEntryDataSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const OrgRestoreMemberAuditEntryMembership: OrgRestoreMemberAuditEntryMembershipSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "OrgRestoreMemberMembershipOrganizationAuditEntryData": {
        return new InlineFragment(
          new NamedType(
            "OrgRestoreMemberMembershipOrganizationAuditEntryData"
          ) as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipOrganizationAuditEntryData as any)
          )
        );
      }

      case "OrgRestoreMemberMembershipRepositoryAuditEntryData": {
        return new InlineFragment(
          new NamedType(
            "OrgRestoreMemberMembershipRepositoryAuditEntryData"
          ) as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipRepositoryAuditEntryData as any)
          )
        );
      }

      case "OrgRestoreMemberMembershipTeamAuditEntryData": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberMembershipTeamAuditEntryData") as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipTeamAuditEntryData as any)
          )
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IOrganizationAuditEntry =
  | IMembersCanDeleteReposClearAuditEntry
  | IMembersCanDeleteReposDisableAuditEntry
  | IMembersCanDeleteReposEnableAuditEntry
  | IOauthApplicationCreateAuditEntry
  | IOrgAddBillingManagerAuditEntry
  | IOrgAddMemberAuditEntry
  | IOrgBlockUserAuditEntry
  | IOrgConfigDisableCollaboratorsOnlyAuditEntry
  | IOrgConfigEnableCollaboratorsOnlyAuditEntry
  | IOrgCreateAuditEntry
  | IOrgDisableOauthAppRestrictionsAuditEntry
  | IOrgDisableSamlAuditEntry
  | IOrgDisableTwoFactorRequirementAuditEntry
  | IOrgEnableOauthAppRestrictionsAuditEntry
  | IOrgEnableSamlAuditEntry
  | IOrgEnableTwoFactorRequirementAuditEntry
  | IOrgInviteMemberAuditEntry
  | IOrgInviteToBusinessAuditEntry
  | IOrgOauthAppAccessApprovedAuditEntry
  | IOrgOauthAppAccessDeniedAuditEntry
  | IOrgOauthAppAccessRequestedAuditEntry
  | IOrgRemoveBillingManagerAuditEntry
  | IOrgRemoveMemberAuditEntry
  | IOrgRemoveOutsideCollaboratorAuditEntry
  | IOrgRestoreMemberAuditEntry
  | IOrgUnblockUserAuditEntry
  | IOrgUpdateDefaultRepositoryPermissionAuditEntry
  | IOrgUpdateMemberAuditEntry
  | IOrgUpdateMemberRepositoryCreationPermissionAuditEntry
  | IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry
  | IPrivateRepositoryForkingDisableAuditEntry
  | IPrivateRepositoryForkingEnableAuditEntry
  | IRepoAccessAuditEntry
  | IRepoAddMemberAuditEntry
  | IRepoAddTopicAuditEntry
  | IRepoArchivedAuditEntry
  | IRepoChangeMergeSettingAuditEntry
  | IRepoConfigDisableAnonymousGitAccessAuditEntry
  | IRepoConfigDisableCollaboratorsOnlyAuditEntry
  | IRepoConfigDisableContributorsOnlyAuditEntry
  | IRepoConfigDisableSockpuppetDisallowedAuditEntry
  | IRepoConfigEnableAnonymousGitAccessAuditEntry
  | IRepoConfigEnableCollaboratorsOnlyAuditEntry
  | IRepoConfigEnableContributorsOnlyAuditEntry
  | IRepoConfigEnableSockpuppetDisallowedAuditEntry
  | IRepoConfigLockAnonymousGitAccessAuditEntry
  | IRepoConfigUnlockAnonymousGitAccessAuditEntry
  | IRepoCreateAuditEntry
  | IRepoDestroyAuditEntry
  | IRepoRemoveMemberAuditEntry
  | IRepoRemoveTopicAuditEntry
  | IRepositoryVisibilityChangeDisableAuditEntry
  | IRepositoryVisibilityChangeEnableAuditEntry
  | ITeamAddMemberAuditEntry
  | ITeamAddRepositoryAuditEntry
  | ITeamChangeParentTeamAuditEntry
  | ITeamRemoveMemberAuditEntry
  | ITeamRemoveRepositoryAuditEntry;

interface OrganizationAuditEntrySelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "OauthApplicationCreateAuditEntry"
      | "OrgAddBillingManagerAuditEntry"
      | "OrgAddMemberAuditEntry"
      | "OrgBlockUserAuditEntry"
      | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
      | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
      | "OrgCreateAuditEntry"
      | "OrgDisableOauthAppRestrictionsAuditEntry"
      | "OrgDisableSamlAuditEntry"
      | "OrgDisableTwoFactorRequirementAuditEntry"
      | "OrgEnableOauthAppRestrictionsAuditEntry"
      | "OrgEnableSamlAuditEntry"
      | "OrgEnableTwoFactorRequirementAuditEntry"
      | "OrgInviteMemberAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
      | "OrgRemoveBillingManagerAuditEntry"
      | "OrgRemoveMemberAuditEntry"
      | "OrgRemoveOutsideCollaboratorAuditEntry"
      | "OrgRestoreMemberAuditEntry"
      | "OrgUnblockUserAuditEntry"
      | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
      | "OrgUpdateMemberAuditEntry"
      | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
      | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgAddBillingManagerAuditEntry"
        ? OrgAddBillingManagerAuditEntrySelector
        : F extends "OrgAddMemberAuditEntry"
        ? OrgAddMemberAuditEntrySelector
        : F extends "OrgBlockUserAuditEntry"
        ? OrgBlockUserAuditEntrySelector
        : F extends "OrgConfigDisableCollaboratorsOnlyAuditEntry"
        ? OrgConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgConfigEnableCollaboratorsOnlyAuditEntry"
        ? OrgConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgCreateAuditEntry"
        ? OrgCreateAuditEntrySelector
        : F extends "OrgDisableOauthAppRestrictionsAuditEntry"
        ? OrgDisableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgDisableSamlAuditEntry"
        ? OrgDisableSamlAuditEntrySelector
        : F extends "OrgDisableTwoFactorRequirementAuditEntry"
        ? OrgDisableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgEnableOauthAppRestrictionsAuditEntry"
        ? OrgEnableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgEnableSamlAuditEntry"
        ? OrgEnableSamlAuditEntrySelector
        : F extends "OrgEnableTwoFactorRequirementAuditEntry"
        ? OrgEnableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgInviteMemberAuditEntry"
        ? OrgInviteMemberAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : F extends "OrgRemoveBillingManagerAuditEntry"
        ? OrgRemoveBillingManagerAuditEntrySelector
        : F extends "OrgRemoveMemberAuditEntry"
        ? OrgRemoveMemberAuditEntrySelector
        : F extends "OrgRemoveOutsideCollaboratorAuditEntry"
        ? OrgRemoveOutsideCollaboratorAuditEntrySelector
        : F extends "OrgRestoreMemberAuditEntry"
        ? OrgRestoreMemberAuditEntrySelector
        : F extends "OrgUnblockUserAuditEntry"
        ? OrgUnblockUserAuditEntrySelector
        : F extends "OrgUpdateDefaultRepositoryPermissionAuditEntry"
        ? OrgUpdateDefaultRepositoryPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberAuditEntry"
        ? OrgUpdateMemberAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const OrganizationAuditEntry: OrganizationAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgAddBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgAddBillingManagerAuditEntry as any))
        );
      }

      case "OrgAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddMemberAuditEntry") as any,
          new SelectionSet(select(OrgAddMemberAuditEntry as any))
        );
      }

      case "OrgBlockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgBlockUserAuditEntry") as any,
          new SelectionSet(select(OrgBlockUserAuditEntry as any))
        );
      }

      case "OrgConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgCreateAuditEntry") as any,
          new SelectionSet(select(OrgCreateAuditEntry as any))
        );
      }

      case "OrgDisableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgDisableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableSamlAuditEntry") as any,
          new SelectionSet(select(OrgDisableSamlAuditEntry as any))
        );
      }

      case "OrgDisableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgEnableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgEnableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableSamlAuditEntry") as any,
          new SelectionSet(select(OrgEnableSamlAuditEntry as any))
        );
      }

      case "OrgEnableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgInviteMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteMemberAuditEntry") as any,
          new SelectionSet(select(OrgInviteMemberAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      case "OrgRemoveBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgRemoveBillingManagerAuditEntry as any))
        );
      }

      case "OrgRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveMemberAuditEntry") as any,
          new SelectionSet(select(OrgRemoveMemberAuditEntry as any))
        );
      }

      case "OrgRemoveOutsideCollaboratorAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveOutsideCollaboratorAuditEntry") as any,
          new SelectionSet(
            select(OrgRemoveOutsideCollaboratorAuditEntry as any)
          )
        );
      }

      case "OrgRestoreMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberAuditEntry") as any,
          new SelectionSet(select(OrgRestoreMemberAuditEntry as any))
        );
      }

      case "OrgUnblockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUnblockUserAuditEntry") as any,
          new SelectionSet(select(OrgUnblockUserAuditEntry as any))
        );
      }

      case "OrgUpdateDefaultRepositoryPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateDefaultRepositoryPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateDefaultRepositoryPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUpdateMemberAuditEntry") as any,
          new SelectionSet(select(OrgUpdateMemberAuditEntry as any))
        );
      }

      case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateMemberRepositoryCreationPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(
              OrgUpdateMemberRepositoryInvitationPermissionAuditEntry as any
            )
          )
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IPermissionGranter = IOrganization | IRepository | ITeam;

interface PermissionGranterSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends "Organization" | "Repository" | "Team"
  >(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "Team"
        ? TeamSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const PermissionGranter: PermissionGranterSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IPinnableItem = IGist | IRepository;

interface PinnableItemSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Gist" | "Repository">(
    type: F,
    select: (
      t: F extends "Gist"
        ? GistSelector
        : F extends "Repository"
        ? RepositorySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const PinnableItem: PinnableItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Gist": {
        return new InlineFragment(
          new NamedType("Gist") as any,
          new SelectionSet(select(Gist as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IProjectCardItem = IIssue | IPullRequest;

interface ProjectCardItemSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const ProjectCardItem: ProjectCardItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IPullRequestTimelineItem =
  | IAssignedEvent
  | IBaseRefDeletedEvent
  | IBaseRefForcePushedEvent
  | IClosedEvent
  | ICommit
  | ICommitCommentThread
  | ICrossReferencedEvent
  | IDemilestonedEvent
  | IDeployedEvent
  | IDeploymentEnvironmentChangedEvent
  | IHeadRefDeletedEvent
  | IHeadRefForcePushedEvent
  | IHeadRefRestoredEvent
  | IIssueComment
  | ILabeledEvent
  | ILockedEvent
  | IMergedEvent
  | IMilestonedEvent
  | IPullRequestReview
  | IPullRequestReviewComment
  | IPullRequestReviewThread
  | IReferencedEvent
  | IRenamedTitleEvent
  | IReopenedEvent
  | IReviewDismissedEvent
  | IReviewRequestRemovedEvent
  | IReviewRequestedEvent
  | ISubscribedEvent
  | IUnassignedEvent
  | IUnlabeledEvent
  | IUnlockedEvent
  | IUnsubscribedEvent
  | IUserBlockedEvent;

interface PullRequestTimelineItemSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends
      | "AssignedEvent"
      | "BaseRefDeletedEvent"
      | "BaseRefForcePushedEvent"
      | "ClosedEvent"
      | "Commit"
      | "CommitCommentThread"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "DeployedEvent"
      | "DeploymentEnvironmentChangedEvent"
      | "HeadRefDeletedEvent"
      | "HeadRefForcePushedEvent"
      | "HeadRefRestoredEvent"
      | "IssueComment"
      | "LabeledEvent"
      | "LockedEvent"
      | "MergedEvent"
      | "MilestonedEvent"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "PullRequestReviewThread"
      | "ReferencedEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "ReviewDismissedEvent"
      | "ReviewRequestRemovedEvent"
      | "ReviewRequestedEvent"
      | "SubscribedEvent"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnsubscribedEvent"
      | "UserBlockedEvent"
  >(
    type: F,
    select: (
      t: F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "BaseRefDeletedEvent"
        ? BaseRefDeletedEventSelector
        : F extends "BaseRefForcePushedEvent"
        ? BaseRefForcePushedEventSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "CommitCommentThread"
        ? CommitCommentThreadSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "DeployedEvent"
        ? DeployedEventSelector
        : F extends "DeploymentEnvironmentChangedEvent"
        ? DeploymentEnvironmentChangedEventSelector
        : F extends "HeadRefDeletedEvent"
        ? HeadRefDeletedEventSelector
        : F extends "HeadRefForcePushedEvent"
        ? HeadRefForcePushedEventSelector
        : F extends "HeadRefRestoredEvent"
        ? HeadRefRestoredEventSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "MergedEvent"
        ? MergedEventSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "PullRequestReviewThread"
        ? PullRequestReviewThreadSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "ReviewDismissedEvent"
        ? ReviewDismissedEventSelector
        : F extends "ReviewRequestRemovedEvent"
        ? ReviewRequestRemovedEventSelector
        : F extends "ReviewRequestedEvent"
        ? ReviewRequestedEventSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const PullRequestTimelineItem: PullRequestTimelineItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "BaseRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefDeletedEvent") as any,
          new SelectionSet(select(BaseRefDeletedEvent as any))
        );
      }

      case "BaseRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefForcePushedEvent") as any,
          new SelectionSet(select(BaseRefForcePushedEvent as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "CommitCommentThread": {
        return new InlineFragment(
          new NamedType("CommitCommentThread") as any,
          new SelectionSet(select(CommitCommentThread as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "DeployedEvent": {
        return new InlineFragment(
          new NamedType("DeployedEvent") as any,
          new SelectionSet(select(DeployedEvent as any))
        );
      }

      case "DeploymentEnvironmentChangedEvent": {
        return new InlineFragment(
          new NamedType("DeploymentEnvironmentChangedEvent") as any,
          new SelectionSet(select(DeploymentEnvironmentChangedEvent as any))
        );
      }

      case "HeadRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefDeletedEvent") as any,
          new SelectionSet(select(HeadRefDeletedEvent as any))
        );
      }

      case "HeadRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefForcePushedEvent") as any,
          new SelectionSet(select(HeadRefForcePushedEvent as any))
        );
      }

      case "HeadRefRestoredEvent": {
        return new InlineFragment(
          new NamedType("HeadRefRestoredEvent") as any,
          new SelectionSet(select(HeadRefRestoredEvent as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "MergedEvent": {
        return new InlineFragment(
          new NamedType("MergedEvent") as any,
          new SelectionSet(select(MergedEvent as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "PullRequestReviewThread": {
        return new InlineFragment(
          new NamedType("PullRequestReviewThread") as any,
          new SelectionSet(select(PullRequestReviewThread as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "ReviewDismissedEvent": {
        return new InlineFragment(
          new NamedType("ReviewDismissedEvent") as any,
          new SelectionSet(select(ReviewDismissedEvent as any))
        );
      }

      case "ReviewRequestRemovedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestRemovedEvent") as any,
          new SelectionSet(select(ReviewRequestRemovedEvent as any))
        );
      }

      case "ReviewRequestedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestedEvent") as any,
          new SelectionSet(select(ReviewRequestedEvent as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IPullRequestTimelineItems =
  | IAddedToProjectEvent
  | IAssignedEvent
  | IAutomaticBaseChangeFailedEvent
  | IAutomaticBaseChangeSucceededEvent
  | IBaseRefChangedEvent
  | IBaseRefDeletedEvent
  | IBaseRefForcePushedEvent
  | IClosedEvent
  | ICommentDeletedEvent
  | IConnectedEvent
  | IConvertToDraftEvent
  | IConvertedNoteToIssueEvent
  | ICrossReferencedEvent
  | IDemilestonedEvent
  | IDeployedEvent
  | IDeploymentEnvironmentChangedEvent
  | IDisconnectedEvent
  | IHeadRefDeletedEvent
  | IHeadRefForcePushedEvent
  | IHeadRefRestoredEvent
  | IIssueComment
  | ILabeledEvent
  | ILockedEvent
  | IMarkedAsDuplicateEvent
  | IMentionedEvent
  | IMergedEvent
  | IMilestonedEvent
  | IMovedColumnsInProjectEvent
  | IPinnedEvent
  | IPullRequestCommit
  | IPullRequestCommitCommentThread
  | IPullRequestReview
  | IPullRequestReviewThread
  | IPullRequestRevisionMarker
  | IReadyForReviewEvent
  | IReferencedEvent
  | IRemovedFromProjectEvent
  | IRenamedTitleEvent
  | IReopenedEvent
  | IReviewDismissedEvent
  | IReviewRequestRemovedEvent
  | IReviewRequestedEvent
  | ISubscribedEvent
  | ITransferredEvent
  | IUnassignedEvent
  | IUnlabeledEvent
  | IUnlockedEvent
  | IUnmarkedAsDuplicateEvent
  | IUnpinnedEvent
  | IUnsubscribedEvent
  | IUserBlockedEvent;

interface PullRequestTimelineItemsSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends
      | "AddedToProjectEvent"
      | "AssignedEvent"
      | "AutomaticBaseChangeFailedEvent"
      | "AutomaticBaseChangeSucceededEvent"
      | "BaseRefChangedEvent"
      | "BaseRefDeletedEvent"
      | "BaseRefForcePushedEvent"
      | "ClosedEvent"
      | "CommentDeletedEvent"
      | "ConnectedEvent"
      | "ConvertToDraftEvent"
      | "ConvertedNoteToIssueEvent"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "DeployedEvent"
      | "DeploymentEnvironmentChangedEvent"
      | "DisconnectedEvent"
      | "HeadRefDeletedEvent"
      | "HeadRefForcePushedEvent"
      | "HeadRefRestoredEvent"
      | "IssueComment"
      | "LabeledEvent"
      | "LockedEvent"
      | "MarkedAsDuplicateEvent"
      | "MentionedEvent"
      | "MergedEvent"
      | "MilestonedEvent"
      | "MovedColumnsInProjectEvent"
      | "PinnedEvent"
      | "PullRequestCommit"
      | "PullRequestCommitCommentThread"
      | "PullRequestReview"
      | "PullRequestReviewThread"
      | "PullRequestRevisionMarker"
      | "ReadyForReviewEvent"
      | "ReferencedEvent"
      | "RemovedFromProjectEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "ReviewDismissedEvent"
      | "ReviewRequestRemovedEvent"
      | "ReviewRequestedEvent"
      | "SubscribedEvent"
      | "TransferredEvent"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnmarkedAsDuplicateEvent"
      | "UnpinnedEvent"
      | "UnsubscribedEvent"
      | "UserBlockedEvent"
  >(
    type: F,
    select: (
      t: F extends "AddedToProjectEvent"
        ? AddedToProjectEventSelector
        : F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "AutomaticBaseChangeFailedEvent"
        ? AutomaticBaseChangeFailedEventSelector
        : F extends "AutomaticBaseChangeSucceededEvent"
        ? AutomaticBaseChangeSucceededEventSelector
        : F extends "BaseRefChangedEvent"
        ? BaseRefChangedEventSelector
        : F extends "BaseRefDeletedEvent"
        ? BaseRefDeletedEventSelector
        : F extends "BaseRefForcePushedEvent"
        ? BaseRefForcePushedEventSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "CommentDeletedEvent"
        ? CommentDeletedEventSelector
        : F extends "ConnectedEvent"
        ? ConnectedEventSelector
        : F extends "ConvertToDraftEvent"
        ? ConvertToDraftEventSelector
        : F extends "ConvertedNoteToIssueEvent"
        ? ConvertedNoteToIssueEventSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "DeployedEvent"
        ? DeployedEventSelector
        : F extends "DeploymentEnvironmentChangedEvent"
        ? DeploymentEnvironmentChangedEventSelector
        : F extends "DisconnectedEvent"
        ? DisconnectedEventSelector
        : F extends "HeadRefDeletedEvent"
        ? HeadRefDeletedEventSelector
        : F extends "HeadRefForcePushedEvent"
        ? HeadRefForcePushedEventSelector
        : F extends "HeadRefRestoredEvent"
        ? HeadRefRestoredEventSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "MarkedAsDuplicateEvent"
        ? MarkedAsDuplicateEventSelector
        : F extends "MentionedEvent"
        ? MentionedEventSelector
        : F extends "MergedEvent"
        ? MergedEventSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "MovedColumnsInProjectEvent"
        ? MovedColumnsInProjectEventSelector
        : F extends "PinnedEvent"
        ? PinnedEventSelector
        : F extends "PullRequestCommit"
        ? PullRequestCommitSelector
        : F extends "PullRequestCommitCommentThread"
        ? PullRequestCommitCommentThreadSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewThread"
        ? PullRequestReviewThreadSelector
        : F extends "PullRequestRevisionMarker"
        ? PullRequestRevisionMarkerSelector
        : F extends "ReadyForReviewEvent"
        ? ReadyForReviewEventSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "RemovedFromProjectEvent"
        ? RemovedFromProjectEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "ReviewDismissedEvent"
        ? ReviewDismissedEventSelector
        : F extends "ReviewRequestRemovedEvent"
        ? ReviewRequestRemovedEventSelector
        : F extends "ReviewRequestedEvent"
        ? ReviewRequestedEventSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "TransferredEvent"
        ? TransferredEventSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnmarkedAsDuplicateEvent"
        ? UnmarkedAsDuplicateEventSelector
        : F extends "UnpinnedEvent"
        ? UnpinnedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const PullRequestTimelineItems: PullRequestTimelineItemsSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "AddedToProjectEvent": {
        return new InlineFragment(
          new NamedType("AddedToProjectEvent") as any,
          new SelectionSet(select(AddedToProjectEvent as any))
        );
      }

      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "AutomaticBaseChangeFailedEvent": {
        return new InlineFragment(
          new NamedType("AutomaticBaseChangeFailedEvent") as any,
          new SelectionSet(select(AutomaticBaseChangeFailedEvent as any))
        );
      }

      case "AutomaticBaseChangeSucceededEvent": {
        return new InlineFragment(
          new NamedType("AutomaticBaseChangeSucceededEvent") as any,
          new SelectionSet(select(AutomaticBaseChangeSucceededEvent as any))
        );
      }

      case "BaseRefChangedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefChangedEvent") as any,
          new SelectionSet(select(BaseRefChangedEvent as any))
        );
      }

      case "BaseRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefDeletedEvent") as any,
          new SelectionSet(select(BaseRefDeletedEvent as any))
        );
      }

      case "BaseRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefForcePushedEvent") as any,
          new SelectionSet(select(BaseRefForcePushedEvent as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "CommentDeletedEvent": {
        return new InlineFragment(
          new NamedType("CommentDeletedEvent") as any,
          new SelectionSet(select(CommentDeletedEvent as any))
        );
      }

      case "ConnectedEvent": {
        return new InlineFragment(
          new NamedType("ConnectedEvent") as any,
          new SelectionSet(select(ConnectedEvent as any))
        );
      }

      case "ConvertToDraftEvent": {
        return new InlineFragment(
          new NamedType("ConvertToDraftEvent") as any,
          new SelectionSet(select(ConvertToDraftEvent as any))
        );
      }

      case "ConvertedNoteToIssueEvent": {
        return new InlineFragment(
          new NamedType("ConvertedNoteToIssueEvent") as any,
          new SelectionSet(select(ConvertedNoteToIssueEvent as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "DeployedEvent": {
        return new InlineFragment(
          new NamedType("DeployedEvent") as any,
          new SelectionSet(select(DeployedEvent as any))
        );
      }

      case "DeploymentEnvironmentChangedEvent": {
        return new InlineFragment(
          new NamedType("DeploymentEnvironmentChangedEvent") as any,
          new SelectionSet(select(DeploymentEnvironmentChangedEvent as any))
        );
      }

      case "DisconnectedEvent": {
        return new InlineFragment(
          new NamedType("DisconnectedEvent") as any,
          new SelectionSet(select(DisconnectedEvent as any))
        );
      }

      case "HeadRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefDeletedEvent") as any,
          new SelectionSet(select(HeadRefDeletedEvent as any))
        );
      }

      case "HeadRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefForcePushedEvent") as any,
          new SelectionSet(select(HeadRefForcePushedEvent as any))
        );
      }

      case "HeadRefRestoredEvent": {
        return new InlineFragment(
          new NamedType("HeadRefRestoredEvent") as any,
          new SelectionSet(select(HeadRefRestoredEvent as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "MarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("MarkedAsDuplicateEvent") as any,
          new SelectionSet(select(MarkedAsDuplicateEvent as any))
        );
      }

      case "MentionedEvent": {
        return new InlineFragment(
          new NamedType("MentionedEvent") as any,
          new SelectionSet(select(MentionedEvent as any))
        );
      }

      case "MergedEvent": {
        return new InlineFragment(
          new NamedType("MergedEvent") as any,
          new SelectionSet(select(MergedEvent as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "MovedColumnsInProjectEvent": {
        return new InlineFragment(
          new NamedType("MovedColumnsInProjectEvent") as any,
          new SelectionSet(select(MovedColumnsInProjectEvent as any))
        );
      }

      case "PinnedEvent": {
        return new InlineFragment(
          new NamedType("PinnedEvent") as any,
          new SelectionSet(select(PinnedEvent as any))
        );
      }

      case "PullRequestCommit": {
        return new InlineFragment(
          new NamedType("PullRequestCommit") as any,
          new SelectionSet(select(PullRequestCommit as any))
        );
      }

      case "PullRequestCommitCommentThread": {
        return new InlineFragment(
          new NamedType("PullRequestCommitCommentThread") as any,
          new SelectionSet(select(PullRequestCommitCommentThread as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewThread": {
        return new InlineFragment(
          new NamedType("PullRequestReviewThread") as any,
          new SelectionSet(select(PullRequestReviewThread as any))
        );
      }

      case "PullRequestRevisionMarker": {
        return new InlineFragment(
          new NamedType("PullRequestRevisionMarker") as any,
          new SelectionSet(select(PullRequestRevisionMarker as any))
        );
      }

      case "ReadyForReviewEvent": {
        return new InlineFragment(
          new NamedType("ReadyForReviewEvent") as any,
          new SelectionSet(select(ReadyForReviewEvent as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "RemovedFromProjectEvent": {
        return new InlineFragment(
          new NamedType("RemovedFromProjectEvent") as any,
          new SelectionSet(select(RemovedFromProjectEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "ReviewDismissedEvent": {
        return new InlineFragment(
          new NamedType("ReviewDismissedEvent") as any,
          new SelectionSet(select(ReviewDismissedEvent as any))
        );
      }

      case "ReviewRequestRemovedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestRemovedEvent") as any,
          new SelectionSet(select(ReviewRequestRemovedEvent as any))
        );
      }

      case "ReviewRequestedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestedEvent") as any,
          new SelectionSet(select(ReviewRequestedEvent as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "TransferredEvent": {
        return new InlineFragment(
          new NamedType("TransferredEvent") as any,
          new SelectionSet(select(TransferredEvent as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnmarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("UnmarkedAsDuplicateEvent") as any,
          new SelectionSet(select(UnmarkedAsDuplicateEvent as any))
        );
      }

      case "UnpinnedEvent": {
        return new InlineFragment(
          new NamedType("UnpinnedEvent") as any,
          new SelectionSet(select(UnpinnedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IPushAllowanceActor = IApp | ITeam | IUser;

interface PushAllowanceActorSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "App" | "Team" | "User">(
    type: F,
    select: (
      t: F extends "App"
        ? AppSelector
        : F extends "Team"
        ? TeamSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const PushAllowanceActor: PushAllowanceActorSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "App": {
        return new InlineFragment(
          new NamedType("App") as any,
          new SelectionSet(select(App as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IReferencedSubject = IIssue | IPullRequest;

interface ReferencedSubjectSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const ReferencedSubject: ReferencedSubjectSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IRenamedTitleSubject = IIssue | IPullRequest;

interface RenamedTitleSubjectSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RenamedTitleSubject: RenamedTitleSubjectSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IRequestedReviewer = IMannequin | ITeam | IUser;

interface RequestedReviewerSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Mannequin" | "Team" | "User">(
    type: F,
    select: (
      t: F extends "Mannequin"
        ? MannequinSelector
        : F extends "Team"
        ? TeamSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RequestedReviewer: RequestedReviewerSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IReviewDismissalAllowanceActor = ITeam | IUser;

interface ReviewDismissalAllowanceActorSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Team" | "User">(
    type: F,
    select: (
      t: F extends "Team"
        ? TeamSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const ReviewDismissalAllowanceActor: ReviewDismissalAllowanceActorSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type ISearchResultItem =
  | IApp
  | IIssue
  | IMarketplaceListing
  | IOrganization
  | IPullRequest
  | IRepository
  | IUser;

interface SearchResultItemSelector {
  __typename: () => Field<"__typename">;

  on: <
    T extends Array<Selection>,
    F extends
      | "App"
      | "Issue"
      | "MarketplaceListing"
      | "Organization"
      | "PullRequest"
      | "Repository"
      | "User"
  >(
    type: F,
    select: (
      t: F extends "App"
        ? AppSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "MarketplaceListing"
        ? MarketplaceListingSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const SearchResultItem: SearchResultItemSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "App": {
        return new InlineFragment(
          new NamedType("App") as any,
          new SelectionSet(select(App as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "MarketplaceListing": {
        return new InlineFragment(
          new NamedType("MarketplaceListing") as any,
          new SelectionSet(select(MarketplaceListing as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type ISponsor = IOrganization | IUser;

interface SponsorSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "Organization" | "User">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Sponsor: SponsorSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

type IStatusCheckRollupContext = ICheckRun | IStatusContext;

interface StatusCheckRollupContextSelector {
  __typename: () => Field<"__typename">;

  on: <T extends Array<Selection>, F extends "CheckRun" | "StatusContext">(
    type: F,
    select: (
      t: F extends "CheckRun"
        ? CheckRunSelector
        : F extends "StatusContext"
        ? StatusContextSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const StatusCheckRollupContext: StatusCheckRollupContextSelector = {
  __typename: () => new Field("__typename"),

  on: (type, select) => {
    switch (type) {
      case "CheckRun": {
        return new InlineFragment(
          new NamedType("CheckRun") as any,
          new SelectionSet(select(CheckRun as any))
        );
      }

      case "StatusContext": {
        return new InlineFragment(
          new NamedType("StatusContext") as any,
          new SelectionSet(select(StatusContext as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IAcceptEnterpriseAdministratorInvitationPayload {
  clientMutationId: string;
  invitation: IEnterpriseAdministratorInvitation;
  message: string;
}

interface AcceptEnterpriseAdministratorInvitationPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The invitation that was accepted.
   */

  invitation: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"invitation", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of accepting an administrator invitation.
   */

  message: () => Field<"message">;
}

export const AcceptEnterpriseAdministratorInvitationPayload: AcceptEnterpriseAdministratorInvitationPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The invitation that was accepted.
   */

  invitation: (select) =>
    new Field(
      "invitation",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description A message confirming the result of accepting an administrator invitation.
   */
  message: () => new Field("message"),
};

export interface IAcceptTopicSuggestionPayload {
  clientMutationId: string;
  topic: ITopic;
}

interface AcceptTopicSuggestionPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The accepted topic.
   */

  topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;
}

export const AcceptTopicSuggestionPayload: AcceptTopicSuggestionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The accepted topic.
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),
};

export interface IActor {
  __typename: string;
  avatarUrl: unknown;
  login: string;
  resourcePath: unknown;
  url: unknown;
}

interface ActorSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the actor's public avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description The username of the actor.
   */

  login: () => Field<"login">;

  /**
   * @description The HTTP path for this actor.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this actor.
   */

  url: () => Field<"url">;

  on: <
    T extends Array<Selection>,
    F extends
      | "Bot"
      | "EnterpriseUserAccount"
      | "Mannequin"
      | "Organization"
      | "User"
  >(
    type: F,
    select: (
      t: F extends "Bot"
        ? BotSelector
        : F extends "EnterpriseUserAccount"
        ? EnterpriseUserAccountSelector
        : F extends "Mannequin"
        ? MannequinSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Actor: ActorSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the actor's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description The username of the actor.
   */
  login: () => new Field("login"),

  /**
   * @description The HTTP path for this actor.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this actor.
   */
  url: () => new Field("url"),

  on: (type, select) => {
    switch (type) {
      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "EnterpriseUserAccount": {
        return new InlineFragment(
          new NamedType("EnterpriseUserAccount") as any,
          new SelectionSet(select(EnterpriseUserAccount as any))
        );
      }

      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IActorLocation {
  city: string;
  country: string;
  countryCode: string;
  region: string;
  regionCode: string;
}

interface ActorLocationSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description City
   */

  city: () => Field<"city">;

  /**
   * @description Country name
   */

  country: () => Field<"country">;

  /**
   * @description Country code
   */

  countryCode: () => Field<"countryCode">;

  /**
   * @description Region name
   */

  region: () => Field<"region">;

  /**
   * @description Region or state code
   */

  regionCode: () => Field<"regionCode">;
}

export const ActorLocation: ActorLocationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description City
   */
  city: () => new Field("city"),

  /**
   * @description Country name
   */
  country: () => new Field("country"),

  /**
   * @description Country code
   */
  countryCode: () => new Field("countryCode"),

  /**
   * @description Region name
   */
  region: () => new Field("region"),

  /**
   * @description Region or state code
   */
  regionCode: () => new Field("regionCode"),
};

export interface IAddAssigneesToAssignablePayload {
  assignable: IAssignable;
  clientMutationId: string;
}

interface AddAssigneesToAssignablePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The item that was assigned.
   */

  assignable: <T extends Array<Selection>>(
    select: (t: AssignableSelector) => T
  ) => Field<"assignable", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const AddAssigneesToAssignablePayload: AddAssigneesToAssignablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The item that was assigned.
   */

  assignable: (select) =>
    new Field(
      "assignable",
      undefined as never,
      new SelectionSet(select(Assignable))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IAddCommentPayload {
  clientMutationId: string;
  commentEdge: IIssueCommentEdge;
  subject: INode;
  timelineEdge: IIssueTimelineItemEdge;
}

interface AddCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The edge from the subject's comment connection.
   */

  commentEdge: <T extends Array<Selection>>(
    select: (t: IssueCommentEdgeSelector) => T
  ) => Field<"commentEdge", never, SelectionSet<T>>;

  /**
   * @description The subject
   */

  subject: <T extends Array<Selection>>(
    select: (t: NodeSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;

  /**
   * @description The edge from the subject's timeline connection.
   */

  timelineEdge: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemEdgeSelector) => T
  ) => Field<"timelineEdge", never, SelectionSet<T>>;
}

export const AddCommentPayload: AddCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The edge from the subject's comment connection.
   */

  commentEdge: (select) =>
    new Field(
      "commentEdge",
      undefined as never,
      new SelectionSet(select(IssueCommentEdge))
    ),

  /**
   * @description The subject
   */

  subject: (select) =>
    new Field("subject", undefined as never, new SelectionSet(select(Node))),

  /**
   * @description The edge from the subject's timeline connection.
   */

  timelineEdge: (select) =>
    new Field(
      "timelineEdge",
      undefined as never,
      new SelectionSet(select(IssueTimelineItemEdge))
    ),
};

export interface IAddLabelsToLabelablePayload {
  clientMutationId: string;
  labelable: ILabelable;
}

interface AddLabelsToLabelablePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The item that was labeled.
   */

  labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const AddLabelsToLabelablePayload: AddLabelsToLabelablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The item that was labeled.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface IAddProjectCardPayload {
  cardEdge: IProjectCardEdge;
  clientMutationId: string;
  projectColumn: IProjectColumn;
}

interface AddProjectCardPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The edge from the ProjectColumn's card connection.
   */

  cardEdge: <T extends Array<Selection>>(
    select: (t: ProjectCardEdgeSelector) => T
  ) => Field<"cardEdge", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The ProjectColumn
   */

  projectColumn: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"projectColumn", never, SelectionSet<T>>;
}

export const AddProjectCardPayload: AddProjectCardPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The edge from the ProjectColumn's card connection.
   */

  cardEdge: (select) =>
    new Field(
      "cardEdge",
      undefined as never,
      new SelectionSet(select(ProjectCardEdge))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The ProjectColumn
   */

  projectColumn: (select) =>
    new Field(
      "projectColumn",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),
};

export interface IAddProjectColumnPayload {
  clientMutationId: string;
  columnEdge: IProjectColumnEdge;
  project: IProject;
}

interface AddProjectColumnPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The edge from the project's column connection.
   */

  columnEdge: <T extends Array<Selection>>(
    select: (t: ProjectColumnEdgeSelector) => T
  ) => Field<"columnEdge", never, SelectionSet<T>>;

  /**
   * @description The project
   */

  project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const AddProjectColumnPayload: AddProjectColumnPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The edge from the project's column connection.
   */

  columnEdge: (select) =>
    new Field(
      "columnEdge",
      undefined as never,
      new SelectionSet(select(ProjectColumnEdge))
    ),

  /**
   * @description The project
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface IAddPullRequestReviewCommentPayload {
  clientMutationId: string;
  comment: IPullRequestReviewComment;
  commentEdge: IPullRequestReviewCommentEdge;
}

interface AddPullRequestReviewCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The newly created comment.
   */

  comment: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"comment", never, SelectionSet<T>>;

  /**
   * @description The edge from the review's comment connection.
   */

  commentEdge: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentEdgeSelector) => T
  ) => Field<"commentEdge", never, SelectionSet<T>>;
}

export const AddPullRequestReviewCommentPayload: AddPullRequestReviewCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The newly created comment.
   */

  comment: (select) =>
    new Field(
      "comment",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),

  /**
   * @description The edge from the review's comment connection.
   */

  commentEdge: (select) =>
    new Field(
      "commentEdge",
      undefined as never,
      new SelectionSet(select(PullRequestReviewCommentEdge))
    ),
};

export interface IAddPullRequestReviewPayload {
  clientMutationId: string;
  pullRequestReview: IPullRequestReview;
  reviewEdge: IPullRequestReviewEdge;
}

interface AddPullRequestReviewPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The newly created pull request review.
   */

  pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;

  /**
   * @description The edge from the pull request's review connection.
   */

  reviewEdge: <T extends Array<Selection>>(
    select: (t: PullRequestReviewEdgeSelector) => T
  ) => Field<"reviewEdge", never, SelectionSet<T>>;
}

export const AddPullRequestReviewPayload: AddPullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The newly created pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description The edge from the pull request's review connection.
   */

  reviewEdge: (select) =>
    new Field(
      "reviewEdge",
      undefined as never,
      new SelectionSet(select(PullRequestReviewEdge))
    ),
};

export interface IAddPullRequestReviewThreadPayload {
  clientMutationId: string;
  thread: IPullRequestReviewThread;
}

interface AddPullRequestReviewThreadPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The newly created thread.
   */

  thread: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"thread", never, SelectionSet<T>>;
}

export const AddPullRequestReviewThreadPayload: AddPullRequestReviewThreadPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The newly created thread.
   */

  thread: (select) =>
    new Field(
      "thread",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),
};

export interface IAddReactionPayload {
  clientMutationId: string;
  reaction: IReaction;
  subject: IReactable;
}

interface AddReactionPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The reaction object.
   */

  reaction: <T extends Array<Selection>>(
    select: (t: ReactionSelector) => T
  ) => Field<"reaction", never, SelectionSet<T>>;

  /**
   * @description The reactable subject.
   */

  subject: <T extends Array<Selection>>(
    select: (t: ReactableSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const AddReactionPayload: AddReactionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The reaction object.
   */

  reaction: (select) =>
    new Field(
      "reaction",
      undefined as never,
      new SelectionSet(select(Reaction))
    ),

  /**
   * @description The reactable subject.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(Reactable))
    ),
};

export interface IAddStarPayload {
  clientMutationId: string;
  starrable: IStarrable;
}

interface AddStarPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The starrable.
   */

  starrable: <T extends Array<Selection>>(
    select: (t: StarrableSelector) => T
  ) => Field<"starrable", never, SelectionSet<T>>;
}

export const AddStarPayload: AddStarPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The starrable.
   */

  starrable: (select) =>
    new Field(
      "starrable",
      undefined as never,
      new SelectionSet(select(Starrable))
    ),
};

export interface IAddedToProjectEvent extends INode {
  __typename: "AddedToProjectEvent";
  actor: IActor;
  createdAt: unknown;
  databaseId: number;
}

interface AddedToProjectEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;
}

export const isAddedToProjectEvent = (
  object: Record<string, any>
): object is Partial<IAddedToProjectEvent> => {
  return object.__typename === "AddedToProjectEvent";
};

export const AddedToProjectEvent: AddedToProjectEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface IApp extends INode {
  __typename: "App";
  createdAt: unknown;
  databaseId: number;
  description: string;
  logoBackgroundColor: string;
  logoUrl: unknown;
  name: string;
  slug: string;
  updatedAt: unknown;
  url: unknown;
}

interface AppSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The description of the app.
   */

  description: () => Field<"description">;

  id: () => Field<"id">;

  /**
   * @description The hex color code, without the leading '#', for the logo background.
   */

  logoBackgroundColor: () => Field<"logoBackgroundColor">;

  /**
   * @description A URL pointing to the app's logo.
   */

  logoUrl: (variables: { size: unknown }) => Field<"logoUrl", [/* @todo */]>;

  /**
   * @description The name of the app.
   */

  name: () => Field<"name">;

  /**
   * @description A slug based on the name of the app for use in URLs.
   */

  slug: () => Field<"slug">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The URL to the app's homepage.
   */

  url: () => Field<"url">;
}

export const isApp = (object: Record<string, any>): object is Partial<IApp> => {
  return object.__typename === "App";
};

export const App: AppSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The description of the app.
   */
  description: () => new Field("description"),
  id: () => new Field("id"),

  /**
   * @description The hex color code, without the leading '#', for the logo background.
   */
  logoBackgroundColor: () => new Field("logoBackgroundColor"),

  /**
   * @description A URL pointing to the app's logo.
   */
  logoUrl: (variables) => new Field("logoUrl"),

  /**
   * @description The name of the app.
   */
  name: () => new Field("name"),

  /**
   * @description A slug based on the name of the app for use in URLs.
   */
  slug: () => new Field("slug"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The URL to the app's homepage.
   */
  url: () => new Field("url"),
};

export interface IArchiveRepositoryPayload {
  clientMutationId: string;
  repository: IRepository;
}

interface ArchiveRepositoryPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository that was marked as archived.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const ArchiveRepositoryPayload: ArchiveRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository that was marked as archived.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IAssignable {
  __typename: string;
  assignees: IUserConnection;
}

interface AssignableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of Users assigned to this object.
   */

  assignees: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "assignees",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Assignable: AssignableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of Users assigned to this object.
   */

  assignees: (variables, select) =>
    new Field(
      "assignees",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IAssignedEvent extends INode {
  __typename: "AssignedEvent";
  actor: IActor;
  assignable: IAssignable;
  assignee: IAssignee;
  createdAt: unknown;
  user: IUser;
}

interface AssignedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the assignable associated with the event.
   */

  assignable: <T extends Array<Selection>>(
    select: (t: AssignableSelector) => T
  ) => Field<"assignable", never, SelectionSet<T>>;

  /**
   * @description Identifies the user or mannequin that was assigned.
   */

  assignee: <T extends Array<Selection>>(
    select: (t: AssigneeSelector) => T
  ) => Field<"assignee", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isAssignedEvent = (
  object: Record<string, any>
): object is Partial<IAssignedEvent> => {
  return object.__typename === "AssignedEvent";
};

export const AssignedEvent: AssignedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the assignable associated with the event.
   */

  assignable: (select) =>
    new Field(
      "assignable",
      undefined as never,
      new SelectionSet(select(Assignable))
    ),

  /**
   * @description Identifies the user or mannequin that was assigned.
   */

  assignee: (select) =>
    new Field(
      "assignee",
      undefined as never,
      new SelectionSet(select(Assignee))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the user who was assigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IAuditEntry {
  __typename: string;
  action: string;
  actor: IAuditEntryActor;
  actorIp: string;
  actorLocation: IActorLocation;
  actorLogin: string;
  actorResourcePath: unknown;
  actorUrl: unknown;
  createdAt: unknown;
  operationType: OperationType;
  user: IUser;
  userLogin: string;
  userResourcePath: unknown;
  userUrl: unknown;
}

interface AuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;

  on: <
    T extends Array<Selection>,
    F extends
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "OauthApplicationCreateAuditEntry"
      | "OrgAddBillingManagerAuditEntry"
      | "OrgAddMemberAuditEntry"
      | "OrgBlockUserAuditEntry"
      | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
      | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
      | "OrgCreateAuditEntry"
      | "OrgDisableOauthAppRestrictionsAuditEntry"
      | "OrgDisableSamlAuditEntry"
      | "OrgDisableTwoFactorRequirementAuditEntry"
      | "OrgEnableOauthAppRestrictionsAuditEntry"
      | "OrgEnableSamlAuditEntry"
      | "OrgEnableTwoFactorRequirementAuditEntry"
      | "OrgInviteMemberAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
      | "OrgRemoveBillingManagerAuditEntry"
      | "OrgRemoveMemberAuditEntry"
      | "OrgRemoveOutsideCollaboratorAuditEntry"
      | "OrgRestoreMemberAuditEntry"
      | "OrgUnblockUserAuditEntry"
      | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
      | "OrgUpdateMemberAuditEntry"
      | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
      | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgAddBillingManagerAuditEntry"
        ? OrgAddBillingManagerAuditEntrySelector
        : F extends "OrgAddMemberAuditEntry"
        ? OrgAddMemberAuditEntrySelector
        : F extends "OrgBlockUserAuditEntry"
        ? OrgBlockUserAuditEntrySelector
        : F extends "OrgConfigDisableCollaboratorsOnlyAuditEntry"
        ? OrgConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgConfigEnableCollaboratorsOnlyAuditEntry"
        ? OrgConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgCreateAuditEntry"
        ? OrgCreateAuditEntrySelector
        : F extends "OrgDisableOauthAppRestrictionsAuditEntry"
        ? OrgDisableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgDisableSamlAuditEntry"
        ? OrgDisableSamlAuditEntrySelector
        : F extends "OrgDisableTwoFactorRequirementAuditEntry"
        ? OrgDisableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgEnableOauthAppRestrictionsAuditEntry"
        ? OrgEnableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgEnableSamlAuditEntry"
        ? OrgEnableSamlAuditEntrySelector
        : F extends "OrgEnableTwoFactorRequirementAuditEntry"
        ? OrgEnableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgInviteMemberAuditEntry"
        ? OrgInviteMemberAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : F extends "OrgRemoveBillingManagerAuditEntry"
        ? OrgRemoveBillingManagerAuditEntrySelector
        : F extends "OrgRemoveMemberAuditEntry"
        ? OrgRemoveMemberAuditEntrySelector
        : F extends "OrgRemoveOutsideCollaboratorAuditEntry"
        ? OrgRemoveOutsideCollaboratorAuditEntrySelector
        : F extends "OrgRestoreMemberAuditEntry"
        ? OrgRestoreMemberAuditEntrySelector
        : F extends "OrgUnblockUserAuditEntry"
        ? OrgUnblockUserAuditEntrySelector
        : F extends "OrgUpdateDefaultRepositoryPermissionAuditEntry"
        ? OrgUpdateDefaultRepositoryPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberAuditEntry"
        ? OrgUpdateMemberAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const AuditEntry: AuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  on: (type, select) => {
    switch (type) {
      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgAddBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgAddBillingManagerAuditEntry as any))
        );
      }

      case "OrgAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddMemberAuditEntry") as any,
          new SelectionSet(select(OrgAddMemberAuditEntry as any))
        );
      }

      case "OrgBlockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgBlockUserAuditEntry") as any,
          new SelectionSet(select(OrgBlockUserAuditEntry as any))
        );
      }

      case "OrgConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgCreateAuditEntry") as any,
          new SelectionSet(select(OrgCreateAuditEntry as any))
        );
      }

      case "OrgDisableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgDisableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableSamlAuditEntry") as any,
          new SelectionSet(select(OrgDisableSamlAuditEntry as any))
        );
      }

      case "OrgDisableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgEnableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgEnableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableSamlAuditEntry") as any,
          new SelectionSet(select(OrgEnableSamlAuditEntry as any))
        );
      }

      case "OrgEnableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgInviteMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteMemberAuditEntry") as any,
          new SelectionSet(select(OrgInviteMemberAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      case "OrgRemoveBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgRemoveBillingManagerAuditEntry as any))
        );
      }

      case "OrgRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveMemberAuditEntry") as any,
          new SelectionSet(select(OrgRemoveMemberAuditEntry as any))
        );
      }

      case "OrgRemoveOutsideCollaboratorAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveOutsideCollaboratorAuditEntry") as any,
          new SelectionSet(
            select(OrgRemoveOutsideCollaboratorAuditEntry as any)
          )
        );
      }

      case "OrgRestoreMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberAuditEntry") as any,
          new SelectionSet(select(OrgRestoreMemberAuditEntry as any))
        );
      }

      case "OrgUnblockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUnblockUserAuditEntry") as any,
          new SelectionSet(select(OrgUnblockUserAuditEntry as any))
        );
      }

      case "OrgUpdateDefaultRepositoryPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateDefaultRepositoryPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateDefaultRepositoryPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUpdateMemberAuditEntry") as any,
          new SelectionSet(select(OrgUpdateMemberAuditEntry as any))
        );
      }

      case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateMemberRepositoryCreationPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(
              OrgUpdateMemberRepositoryInvitationPermissionAuditEntry as any
            )
          )
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IAutomaticBaseChangeFailedEvent extends INode {
  __typename: "AutomaticBaseChangeFailedEvent";
  actor: IActor;
  createdAt: unknown;
  newBase: string;
  oldBase: string;
  pullRequest: IPullRequest;
}

interface AutomaticBaseChangeFailedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The new base for this PR
   */

  newBase: () => Field<"newBase">;

  /**
   * @description The old base for this PR
   */

  oldBase: () => Field<"oldBase">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isAutomaticBaseChangeFailedEvent = (
  object: Record<string, any>
): object is Partial<IAutomaticBaseChangeFailedEvent> => {
  return object.__typename === "AutomaticBaseChangeFailedEvent";
};

export const AutomaticBaseChangeFailedEvent: AutomaticBaseChangeFailedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The new base for this PR
   */
  newBase: () => new Field("newBase"),

  /**
   * @description The old base for this PR
   */
  oldBase: () => new Field("oldBase"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IAutomaticBaseChangeSucceededEvent extends INode {
  __typename: "AutomaticBaseChangeSucceededEvent";
  actor: IActor;
  createdAt: unknown;
  newBase: string;
  oldBase: string;
  pullRequest: IPullRequest;
}

interface AutomaticBaseChangeSucceededEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The new base for this PR
   */

  newBase: () => Field<"newBase">;

  /**
   * @description The old base for this PR
   */

  oldBase: () => Field<"oldBase">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isAutomaticBaseChangeSucceededEvent = (
  object: Record<string, any>
): object is Partial<IAutomaticBaseChangeSucceededEvent> => {
  return object.__typename === "AutomaticBaseChangeSucceededEvent";
};

export const AutomaticBaseChangeSucceededEvent: AutomaticBaseChangeSucceededEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The new base for this PR
   */
  newBase: () => new Field("newBase"),

  /**
   * @description The old base for this PR
   */
  oldBase: () => new Field("oldBase"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IBaseRefChangedEvent extends INode {
  __typename: "BaseRefChangedEvent";
  actor: IActor;
  createdAt: unknown;
  currentRefName: string;
  databaseId: number;
  previousRefName: string;
  pullRequest: IPullRequest;
}

interface BaseRefChangedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the name of the base ref for the pull request after it was changed.
   */

  currentRefName: () => Field<"currentRefName">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description Identifies the name of the base ref for the pull request before it was changed.
   */

  previousRefName: () => Field<"previousRefName">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isBaseRefChangedEvent = (
  object: Record<string, any>
): object is Partial<IBaseRefChangedEvent> => {
  return object.__typename === "BaseRefChangedEvent";
};

export const BaseRefChangedEvent: BaseRefChangedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the name of the base ref for the pull request after it was changed.
   */
  currentRefName: () => new Field("currentRefName"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description Identifies the name of the base ref for the pull request before it was changed.
   */
  previousRefName: () => new Field("previousRefName"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IBaseRefDeletedEvent extends INode {
  __typename: "BaseRefDeletedEvent";
  actor: IActor;
  baseRefName: string;
  createdAt: unknown;
  pullRequest: IPullRequest;
}

interface BaseRefDeletedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the Ref associated with the `base_ref_deleted` event.
   */

  baseRefName: () => Field<"baseRefName">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isBaseRefDeletedEvent = (
  object: Record<string, any>
): object is Partial<IBaseRefDeletedEvent> => {
  return object.__typename === "BaseRefDeletedEvent";
};

export const BaseRefDeletedEvent: BaseRefDeletedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the name of the Ref associated with the `base_ref_deleted` event.
   */
  baseRefName: () => new Field("baseRefName"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IBaseRefForcePushedEvent extends INode {
  __typename: "BaseRefForcePushedEvent";
  actor: IActor;
  afterCommit: ICommit;
  beforeCommit: ICommit;
  createdAt: unknown;
  pullRequest: IPullRequest;
  ref: IRef;
}

interface BaseRefForcePushedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the after commit SHA for the 'base_ref_force_pushed' event.
   */

  afterCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"afterCommit", never, SelectionSet<T>>;

  /**
   * @description Identifies the before commit SHA for the 'base_ref_force_pushed' event.
   */

  beforeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"beforeCommit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the fully qualified ref name for the 'base_ref_force_pushed' event.
   */

  ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const isBaseRefForcePushedEvent = (
  object: Record<string, any>
): object is Partial<IBaseRefForcePushedEvent> => {
  return object.__typename === "BaseRefForcePushedEvent";
};

export const BaseRefForcePushedEvent: BaseRefForcePushedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the after commit SHA for the 'base_ref_force_pushed' event.
   */

  afterCommit: (select) =>
    new Field(
      "afterCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Identifies the before commit SHA for the 'base_ref_force_pushed' event.
   */

  beforeCommit: (select) =>
    new Field(
      "beforeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the fully qualified ref name for the 'base_ref_force_pushed' event.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IBlame {
  ranges: IBlameRange[];
}

interface BlameSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The list of ranges from a Git blame.
   */

  ranges: <T extends Array<Selection>>(
    select: (t: BlameRangeSelector) => T
  ) => Field<"ranges", never, SelectionSet<T>>;
}

export const Blame: BlameSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The list of ranges from a Git blame.
   */

  ranges: (select) =>
    new Field(
      "ranges",
      undefined as never,
      new SelectionSet(select(BlameRange))
    ),
};

export interface IBlameRange {
  age: number;
  commit: ICommit;
  endingLine: number;
  startingLine: number;
}

interface BlameRangeSelector {
  __typename: () => Field<"__typename">;

  /**
     * @description Identifies the recency of the change, from 1 (new) to 10 (old). This is
calculated as a 2-quantile and determines the length of distance between the
median age of all the changes in the file and the recency of the current
range's change.
     */

  age: () => Field<"age">;

  /**
   * @description Identifies the line author
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description The ending line for the range
   */

  endingLine: () => Field<"endingLine">;

  /**
   * @description The starting line for the range
   */

  startingLine: () => Field<"startingLine">;
}

export const BlameRange: BlameRangeSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Identifies the recency of the change, from 1 (new) to 10 (old). This is
calculated as a 2-quantile and determines the length of distance between the
median age of all the changes in the file and the recency of the current
range's change.
     */
  age: () => new Field("age"),

  /**
   * @description Identifies the line author
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description The ending line for the range
   */
  endingLine: () => new Field("endingLine"),

  /**
   * @description The starting line for the range
   */
  startingLine: () => new Field("startingLine"),
};

export interface IBlob extends IGitObject, INode {
  __typename: "Blob";
  byteSize: number;
  isBinary: boolean;
  isTruncated: boolean;
  text: string;
}

interface BlobSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description Byte size of Blob object
   */

  byteSize: () => Field<"byteSize">;

  /**
   * @description The HTTP path for this Git object
   */

  commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  commitUrl: () => Field<"commitUrl">;

  id: () => Field<"id">;

  /**
   * @description Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding.
   */

  isBinary: () => Field<"isBinary">;

  /**
   * @description Indicates whether the contents is truncated
   */

  isTruncated: () => Field<"isTruncated">;

  /**
   * @description The Git object ID
   */

  oid: () => Field<"oid">;

  /**
   * @description The Repository the Git object belongs to
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description UTF8 text data or null if the Blob is binary
   */

  text: () => Field<"text">;
}

export const isBlob = (
  object: Record<string, any>
): object is Partial<IBlob> => {
  return object.__typename === "Blob";
};

export const Blob: BlobSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description Byte size of Blob object
   */
  byteSize: () => new Field("byteSize"),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),
  id: () => new Field("id"),

  /**
   * @description Indicates whether the Blob is binary or text. Returns null if unable to determine the encoding.
   */
  isBinary: () => new Field("isBinary"),

  /**
   * @description Indicates whether the contents is truncated
   */
  isTruncated: () => new Field("isTruncated"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The Repository the Git object belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description UTF8 text data or null if the Blob is binary
   */
  text: () => new Field("text"),
};

export interface IBot extends IActor, INode, IUniformResourceLocatable {
  __typename: "Bot";
  createdAt: unknown;
  databaseId: number;
  updatedAt: unknown;
}

interface BotSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the GitHub App's public avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description The username of the actor.
   */

  login: () => Field<"login">;

  /**
   * @description The HTTP path for this bot
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this bot
   */

  url: () => Field<"url">;
}

export const isBot = (object: Record<string, any>): object is Partial<IBot> => {
  return object.__typename === "Bot";
};

export const Bot: BotSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the GitHub App's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The username of the actor.
   */
  login: () => new Field("login"),

  /**
   * @description The HTTP path for this bot
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this bot
   */
  url: () => new Field("url"),
};

export interface IBranchProtectionRule extends INode {
  __typename: "BranchProtectionRule";
  allowsDeletions: boolean;
  allowsForcePushes: boolean;
  branchProtectionRuleConflicts: IBranchProtectionRuleConflictConnection;
  creator: IActor;
  databaseId: number;
  dismissesStaleReviews: boolean;
  isAdminEnforced: boolean;
  matchingRefs: IRefConnection;
  pattern: string;
  pushAllowances: IPushAllowanceConnection;
  repository: IRepository;
  requiredApprovingReviewCount: number;
  requiredStatusCheckContexts: string[];
  requiresApprovingReviews: boolean;
  requiresCodeOwnerReviews: boolean;
  requiresCommitSignatures: boolean;
  requiresLinearHistory: boolean;
  requiresStatusChecks: boolean;
  requiresStrictStatusChecks: boolean;
  restrictsPushes: boolean;
  restrictsReviewDismissals: boolean;
  reviewDismissalAllowances: IReviewDismissalAllowanceConnection;
}

interface BranchProtectionRuleSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Can this branch be deleted.
   */

  allowsDeletions: () => Field<"allowsDeletions">;

  /**
   * @description Are force pushes allowed on this branch.
   */

  allowsForcePushes: () => Field<"allowsForcePushes">;

  /**
   * @description A list of conflicts matching branches protection rule and other branch protection rules
   */

  branchProtectionRuleConflicts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: BranchProtectionRuleConflictConnectionSelector) => T
  ) => Field<
    "branchProtectionRuleConflicts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The actor who created this branch protection rule.
   */

  creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description Will new commits pushed to matching branches dismiss pull request review approvals.
   */

  dismissesStaleReviews: () => Field<"dismissesStaleReviews">;

  id: () => Field<"id">;

  /**
   * @description Can admins overwrite branch protection.
   */

  isAdminEnforced: () => Field<"isAdminEnforced">;

  /**
   * @description Repository refs that are protected by this rule
   */

  matchingRefs: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: RefConnectionSelector) => T
  ) => Field<
    "matchingRefs",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the protection rule pattern.
   */

  pattern: () => Field<"pattern">;

  /**
   * @description A list push allowances for this branch protection rule.
   */

  pushAllowances: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PushAllowanceConnectionSelector) => T
  ) => Field<
    "pushAllowances",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this branch protection rule.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description Number of approving reviews required to update matching branches.
   */

  requiredApprovingReviewCount: () => Field<"requiredApprovingReviewCount">;

  /**
   * @description List of required status check contexts that must pass for commits to be accepted to matching branches.
   */

  requiredStatusCheckContexts: () => Field<"requiredStatusCheckContexts">;

  /**
   * @description Are approving reviews required to update matching branches.
   */

  requiresApprovingReviews: () => Field<"requiresApprovingReviews">;

  /**
   * @description Are reviews from code owners required to update matching branches.
   */

  requiresCodeOwnerReviews: () => Field<"requiresCodeOwnerReviews">;

  /**
   * @description Are commits required to be signed.
   */

  requiresCommitSignatures: () => Field<"requiresCommitSignatures">;

  /**
   * @description Are merge commits prohibited from being pushed to this branch.
   */

  requiresLinearHistory: () => Field<"requiresLinearHistory">;

  /**
   * @description Are status checks required to update matching branches.
   */

  requiresStatusChecks: () => Field<"requiresStatusChecks">;

  /**
   * @description Are branches required to be up to date before merging.
   */

  requiresStrictStatusChecks: () => Field<"requiresStrictStatusChecks">;

  /**
   * @description Is pushing to matching branches restricted.
   */

  restrictsPushes: () => Field<"restrictsPushes">;

  /**
   * @description Is dismissal of pull request reviews restricted.
   */

  restrictsReviewDismissals: () => Field<"restrictsReviewDismissals">;

  /**
   * @description A list review dismissal allowances for this branch protection rule.
   */

  reviewDismissalAllowances: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ReviewDismissalAllowanceConnectionSelector) => T
  ) => Field<
    "reviewDismissalAllowances",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;
}

export const isBranchProtectionRule = (
  object: Record<string, any>
): object is Partial<IBranchProtectionRule> => {
  return object.__typename === "BranchProtectionRule";
};

export const BranchProtectionRule: BranchProtectionRuleSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Can this branch be deleted.
   */
  allowsDeletions: () => new Field("allowsDeletions"),

  /**
   * @description Are force pushes allowed on this branch.
   */
  allowsForcePushes: () => new Field("allowsForcePushes"),

  /**
   * @description A list of conflicts matching branches protection rule and other branch protection rules
   */

  branchProtectionRuleConflicts: (variables, select) =>
    new Field(
      "branchProtectionRuleConflicts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(BranchProtectionRuleConflictConnection))
    ),

  /**
   * @description The actor who created this branch protection rule.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description Will new commits pushed to matching branches dismiss pull request review approvals.
   */
  dismissesStaleReviews: () => new Field("dismissesStaleReviews"),
  id: () => new Field("id"),

  /**
   * @description Can admins overwrite branch protection.
   */
  isAdminEnforced: () => new Field("isAdminEnforced"),

  /**
   * @description Repository refs that are protected by this rule
   */

  matchingRefs: (variables, select) =>
    new Field(
      "matchingRefs",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(RefConnection))
    ),

  /**
   * @description Identifies the protection rule pattern.
   */
  pattern: () => new Field("pattern"),

  /**
   * @description A list push allowances for this branch protection rule.
   */

  pushAllowances: (variables, select) =>
    new Field(
      "pushAllowances",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PushAllowanceConnection))
    ),

  /**
   * @description The repository associated with this branch protection rule.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Number of approving reviews required to update matching branches.
   */
  requiredApprovingReviewCount: () => new Field("requiredApprovingReviewCount"),

  /**
   * @description List of required status check contexts that must pass for commits to be accepted to matching branches.
   */
  requiredStatusCheckContexts: () => new Field("requiredStatusCheckContexts"),

  /**
   * @description Are approving reviews required to update matching branches.
   */
  requiresApprovingReviews: () => new Field("requiresApprovingReviews"),

  /**
   * @description Are reviews from code owners required to update matching branches.
   */
  requiresCodeOwnerReviews: () => new Field("requiresCodeOwnerReviews"),

  /**
   * @description Are commits required to be signed.
   */
  requiresCommitSignatures: () => new Field("requiresCommitSignatures"),

  /**
   * @description Are merge commits prohibited from being pushed to this branch.
   */
  requiresLinearHistory: () => new Field("requiresLinearHistory"),

  /**
   * @description Are status checks required to update matching branches.
   */
  requiresStatusChecks: () => new Field("requiresStatusChecks"),

  /**
   * @description Are branches required to be up to date before merging.
   */
  requiresStrictStatusChecks: () => new Field("requiresStrictStatusChecks"),

  /**
   * @description Is pushing to matching branches restricted.
   */
  restrictsPushes: () => new Field("restrictsPushes"),

  /**
   * @description Is dismissal of pull request reviews restricted.
   */
  restrictsReviewDismissals: () => new Field("restrictsReviewDismissals"),

  /**
   * @description A list review dismissal allowances for this branch protection rule.
   */

  reviewDismissalAllowances: (variables, select) =>
    new Field(
      "reviewDismissalAllowances",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ReviewDismissalAllowanceConnection))
    ),
};

export interface IBranchProtectionRuleConflict {
  branchProtectionRule: IBranchProtectionRule;
  conflictingBranchProtectionRule: IBranchProtectionRule;
  ref: IRef;
}

interface BranchProtectionRuleConflictSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the branch protection rule.
   */

  branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  /**
   * @description Identifies the conflicting branch protection rule.
   */

  conflictingBranchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"conflictingBranchProtectionRule", never, SelectionSet<T>>;

  /**
   * @description Identifies the branch ref that has conflicting rules
   */

  ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const BranchProtectionRuleConflict: BranchProtectionRuleConflictSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the branch protection rule.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description Identifies the conflicting branch protection rule.
   */

  conflictingBranchProtectionRule: (select) =>
    new Field(
      "conflictingBranchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description Identifies the branch ref that has conflicting rules
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IBranchProtectionRuleConflictConnection {
  edges: IBranchProtectionRuleConflictEdge[];
  nodes: IBranchProtectionRuleConflict[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface BranchProtectionRuleConflictConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleConflictEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleConflictSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const BranchProtectionRuleConflictConnection: BranchProtectionRuleConflictConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(BranchProtectionRuleConflictEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(BranchProtectionRuleConflict))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IBranchProtectionRuleConflictEdge {
  cursor: string;
  node: IBranchProtectionRuleConflict;
}

interface BranchProtectionRuleConflictEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleConflictSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const BranchProtectionRuleConflictEdge: BranchProtectionRuleConflictEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(BranchProtectionRuleConflict))
    ),
};

export interface IBranchProtectionRuleConnection {
  edges: IBranchProtectionRuleEdge[];
  nodes: IBranchProtectionRule[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface BranchProtectionRuleConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const BranchProtectionRuleConnection: BranchProtectionRuleConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(BranchProtectionRuleEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IBranchProtectionRuleEdge {
  cursor: string;
  node: IBranchProtectionRule;
}

interface BranchProtectionRuleEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const BranchProtectionRuleEdge: BranchProtectionRuleEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),
};

export interface ICancelEnterpriseAdminInvitationPayload {
  clientMutationId: string;
  invitation: IEnterpriseAdministratorInvitation;
  message: string;
}

interface CancelEnterpriseAdminInvitationPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The invitation that was canceled.
   */

  invitation: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"invitation", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of canceling an administrator invitation.
   */

  message: () => Field<"message">;
}

export const CancelEnterpriseAdminInvitationPayload: CancelEnterpriseAdminInvitationPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The invitation that was canceled.
   */

  invitation: (select) =>
    new Field(
      "invitation",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description A message confirming the result of canceling an administrator invitation.
   */
  message: () => new Field("message"),
};

export interface IChangeUserStatusPayload {
  clientMutationId: string;
  status: IUserStatus;
}

interface ChangeUserStatusPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description Your updated status.
   */

  status: <T extends Array<Selection>>(
    select: (t: UserStatusSelector) => T
  ) => Field<"status", never, SelectionSet<T>>;
}

export const ChangeUserStatusPayload: ChangeUserStatusPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description Your updated status.
   */

  status: (select) =>
    new Field(
      "status",
      undefined as never,
      new SelectionSet(select(UserStatus))
    ),
};

export interface ICheckAnnotation {
  annotationLevel: CheckAnnotationLevel;
  blobUrl: unknown;
  databaseId: number;
  location: ICheckAnnotationSpan;
  message: string;
  path: string;
  rawDetails: string;
  title: string;
}

interface CheckAnnotationSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The annotation's severity level.
   */

  annotationLevel: () => Field<"annotationLevel">;

  /**
   * @description The path to the file that this annotation was made on.
   */

  blobUrl: () => Field<"blobUrl">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The position of this annotation.
   */

  location: <T extends Array<Selection>>(
    select: (t: CheckAnnotationSpanSelector) => T
  ) => Field<"location", never, SelectionSet<T>>;

  /**
   * @description The annotation's message.
   */

  message: () => Field<"message">;

  /**
   * @description The path that this annotation was made on.
   */

  path: () => Field<"path">;

  /**
   * @description Additional information about the annotation.
   */

  rawDetails: () => Field<"rawDetails">;

  /**
   * @description The annotation's title
   */

  title: () => Field<"title">;
}

export const CheckAnnotation: CheckAnnotationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The annotation's severity level.
   */
  annotationLevel: () => new Field("annotationLevel"),

  /**
   * @description The path to the file that this annotation was made on.
   */
  blobUrl: () => new Field("blobUrl"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The position of this annotation.
   */

  location: (select) =>
    new Field(
      "location",
      undefined as never,
      new SelectionSet(select(CheckAnnotationSpan))
    ),

  /**
   * @description The annotation's message.
   */
  message: () => new Field("message"),

  /**
   * @description The path that this annotation was made on.
   */
  path: () => new Field("path"),

  /**
   * @description Additional information about the annotation.
   */
  rawDetails: () => new Field("rawDetails"),

  /**
   * @description The annotation's title
   */
  title: () => new Field("title"),
};

export interface ICheckAnnotationConnection {
  edges: ICheckAnnotationEdge[];
  nodes: ICheckAnnotation[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CheckAnnotationConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CheckAnnotationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CheckAnnotationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CheckAnnotationConnection: CheckAnnotationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CheckAnnotationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CheckAnnotation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICheckAnnotationEdge {
  cursor: string;
  node: ICheckAnnotation;
}

interface CheckAnnotationEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CheckAnnotationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CheckAnnotationEdge: CheckAnnotationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CheckAnnotation))
    ),
};

export interface ICheckAnnotationPosition {
  column: number;
  line: number;
}

interface CheckAnnotationPositionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Column number (1 indexed).
   */

  column: () => Field<"column">;

  /**
   * @description Line number (1 indexed).
   */

  line: () => Field<"line">;
}

export const CheckAnnotationPosition: CheckAnnotationPositionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Column number (1 indexed).
   */
  column: () => new Field("column"),

  /**
   * @description Line number (1 indexed).
   */
  line: () => new Field("line"),
};

export interface ICheckAnnotationSpan {
  end: ICheckAnnotationPosition;
  start: ICheckAnnotationPosition;
}

interface CheckAnnotationSpanSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description End position (inclusive).
   */

  end: <T extends Array<Selection>>(
    select: (t: CheckAnnotationPositionSelector) => T
  ) => Field<"end", never, SelectionSet<T>>;

  /**
   * @description Start position (inclusive).
   */

  start: <T extends Array<Selection>>(
    select: (t: CheckAnnotationPositionSelector) => T
  ) => Field<"start", never, SelectionSet<T>>;
}

export const CheckAnnotationSpan: CheckAnnotationSpanSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description End position (inclusive).
   */

  end: (select) =>
    new Field(
      "end",
      undefined as never,
      new SelectionSet(select(CheckAnnotationPosition))
    ),

  /**
   * @description Start position (inclusive).
   */

  start: (select) =>
    new Field(
      "start",
      undefined as never,
      new SelectionSet(select(CheckAnnotationPosition))
    ),
};

export interface ICheckRun extends INode, IUniformResourceLocatable {
  __typename: "CheckRun";
  annotations: ICheckAnnotationConnection;
  checkSuite: ICheckSuite;
  completedAt: unknown;
  conclusion: CheckConclusionState;
  databaseId: number;
  detailsUrl: unknown;
  externalId: string;
  name: string;
  permalink: unknown;
  repository: IRepository;
  startedAt: unknown;
  status: CheckStatusState;
  summary: string;
  text: string;
  title: string;
}

interface CheckRunSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The check run's annotations
   */

  annotations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CheckAnnotationConnectionSelector) => T
  ) => Field<
    "annotations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The check suite that this run is a part of.
   */

  checkSuite: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"checkSuite", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the check run was completed.
   */

  completedAt: () => Field<"completedAt">;

  /**
   * @description The conclusion of the check run.
   */

  conclusion: () => Field<"conclusion">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The URL from which to find full details of the check run on the integrator's site.
   */

  detailsUrl: () => Field<"detailsUrl">;

  /**
   * @description A reference for the check run on the integrator's system.
   */

  externalId: () => Field<"externalId">;

  id: () => Field<"id">;

  /**
   * @description The name of the check for this check run.
   */

  name: () => Field<"name">;

  /**
   * @description The permalink to the check run summary.
   */

  permalink: () => Field<"permalink">;

  /**
   * @description The repository associated with this check run.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this check run.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the check run was started.
   */

  startedAt: () => Field<"startedAt">;

  /**
   * @description The current status of the check run.
   */

  status: () => Field<"status">;

  /**
   * @description A string representing the check run's summary
   */

  summary: () => Field<"summary">;

  /**
   * @description A string representing the check run's text
   */

  text: () => Field<"text">;

  /**
   * @description A string representing the check run
   */

  title: () => Field<"title">;

  /**
   * @description The HTTP URL for this check run.
   */

  url: () => Field<"url">;
}

export const isCheckRun = (
  object: Record<string, any>
): object is Partial<ICheckRun> => {
  return object.__typename === "CheckRun";
};

export const CheckRun: CheckRunSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The check run's annotations
   */

  annotations: (variables, select) =>
    new Field(
      "annotations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CheckAnnotationConnection))
    ),

  /**
   * @description The check suite that this run is a part of.
   */

  checkSuite: (select) =>
    new Field(
      "checkSuite",
      undefined as never,
      new SelectionSet(select(CheckSuite))
    ),

  /**
   * @description Identifies the date and time when the check run was completed.
   */
  completedAt: () => new Field("completedAt"),

  /**
   * @description The conclusion of the check run.
   */
  conclusion: () => new Field("conclusion"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The URL from which to find full details of the check run on the integrator's site.
   */
  detailsUrl: () => new Field("detailsUrl"),

  /**
   * @description A reference for the check run on the integrator's system.
   */
  externalId: () => new Field("externalId"),
  id: () => new Field("id"),

  /**
   * @description The name of the check for this check run.
   */
  name: () => new Field("name"),

  /**
   * @description The permalink to the check run summary.
   */
  permalink: () => new Field("permalink"),

  /**
   * @description The repository associated with this check run.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this check run.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the check run was started.
   */
  startedAt: () => new Field("startedAt"),

  /**
   * @description The current status of the check run.
   */
  status: () => new Field("status"),

  /**
   * @description A string representing the check run's summary
   */
  summary: () => new Field("summary"),

  /**
   * @description A string representing the check run's text
   */
  text: () => new Field("text"),

  /**
   * @description A string representing the check run
   */
  title: () => new Field("title"),

  /**
   * @description The HTTP URL for this check run.
   */
  url: () => new Field("url"),
};

export interface ICheckRunConnection {
  edges: ICheckRunEdge[];
  nodes: ICheckRun[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CheckRunConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CheckRunEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CheckRunSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CheckRunConnection: CheckRunConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CheckRunEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(CheckRun))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICheckRunEdge {
  cursor: string;
  node: ICheckRun;
}

interface CheckRunEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CheckRunSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CheckRunEdge: CheckRunEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(CheckRun))),
};

export interface ICheckSuite extends INode {
  __typename: "CheckSuite";
  app: IApp;
  branch: IRef;
  checkRuns: ICheckRunConnection;
  commit: ICommit;
  conclusion: CheckConclusionState;
  createdAt: unknown;
  databaseId: number;
  matchingPullRequests: IPullRequestConnection;
  push: IPush;
  repository: IRepository;
  resourcePath: unknown;
  status: CheckStatusState;
  updatedAt: unknown;
  url: unknown;
}

interface CheckSuiteSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The GitHub App which created this check suite.
   */

  app: <T extends Array<Selection>>(
    select: (t: AppSelector) => T
  ) => Field<"app", never, SelectionSet<T>>;

  /**
   * @description The name of the branch for this check suite.
   */

  branch: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"branch", never, SelectionSet<T>>;

  /**
   * @description The check runs associated with a check suite.
   */

  checkRuns: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | CheckRunFilter;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CheckRunConnectionSelector) => T
  ) => Field<
    "checkRuns",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | CheckRunFilter>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The commit for this check suite
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description The conclusion of this check suite.
   */

  conclusion: () => Field<"conclusion">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description A list of open pull requests matching the check suite.
   */

  matchingPullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "matchingPullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The push that triggered this check suite.
   */

  push: <T extends Array<Selection>>(
    select: (t: PushSelector) => T
  ) => Field<"push", never, SelectionSet<T>>;

  /**
   * @description The repository associated with this check suite.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this check suite
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The status of this check suite.
   */

  status: () => Field<"status">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this check suite
   */

  url: () => Field<"url">;
}

export const isCheckSuite = (
  object: Record<string, any>
): object is Partial<ICheckSuite> => {
  return object.__typename === "CheckSuite";
};

export const CheckSuite: CheckSuiteSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The GitHub App which created this check suite.
   */

  app: (select) =>
    new Field("app", undefined as never, new SelectionSet(select(App))),

  /**
   * @description The name of the branch for this check suite.
   */

  branch: (select) =>
    new Field("branch", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description The check runs associated with a check suite.
   */

  checkRuns: (variables, select) =>
    new Field(
      "checkRuns",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CheckRunConnection))
    ),

  /**
   * @description The commit for this check suite
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description The conclusion of this check suite.
   */
  conclusion: () => new Field("conclusion"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description A list of open pull requests matching the check suite.
   */

  matchingPullRequests: (variables, select) =>
    new Field(
      "matchingPullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description The push that triggered this check suite.
   */

  push: (select) =>
    new Field("push", undefined as never, new SelectionSet(select(Push))),

  /**
   * @description The repository associated with this check suite.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this check suite
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The status of this check suite.
   */
  status: () => new Field("status"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this check suite
   */
  url: () => new Field("url"),
};

export interface ICheckSuiteConnection {
  edges: ICheckSuiteEdge[];
  nodes: ICheckSuite[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CheckSuiteConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CheckSuiteEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CheckSuiteConnection: CheckSuiteConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CheckSuiteEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CheckSuite))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICheckSuiteEdge {
  cursor: string;
  node: ICheckSuite;
}

interface CheckSuiteEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CheckSuiteEdge: CheckSuiteEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(CheckSuite))),
};

export interface IClearLabelsFromLabelablePayload {
  clientMutationId: string;
  labelable: ILabelable;
}

interface ClearLabelsFromLabelablePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The item that was unlabeled.
   */

  labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const ClearLabelsFromLabelablePayload: ClearLabelsFromLabelablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The item that was unlabeled.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface ICloneProjectPayload {
  clientMutationId: string;
  jobStatusId: string;
  project: IProject;
}

interface CloneProjectPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The id of the JobStatus for populating cloned fields.
   */

  jobStatusId: () => Field<"jobStatusId">;

  /**
   * @description The new cloned project.
   */

  project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const CloneProjectPayload: CloneProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The id of the JobStatus for populating cloned fields.
   */
  jobStatusId: () => new Field("jobStatusId"),

  /**
   * @description The new cloned project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface ICloneTemplateRepositoryPayload {
  clientMutationId: string;
  repository: IRepository;
}

interface CloneTemplateRepositoryPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new repository.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const CloneTemplateRepositoryPayload: CloneTemplateRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IClosable {
  __typename: string;
  closed: boolean;
  closedAt: unknown;
}

interface ClosableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */

  closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  closedAt: () => Field<"closedAt">;

  on: <
    T extends Array<Selection>,
    F extends "Issue" | "Milestone" | "Project" | "PullRequest"
  >(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "Milestone"
        ? MilestoneSelector
        : F extends "Project"
        ? ProjectSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Closable: ClosableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "Milestone": {
        return new InlineFragment(
          new NamedType("Milestone") as any,
          new SelectionSet(select(Milestone as any))
        );
      }

      case "Project": {
        return new InlineFragment(
          new NamedType("Project") as any,
          new SelectionSet(select(Project as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface ICloseIssuePayload {
  clientMutationId: string;
  issue: IIssue;
}

interface CloseIssuePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue that was closed.
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const CloseIssuePayload: CloseIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue that was closed.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IClosePullRequestPayload {
  clientMutationId: string;
  pullRequest: IPullRequest;
}

interface ClosePullRequestPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that was closed.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const ClosePullRequestPayload: ClosePullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that was closed.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IClosedEvent extends INode, IUniformResourceLocatable {
  __typename: "ClosedEvent";
  actor: IActor;
  closable: IClosable;
  closer: ICloser;
  createdAt: unknown;
}

interface ClosedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Object that was closed.
   */

  closable: <T extends Array<Selection>>(
    select: (t: ClosableSelector) => T
  ) => Field<"closable", never, SelectionSet<T>>;

  /**
   * @description Object which triggered the creation of this event.
   */

  closer: <T extends Array<Selection>>(
    select: (t: CloserSelector) => T
  ) => Field<"closer", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The HTTP path for this closed event.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this closed event.
   */

  url: () => Field<"url">;
}

export const isClosedEvent = (
  object: Record<string, any>
): object is Partial<IClosedEvent> => {
  return object.__typename === "ClosedEvent";
};

export const ClosedEvent: ClosedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Object that was closed.
   */

  closable: (select) =>
    new Field(
      "closable",
      undefined as never,
      new SelectionSet(select(Closable))
    ),

  /**
   * @description Object which triggered the creation of this event.
   */

  closer: (select) =>
    new Field("closer", undefined as never, new SelectionSet(select(Closer))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The HTTP path for this closed event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this closed event.
   */
  url: () => new Field("url"),
};

export interface ICodeOfConduct extends INode {
  __typename: "CodeOfConduct";
  body: string;
  key: string;
  name: string;
  resourcePath: unknown;
  url: unknown;
}

interface CodeOfConductSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The body of the Code of Conduct
   */

  body: () => Field<"body">;

  id: () => Field<"id">;

  /**
   * @description The key for the Code of Conduct
   */

  key: () => Field<"key">;

  /**
   * @description The formal name of the Code of Conduct
   */

  name: () => Field<"name">;

  /**
   * @description The HTTP path for this Code of Conduct
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this Code of Conduct
   */

  url: () => Field<"url">;
}

export const isCodeOfConduct = (
  object: Record<string, any>
): object is Partial<ICodeOfConduct> => {
  return object.__typename === "CodeOfConduct";
};

export const CodeOfConduct: CodeOfConductSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The body of the Code of Conduct
   */
  body: () => new Field("body"),
  id: () => new Field("id"),

  /**
   * @description The key for the Code of Conduct
   */
  key: () => new Field("key"),

  /**
   * @description The formal name of the Code of Conduct
   */
  name: () => new Field("name"),

  /**
   * @description The HTTP path for this Code of Conduct
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this Code of Conduct
   */
  url: () => new Field("url"),
};

export interface IComment {
  __typename: string;
  author: IActor;
  authorAssociation: CommentAuthorAssociation;
  body: string;
  bodyHTML: unknown;
  bodyText: string;
  createdAt: unknown;
  createdViaEmail: boolean;
  editor: IActor;
  id: string;
  includesCreatedEdit: boolean;
  lastEditedAt: unknown;
  publishedAt: unknown;
  updatedAt: unknown;
  userContentEdits: IUserContentEditConnection;
  viewerDidAuthor: boolean;
}

interface CommentSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The body as Markdown.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description The actor who edited the comment.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;

  on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "Issue"
      | "IssueComment"
      | "PullRequest"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Comment: CommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface ICommentDeletedEvent extends INode {
  __typename: "CommentDeletedEvent";
  actor: IActor;
  createdAt: unknown;
  databaseId: number;
  deletedCommentAuthor: IActor;
}

interface CommentDeletedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The user who authored the deleted comment.
   */

  deletedCommentAuthor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"deletedCommentAuthor", never, SelectionSet<T>>;

  id: () => Field<"id">;
}

export const isCommentDeletedEvent = (
  object: Record<string, any>
): object is Partial<ICommentDeletedEvent> => {
  return object.__typename === "CommentDeletedEvent";
};

export const CommentDeletedEvent: CommentDeletedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The user who authored the deleted comment.
   */

  deletedCommentAuthor: (select) =>
    new Field(
      "deletedCommentAuthor",
      undefined as never,
      new SelectionSet(select(Actor))
    ),

  id: () => new Field("id"),
};

export interface ICommit
  extends IGitObject,
    INode,
    ISubscribable,
    IUniformResourceLocatable {
  __typename: "Commit";
  additions: number;
  associatedPullRequests: IPullRequestConnection;
  author: IGitActor;
  authoredByCommitter: boolean;
  authoredDate: unknown;
  authors: IGitActorConnection;
  blame: IBlame;
  changedFiles: number;
  checkSuites: ICheckSuiteConnection;
  comments: ICommitCommentConnection;
  committedDate: unknown;
  committedViaWeb: boolean;
  committer: IGitActor;
  deletions: number;
  deployments: IDeploymentConnection;
  file: ITreeEntry;
  history: ICommitHistoryConnection;
  message: string;
  messageBody: string;
  messageBodyHTML: unknown;
  messageHeadline: string;
  messageHeadlineHTML: unknown;
  onBehalfOf: IOrganization;
  parents: ICommitConnection;
  pushedDate: unknown;
  signature: IGitSignature;
  status: IStatus;
  statusCheckRollup: IStatusCheckRollup;
  submodules: ISubmoduleConnection;
  tarballUrl: unknown;
  tree: ITree;
  treeResourcePath: unknown;
  treeUrl: unknown;
  zipballUrl: unknown;
}

interface CommitSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description The number of additions in this commit.
   */

  additions: () => Field<"additions">;

  /**
   * @description The pull requests associated with a commit
   */

  associatedPullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | PullRequestOrder;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "associatedPullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | PullRequestOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Authorship details of the commit.
   */

  author: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Check if the committer and the author match.
   */

  authoredByCommitter: () => Field<"authoredByCommitter">;

  /**
   * @description The datetime when this commit was authored.
   */

  authoredDate: () => Field<"authoredDate">;

  /**
     * @description The list of authors for this commit based on the git author and the Co-authored-by
message trailer. The git author will always be first.
     */

  authors: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: GitActorConnectionSelector) => T
  ) => Field<
    "authors",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Fetches `git blame` information.
   */

  blame: <T extends Array<Selection>>(
    variables: { path?: Variable<"path"> | string },
    select: (t: BlameSelector) => T
  ) => Field<
    "blame",
    [Argument<"path", Variable<"path"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The number of changed files in this commit.
   */

  changedFiles: () => Field<"changedFiles">;

  /**
   * @description The check suites associated with a commit.
   */

  checkSuites: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | CheckSuiteFilter;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CheckSuiteConnectionSelector) => T
  ) => Field<
    "checkSuites",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | CheckSuiteFilter>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Comments made on the commit.
   */

  comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this Git object
   */

  commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  commitUrl: () => Field<"commitUrl">;

  /**
   * @description The datetime when this commit was committed.
   */

  committedDate: () => Field<"committedDate">;

  /**
   * @description Check if commited via GitHub web UI.
   */

  committedViaWeb: () => Field<"committedViaWeb">;

  /**
   * @description Committership details of the commit.
   */

  committer: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"committer", never, SelectionSet<T>>;

  /**
   * @description The number of deletions in this commit.
   */

  deletions: () => Field<"deletions">;

  /**
   * @description The deployments associated with a commit.
   */

  deployments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      environments?: Variable<"environments"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | DeploymentOrder;
    },
    select: (t: DeploymentConnectionSelector) => T
  ) => Field<
    "deployments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"environments", Variable<"environments"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | DeploymentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The tree entry representing the file located at the given path.
   */

  file: <T extends Array<Selection>>(
    variables: { path?: Variable<"path"> | string },
    select: (t: TreeEntrySelector) => T
  ) => Field<
    "file",
    [Argument<"path", Variable<"path"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The linear commit history starting from (and including) this commit, in the same order as `git log`.
   */

  history: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      author?: Variable<"author"> | CommitAuthor;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      path?: Variable<"path"> | string;
      since?: Variable<"since"> | unknown;
      until?: Variable<"until"> | unknown;
    },
    select: (t: CommitHistoryConnectionSelector) => T
  ) => Field<
    "history",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"author", Variable<"author"> | CommitAuthor>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"path", Variable<"path"> | string>,
      Argument<"since", Variable<"since"> | unknown>,
      Argument<"until", Variable<"until"> | unknown>
    ],
    SelectionSet<T>
  >;

  id: () => Field<"id">;

  /**
   * @description The Git commit message
   */

  message: () => Field<"message">;

  /**
   * @description The Git commit message body
   */

  messageBody: () => Field<"messageBody">;

  /**
   * @description The commit message body rendered to HTML.
   */

  messageBodyHTML: () => Field<"messageBodyHTML">;

  /**
   * @description The Git commit message headline
   */

  messageHeadline: () => Field<"messageHeadline">;

  /**
   * @description The commit message headline rendered to HTML.
   */

  messageHeadlineHTML: () => Field<"messageHeadlineHTML">;

  /**
   * @description The Git object ID
   */

  oid: () => Field<"oid">;

  /**
   * @description The organization this commit was made on behalf of.
   */

  onBehalfOf: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"onBehalfOf", never, SelectionSet<T>>;

  /**
   * @description The parents of a commit.
   */

  parents: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitConnectionSelector) => T
  ) => Field<
    "parents",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The datetime when this commit was pushed.
   */

  pushedDate: () => Field<"pushedDate">;

  /**
   * @description The Repository this commit belongs to
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this commit
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Commit signing information, if present.
   */

  signature: <T extends Array<Selection>>(
    select: (t: GitSignatureSelector) => T
  ) => Field<"signature", never, SelectionSet<T>>;

  /**
   * @description Status information for this commit
   */

  status: <T extends Array<Selection>>(
    select: (t: StatusSelector) => T
  ) => Field<"status", never, SelectionSet<T>>;

  /**
   * @description Check and Status rollup information for this commit.
   */

  statusCheckRollup: <T extends Array<Selection>>(
    select: (t: StatusCheckRollupSelector) => T
  ) => Field<"statusCheckRollup", never, SelectionSet<T>>;

  /**
   * @description Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file.
   */

  submodules: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: SubmoduleConnectionSelector) => T
  ) => Field<
    "submodules",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
     * @description Returns a URL to download a tarball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes.
     */

  tarballUrl: () => Field<"tarballUrl">;

  /**
   * @description Commit's root Tree
   */

  tree: <T extends Array<Selection>>(
    select: (t: TreeSelector) => T
  ) => Field<"tree", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for the tree of this commit
   */

  treeResourcePath: () => Field<"treeResourcePath">;

  /**
   * @description The HTTP URL for the tree of this commit
   */

  treeUrl: () => Field<"treeUrl">;

  /**
   * @description The HTTP URL for this commit
   */

  url: () => Field<"url">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  viewerSubscription: () => Field<"viewerSubscription">;

  /**
     * @description Returns a URL to download a zipball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes.
     */

  zipballUrl: () => Field<"zipballUrl">;
}

export const isCommit = (
  object: Record<string, any>
): object is Partial<ICommit> => {
  return object.__typename === "Commit";
};

export const Commit: CommitSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description The number of additions in this commit.
   */
  additions: () => new Field("additions"),

  /**
   * @description The pull requests associated with a commit
   */

  associatedPullRequests: (variables, select) =>
    new Field(
      "associatedPullRequests",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description Authorship details of the commit.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(GitActor))),

  /**
   * @description Check if the committer and the author match.
   */
  authoredByCommitter: () => new Field("authoredByCommitter"),

  /**
   * @description The datetime when this commit was authored.
   */
  authoredDate: () => new Field("authoredDate"),

  /**
     * @description The list of authors for this commit based on the git author and the Co-authored-by
message trailer. The git author will always be first.
     */

  authors: (variables, select) =>
    new Field(
      "authors",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(GitActorConnection))
    ),

  /**
   * @description Fetches `git blame` information.
   */

  blame: (variables, select) =>
    new Field(
      "blame",
      [new Argument("path", variables.path)],
      new SelectionSet(select(Blame))
    ),

  /**
   * @description The number of changed files in this commit.
   */
  changedFiles: () => new Field("changedFiles"),

  /**
   * @description The check suites associated with a commit.
   */

  checkSuites: (variables, select) =>
    new Field(
      "checkSuites",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CheckSuiteConnection))
    ),

  /**
   * @description Comments made on the commit.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),

  /**
   * @description The datetime when this commit was committed.
   */
  committedDate: () => new Field("committedDate"),

  /**
   * @description Check if commited via GitHub web UI.
   */
  committedViaWeb: () => new Field("committedViaWeb"),

  /**
   * @description Committership details of the commit.
   */

  committer: (select) =>
    new Field(
      "committer",
      undefined as never,
      new SelectionSet(select(GitActor))
    ),

  /**
   * @description The number of deletions in this commit.
   */
  deletions: () => new Field("deletions"),

  /**
   * @description The deployments associated with a commit.
   */

  deployments: (variables, select) =>
    new Field(
      "deployments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("environments", variables.environments),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(DeploymentConnection))
    ),

  /**
   * @description The tree entry representing the file located at the given path.
   */

  file: (variables, select) =>
    new Field(
      "file",
      [new Argument("path", variables.path)],
      new SelectionSet(select(TreeEntry))
    ),

  /**
   * @description The linear commit history starting from (and including) this commit, in the same order as `git log`.
   */

  history: (variables, select) =>
    new Field(
      "history",
      [
        new Argument("after", variables.after),
        new Argument("author", variables.author),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("path", variables.path),
        new Argument("since", variables.since),
        new Argument("until", variables.until),
      ],
      new SelectionSet(select(CommitHistoryConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The Git commit message
   */
  message: () => new Field("message"),

  /**
   * @description The Git commit message body
   */
  messageBody: () => new Field("messageBody"),

  /**
   * @description The commit message body rendered to HTML.
   */
  messageBodyHTML: () => new Field("messageBodyHTML"),

  /**
   * @description The Git commit message headline
   */
  messageHeadline: () => new Field("messageHeadline"),

  /**
   * @description The commit message headline rendered to HTML.
   */
  messageHeadlineHTML: () => new Field("messageHeadlineHTML"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The organization this commit was made on behalf of.
   */

  onBehalfOf: (select) =>
    new Field(
      "onBehalfOf",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The parents of a commit.
   */

  parents: (variables, select) =>
    new Field(
      "parents",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitConnection))
    ),

  /**
   * @description The datetime when this commit was pushed.
   */
  pushedDate: () => new Field("pushedDate"),

  /**
   * @description The Repository this commit belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this commit
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Commit signing information, if present.
   */

  signature: (select) =>
    new Field(
      "signature",
      undefined as never,
      new SelectionSet(select(GitSignature))
    ),

  /**
   * @description Status information for this commit
   */

  status: (select) =>
    new Field("status", undefined as never, new SelectionSet(select(Status))),

  /**
   * @description Check and Status rollup information for this commit.
   */

  statusCheckRollup: (select) =>
    new Field(
      "statusCheckRollup",
      undefined as never,
      new SelectionSet(select(StatusCheckRollup))
    ),

  /**
   * @description Returns a list of all submodules in this repository as of this Commit parsed from the .gitmodules file.
   */

  submodules: (variables, select) =>
    new Field(
      "submodules",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(SubmoduleConnection))
    ),

  /**
     * @description Returns a URL to download a tarball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes.
     */
  tarballUrl: () => new Field("tarballUrl"),

  /**
   * @description Commit's root Tree
   */

  tree: (select) =>
    new Field("tree", undefined as never, new SelectionSet(select(Tree))),

  /**
   * @description The HTTP path for the tree of this commit
   */
  treeResourcePath: () => new Field("treeResourcePath"),

  /**
   * @description The HTTP URL for the tree of this commit
   */
  treeUrl: () => new Field("treeUrl"),

  /**
   * @description The HTTP URL for this commit
   */
  url: () => new Field("url"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),

  /**
     * @description Returns a URL to download a zipball archive for a repository.
Note: For private repositories, these links are temporary and expire after five minutes.
     */
  zipballUrl: () => new Field("zipballUrl"),
};

export interface ICommitComment
  extends IComment,
    IDeletable,
    IMinimizable,
    INode,
    IReactable,
    IRepositoryNode,
    IUpdatable,
    IUpdatableComment {
  __typename: "CommitComment";
  commit: ICommit;
  path: string;
  position: number;
  resourcePath: unknown;
  url: unknown;
}

interface CommitCommentSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Identifies the comment body.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the commit associated with the comment, if the commit exists.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  isMinimized: () => Field<"isMinimized">;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Returns why the comment was minimized.
   */

  minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Identifies the file path associated with the comment.
   */

  path: () => Field<"path">;

  /**
   * @description Identifies the line position associated with the comment.
   */

  position: () => Field<"position">;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path permalink for this commit comment.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL permalink for this commit comment.
   */

  url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  viewerCanMinimize: () => Field<"viewerCanMinimize">;

  /**
   * @description Can user react to this subject
   */

  viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isCommitComment = (
  object: Record<string, any>
): object is Partial<ICommitComment> => {
  return object.__typename === "CommitComment";
};

export const CommitComment: CommitCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Identifies the comment body.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the commit associated with the comment, if the commit exists.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Identifies the file path associated with the comment.
   */
  path: () => new Field("path"),

  /**
   * @description Identifies the line position associated with the comment.
   */
  position: () => new Field("position"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path permalink for this commit comment.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL permalink for this commit comment.
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface ICommitCommentConnection {
  edges: ICommitCommentEdge[];
  nodes: ICommitComment[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CommitCommentConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CommitCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CommitCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CommitCommentConnection: CommitCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CommitCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CommitComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICommitCommentEdge {
  cursor: string;
  node: ICommitComment;
}

interface CommitCommentEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CommitCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CommitCommentEdge: CommitCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CommitComment))
    ),
};

export interface ICommitCommentThread extends INode, IRepositoryNode {
  __typename: "CommitCommentThread";
  comments: ICommitCommentConnection;
  commit: ICommit;
  path: string;
  position: number;
}

interface CommitCommentThreadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The comments that exist in this thread.
   */

  comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The commit the comments were made on.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description The file the comments were made on.
   */

  path: () => Field<"path">;

  /**
   * @description The position in the diff for the commit that the comment was made on.
   */

  position: () => Field<"position">;

  /**
   * @description The repository associated with this node.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isCommitCommentThread = (
  object: Record<string, any>
): object is Partial<ICommitCommentThread> => {
  return object.__typename === "CommitCommentThread";
};

export const CommitCommentThread: CommitCommentThreadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The comments that exist in this thread.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description The commit the comments were made on.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  id: () => new Field("id"),

  /**
   * @description The file the comments were made on.
   */
  path: () => new Field("path"),

  /**
   * @description The position in the diff for the commit that the comment was made on.
   */
  position: () => new Field("position"),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ICommitConnection {
  edges: ICommitEdge[];
  nodes: ICommit[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CommitConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CommitEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CommitConnection: CommitConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CommitEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICommitContributionsByRepository {
  contributions: ICreatedCommitContributionConnection;
  repository: IRepository;
  resourcePath: unknown;
  url: unknown;
}

interface CommitContributionsByRepositorySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The commit contributions, each representing a day.
   */

  contributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | CommitContributionOrder;
    },
    select: (t: CreatedCommitContributionConnectionSelector) => T
  ) => Field<
    "contributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | CommitContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository in which the commits were made.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for the user's commits to the repository in this time range.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for the user's commits to the repository in this time range.
   */

  url: () => Field<"url">;
}

export const CommitContributionsByRepository: CommitContributionsByRepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The commit contributions, each representing a day.
   */

  contributions: (variables, select) =>
    new Field(
      "contributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedCommitContributionConnection))
    ),

  /**
   * @description The repository in which the commits were made.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for the user's commits to the repository in this time range.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for the user's commits to the repository in this time range.
   */
  url: () => new Field("url"),
};

export interface ICommitEdge {
  cursor: string;
  node: ICommit;
}

interface CommitEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CommitEdge: CommitEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Commit))),
};

export interface ICommitHistoryConnection {
  edges: ICommitEdge[];
  nodes: ICommit[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CommitHistoryConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CommitEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CommitHistoryConnection: CommitHistoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CommitEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IConnectedEvent extends INode {
  __typename: "ConnectedEvent";
  actor: IActor;
  createdAt: unknown;
  isCrossRepository: boolean;
  source: IReferencedSubject;
  subject: IReferencedSubject;
}

interface ConnectedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Reference originated in a different repository.
   */

  isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Issue or pull request that made the reference.
   */

  source: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"source", never, SelectionSet<T>>;

  /**
   * @description Issue or pull request which was connected.
   */

  subject: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isConnectedEvent = (
  object: Record<string, any>
): object is Partial<IConnectedEvent> => {
  return object.__typename === "ConnectedEvent";
};

export const ConnectedEvent: ConnectedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reference originated in a different repository.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Issue or pull request that made the reference.
   */

  source: (select) =>
    new Field(
      "source",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),

  /**
   * @description Issue or pull request which was connected.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),
};

export interface IContribution {
  __typename: string;
  isRestricted: boolean;
  occurredAt: unknown;
  resourcePath: unknown;
  url: unknown;
  user: IUser;
}

interface ContributionSelector {
  __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  occurredAt: () => Field<"occurredAt">;

  /**
   * @description The HTTP path for this contribution.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  on: <
    T extends Array<Selection>,
    F extends
      | "CreatedCommitContribution"
      | "CreatedIssueContribution"
      | "CreatedPullRequestContribution"
      | "CreatedPullRequestReviewContribution"
      | "CreatedRepositoryContribution"
      | "JoinedGitHubContribution"
      | "RestrictedContribution"
  >(
    type: F,
    select: (
      t: F extends "CreatedCommitContribution"
        ? CreatedCommitContributionSelector
        : F extends "CreatedIssueContribution"
        ? CreatedIssueContributionSelector
        : F extends "CreatedPullRequestContribution"
        ? CreatedPullRequestContributionSelector
        : F extends "CreatedPullRequestReviewContribution"
        ? CreatedPullRequestReviewContributionSelector
        : F extends "CreatedRepositoryContribution"
        ? CreatedRepositoryContributionSelector
        : F extends "JoinedGitHubContribution"
        ? JoinedGitHubContributionSelector
        : F extends "RestrictedContribution"
        ? RestrictedContributionSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Contribution: ContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  on: (type, select) => {
    switch (type) {
      case "CreatedCommitContribution": {
        return new InlineFragment(
          new NamedType("CreatedCommitContribution") as any,
          new SelectionSet(select(CreatedCommitContribution as any))
        );
      }

      case "CreatedIssueContribution": {
        return new InlineFragment(
          new NamedType("CreatedIssueContribution") as any,
          new SelectionSet(select(CreatedIssueContribution as any))
        );
      }

      case "CreatedPullRequestContribution": {
        return new InlineFragment(
          new NamedType("CreatedPullRequestContribution") as any,
          new SelectionSet(select(CreatedPullRequestContribution as any))
        );
      }

      case "CreatedPullRequestReviewContribution": {
        return new InlineFragment(
          new NamedType("CreatedPullRequestReviewContribution") as any,
          new SelectionSet(select(CreatedPullRequestReviewContribution as any))
        );
      }

      case "CreatedRepositoryContribution": {
        return new InlineFragment(
          new NamedType("CreatedRepositoryContribution") as any,
          new SelectionSet(select(CreatedRepositoryContribution as any))
        );
      }

      case "JoinedGitHubContribution": {
        return new InlineFragment(
          new NamedType("JoinedGitHubContribution") as any,
          new SelectionSet(select(JoinedGitHubContribution as any))
        );
      }

      case "RestrictedContribution": {
        return new InlineFragment(
          new NamedType("RestrictedContribution") as any,
          new SelectionSet(select(RestrictedContribution as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IContributionCalendar {
  colors: string[];
  isHalloween: boolean;
  months: IContributionCalendarMonth[];
  totalContributions: number;
  weeks: IContributionCalendarWeek[];
}

interface ContributionCalendarSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of hex color codes used in this calendar. The darker the color, the more contributions it represents.
   */

  colors: () => Field<"colors">;

  /**
   * @description Determine if the color set was chosen because it's currently Halloween.
   */

  isHalloween: () => Field<"isHalloween">;

  /**
   * @description A list of the months of contributions in this calendar.
   */

  months: <T extends Array<Selection>>(
    select: (t: ContributionCalendarMonthSelector) => T
  ) => Field<"months", never, SelectionSet<T>>;

  /**
   * @description The count of total contributions in the calendar.
   */

  totalContributions: () => Field<"totalContributions">;

  /**
   * @description A list of the weeks of contributions in this calendar.
   */

  weeks: <T extends Array<Selection>>(
    select: (t: ContributionCalendarWeekSelector) => T
  ) => Field<"weeks", never, SelectionSet<T>>;
}

export const ContributionCalendar: ContributionCalendarSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of hex color codes used in this calendar. The darker the color, the more contributions it represents.
   */
  colors: () => new Field("colors"),

  /**
   * @description Determine if the color set was chosen because it's currently Halloween.
   */
  isHalloween: () => new Field("isHalloween"),

  /**
   * @description A list of the months of contributions in this calendar.
   */

  months: (select) =>
    new Field(
      "months",
      undefined as never,
      new SelectionSet(select(ContributionCalendarMonth))
    ),

  /**
   * @description The count of total contributions in the calendar.
   */
  totalContributions: () => new Field("totalContributions"),

  /**
   * @description A list of the weeks of contributions in this calendar.
   */

  weeks: (select) =>
    new Field(
      "weeks",
      undefined as never,
      new SelectionSet(select(ContributionCalendarWeek))
    ),
};

export interface IContributionCalendarDay {
  color: string;
  contributionCount: number;
  date: unknown;
  weekday: number;
}

interface ContributionCalendarDaySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The hex color code that represents how many contributions were made on this day compared to others in the calendar.
   */

  color: () => Field<"color">;

  /**
   * @description How many contributions were made by the user on this day.
   */

  contributionCount: () => Field<"contributionCount">;

  /**
   * @description The day this square represents.
   */

  date: () => Field<"date">;

  /**
   * @description A number representing which day of the week this square represents, e.g., 1 is Monday.
   */

  weekday: () => Field<"weekday">;
}

export const ContributionCalendarDay: ContributionCalendarDaySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The hex color code that represents how many contributions were made on this day compared to others in the calendar.
   */
  color: () => new Field("color"),

  /**
   * @description How many contributions were made by the user on this day.
   */
  contributionCount: () => new Field("contributionCount"),

  /**
   * @description The day this square represents.
   */
  date: () => new Field("date"),

  /**
   * @description A number representing which day of the week this square represents, e.g., 1 is Monday.
   */
  weekday: () => new Field("weekday"),
};

export interface IContributionCalendarMonth {
  firstDay: unknown;
  name: string;
  totalWeeks: number;
  year: number;
}

interface ContributionCalendarMonthSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The date of the first day of this month.
   */

  firstDay: () => Field<"firstDay">;

  /**
   * @description The name of the month.
   */

  name: () => Field<"name">;

  /**
   * @description How many weeks started in this month.
   */

  totalWeeks: () => Field<"totalWeeks">;

  /**
   * @description The year the month occurred in.
   */

  year: () => Field<"year">;
}

export const ContributionCalendarMonth: ContributionCalendarMonthSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The date of the first day of this month.
   */
  firstDay: () => new Field("firstDay"),

  /**
   * @description The name of the month.
   */
  name: () => new Field("name"),

  /**
   * @description How many weeks started in this month.
   */
  totalWeeks: () => new Field("totalWeeks"),

  /**
   * @description The year the month occurred in.
   */
  year: () => new Field("year"),
};

export interface IContributionCalendarWeek {
  contributionDays: IContributionCalendarDay[];
  firstDay: unknown;
}

interface ContributionCalendarWeekSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The days of contributions in this week.
   */

  contributionDays: <T extends Array<Selection>>(
    select: (t: ContributionCalendarDaySelector) => T
  ) => Field<"contributionDays", never, SelectionSet<T>>;

  /**
   * @description The date of the earliest square in this week.
   */

  firstDay: () => Field<"firstDay">;
}

export const ContributionCalendarWeek: ContributionCalendarWeekSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The days of contributions in this week.
   */

  contributionDays: (select) =>
    new Field(
      "contributionDays",
      undefined as never,
      new SelectionSet(select(ContributionCalendarDay))
    ),

  /**
   * @description The date of the earliest square in this week.
   */
  firstDay: () => new Field("firstDay"),
};

export interface IContributionsCollection {
  commitContributionsByRepository: ICommitContributionsByRepository[];
  contributionCalendar: IContributionCalendar;
  contributionYears: number[];
  doesEndInCurrentMonth: boolean;
  earliestRestrictedContributionDate: unknown;
  endedAt: unknown;
  firstIssueContribution: ICreatedIssueOrRestrictedContribution;
  firstPullRequestContribution: ICreatedPullRequestOrRestrictedContribution;
  firstRepositoryContribution: ICreatedRepositoryOrRestrictedContribution;
  hasActivityInThePast: boolean;
  hasAnyContributions: boolean;
  hasAnyRestrictedContributions: boolean;
  isSingleDay: boolean;
  issueContributions: ICreatedIssueContributionConnection;
  issueContributionsByRepository: IIssueContributionsByRepository[];
  joinedGitHubContribution: IJoinedGitHubContribution;
  latestRestrictedContributionDate: unknown;
  mostRecentCollectionWithActivity: IContributionsCollection;
  mostRecentCollectionWithoutActivity: IContributionsCollection;
  popularIssueContribution: ICreatedIssueContribution;
  popularPullRequestContribution: ICreatedPullRequestContribution;
  pullRequestContributions: ICreatedPullRequestContributionConnection;
  pullRequestContributionsByRepository: IPullRequestContributionsByRepository[];
  pullRequestReviewContributions: ICreatedPullRequestReviewContributionConnection;
  pullRequestReviewContributionsByRepository: IPullRequestReviewContributionsByRepository[];
  repositoryContributions: ICreatedRepositoryContributionConnection;
  restrictedContributionsCount: number;
  startedAt: unknown;
  totalCommitContributions: number;
  totalIssueContributions: number;
  totalPullRequestContributions: number;
  totalPullRequestReviewContributions: number;
  totalRepositoriesWithContributedCommits: number;
  totalRepositoriesWithContributedIssues: number;
  totalRepositoriesWithContributedPullRequestReviews: number;
  totalRepositoriesWithContributedPullRequests: number;
  totalRepositoryContributions: number;
  user: IUser;
}

interface ContributionsCollectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Commit contributions made by the user, grouped by repository.
   */

  commitContributionsByRepository: <T extends Array<Selection>>(
    variables: { maxRepositories?: Variable<"maxRepositories"> | number },
    select: (t: CommitContributionsByRepositorySelector) => T
  ) => Field<
    "commitContributionsByRepository",
    [Argument<"maxRepositories", Variable<"maxRepositories"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A calendar of this user's contributions on GitHub.
   */

  contributionCalendar: <T extends Array<Selection>>(
    select: (t: ContributionCalendarSelector) => T
  ) => Field<"contributionCalendar", never, SelectionSet<T>>;

  /**
   * @description The years the user has been making contributions with the most recent year first.
   */

  contributionYears: () => Field<"contributionYears">;

  /**
   * @description Determine if this collection's time span ends in the current month.
   */

  doesEndInCurrentMonth: () => Field<"doesEndInCurrentMonth">;

  /**
     * @description The date of the first restricted contribution the user made in this time
period. Can only be non-null when the user has enabled private contribution counts.
     */

  earliestRestrictedContributionDate: () => Field<"earliestRestrictedContributionDate">;

  /**
   * @description The ending date and time of this collection.
   */

  endedAt: () => Field<"endedAt">;

  /**
     * @description The first issue the user opened on GitHub. This will be null if that issue was
opened outside the collection's time range and ignoreTimeRange is false. If
the issue is not visible but the user has opted to show private contributions,
a RestrictedContribution will be returned.
     */

  firstIssueContribution: <T extends Array<Selection>>(
    select: (t: CreatedIssueOrRestrictedContributionSelector) => T
  ) => Field<"firstIssueContribution", never, SelectionSet<T>>;

  /**
     * @description The first pull request the user opened on GitHub. This will be null if that
pull request was opened outside the collection's time range and
ignoreTimeRange is not true. If the pull request is not visible but the user
has opted to show private contributions, a RestrictedContribution will be returned.
     */

  firstPullRequestContribution: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestOrRestrictedContributionSelector) => T
  ) => Field<"firstPullRequestContribution", never, SelectionSet<T>>;

  /**
     * @description The first repository the user created on GitHub. This will be null if that
first repository was created outside the collection's time range and
ignoreTimeRange is false. If the repository is not visible, then a
RestrictedContribution is returned.
     */

  firstRepositoryContribution: <T extends Array<Selection>>(
    select: (t: CreatedRepositoryOrRestrictedContributionSelector) => T
  ) => Field<"firstRepositoryContribution", never, SelectionSet<T>>;

  /**
   * @description Does the user have any more activity in the timeline that occurred prior to the collection's time range?
   */

  hasActivityInThePast: () => Field<"hasActivityInThePast">;

  /**
   * @description Determine if there are any contributions in this collection.
   */

  hasAnyContributions: () => Field<"hasAnyContributions">;

  /**
     * @description Determine if the user made any contributions in this time frame whose details
are not visible because they were made in a private repository. Can only be
true if the user enabled private contribution counts.
     */

  hasAnyRestrictedContributions: () => Field<"hasAnyRestrictedContributions">;

  /**
   * @description Whether or not the collector's time span is all within the same day.
   */

  isSingleDay: () => Field<"isSingleDay">;

  /**
   * @description A list of issues the user opened.
   */

  issueContributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      excludePopular?: Variable<"excludePopular"> | boolean;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedIssueContributionConnectionSelector) => T
  ) => Field<
    "issueContributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Issue contributions made by the user, grouped by repository.
   */

  issueContributionsByRepository: <T extends Array<Selection>>(
    variables: {
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      excludePopular?: Variable<"excludePopular"> | boolean;
      maxRepositories?: Variable<"maxRepositories"> | number;
    },
    select: (t: IssueContributionsByRepositorySelector) => T
  ) => Field<
    "issueContributionsByRepository",
    [
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>,
      Argument<"maxRepositories", Variable<"maxRepositories"> | number>
    ],
    SelectionSet<T>
  >;

  /**
     * @description When the user signed up for GitHub. This will be null if that sign up date
falls outside the collection's time range and ignoreTimeRange is false.
     */

  joinedGitHubContribution: <T extends Array<Selection>>(
    select: (t: JoinedGitHubContributionSelector) => T
  ) => Field<"joinedGitHubContribution", never, SelectionSet<T>>;

  /**
     * @description The date of the most recent restricted contribution the user made in this time
period. Can only be non-null when the user has enabled private contribution counts.
     */

  latestRestrictedContributionDate: () => Field<"latestRestrictedContributionDate">;

  /**
     * @description When this collection's time range does not include any activity from the user, use this
to get a different collection from an earlier time range that does have activity.
     */

  mostRecentCollectionWithActivity: <T extends Array<Selection>>(
    select: (t: ContributionsCollectionSelector) => T
  ) => Field<"mostRecentCollectionWithActivity", never, SelectionSet<T>>;

  /**
     * @description Returns a different contributions collection from an earlier time range than this one
that does not have any contributions.
     */

  mostRecentCollectionWithoutActivity: <T extends Array<Selection>>(
    select: (t: ContributionsCollectionSelector) => T
  ) => Field<"mostRecentCollectionWithoutActivity", never, SelectionSet<T>>;

  /**
     * @description The issue the user opened on GitHub that received the most comments in the specified
time frame.
     */

  popularIssueContribution: <T extends Array<Selection>>(
    select: (t: CreatedIssueContributionSelector) => T
  ) => Field<"popularIssueContribution", never, SelectionSet<T>>;

  /**
     * @description The pull request the user opened on GitHub that received the most comments in the
specified time frame.
     */

  popularPullRequestContribution: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestContributionSelector) => T
  ) => Field<"popularPullRequestContribution", never, SelectionSet<T>>;

  /**
   * @description Pull request contributions made by the user.
   */

  pullRequestContributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      excludePopular?: Variable<"excludePopular"> | boolean;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedPullRequestContributionConnectionSelector) => T
  ) => Field<
    "pullRequestContributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Pull request contributions made by the user, grouped by repository.
   */

  pullRequestContributionsByRepository: <T extends Array<Selection>>(
    variables: {
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      excludePopular?: Variable<"excludePopular"> | boolean;
      maxRepositories?: Variable<"maxRepositories"> | number;
    },
    select: (t: PullRequestContributionsByRepositorySelector) => T
  ) => Field<
    "pullRequestContributionsByRepository",
    [
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"excludePopular", Variable<"excludePopular"> | boolean>,
      Argument<"maxRepositories", Variable<"maxRepositories"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Pull request review contributions made by the user.
   */

  pullRequestReviewContributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedPullRequestReviewContributionConnectionSelector) => T
  ) => Field<
    "pullRequestReviewContributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Pull request review contributions made by the user, grouped by repository.
   */

  pullRequestReviewContributionsByRepository: <T extends Array<Selection>>(
    variables: { maxRepositories?: Variable<"maxRepositories"> | number },
    select: (t: PullRequestReviewContributionsByRepositorySelector) => T
  ) => Field<
    "pullRequestReviewContributionsByRepository",
    [Argument<"maxRepositories", Variable<"maxRepositories"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories owned by the user that the user created in this time range.
   */

  repositoryContributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      excludeFirst?: Variable<"excludeFirst"> | boolean;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedRepositoryContributionConnectionSelector) => T
  ) => Field<
    "repositoryContributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"excludeFirst", Variable<"excludeFirst"> | boolean>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
     * @description A count of contributions made by the user that the viewer cannot access. Only
non-zero when the user has chosen to share their private contribution counts.
     */

  restrictedContributionsCount: () => Field<"restrictedContributionsCount">;

  /**
   * @description The beginning date and time of this collection.
   */

  startedAt: () => Field<"startedAt">;

  /**
   * @description How many commits were made by the user in this time span.
   */

  totalCommitContributions: () => Field<"totalCommitContributions">;

  /**
   * @description How many issues the user opened.
   */

  totalIssueContributions: (variables: {
    excludeFirst: unknown;
    excludePopular: unknown;
  }) => Field<"totalIssueContributions", [/* @todo */]>;

  /**
   * @description How many pull requests the user opened.
   */

  totalPullRequestContributions: (variables: {
    excludeFirst: unknown;
    excludePopular: unknown;
  }) => Field<"totalPullRequestContributions", [/* @todo */]>;

  /**
   * @description How many pull request reviews the user left.
   */

  totalPullRequestReviewContributions: () => Field<"totalPullRequestReviewContributions">;

  /**
   * @description How many different repositories the user committed to.
   */

  totalRepositoriesWithContributedCommits: () => Field<"totalRepositoriesWithContributedCommits">;

  /**
   * @description How many different repositories the user opened issues in.
   */

  totalRepositoriesWithContributedIssues: (variables: {
    excludeFirst: unknown;
    excludePopular: unknown;
  }) => Field<"totalRepositoriesWithContributedIssues", [/* @todo */]>;

  /**
   * @description How many different repositories the user left pull request reviews in.
   */

  totalRepositoriesWithContributedPullRequestReviews: () => Field<"totalRepositoriesWithContributedPullRequestReviews">;

  /**
   * @description How many different repositories the user opened pull requests in.
   */

  totalRepositoriesWithContributedPullRequests: (variables: {
    excludeFirst: unknown;
    excludePopular: unknown;
  }) => Field<"totalRepositoriesWithContributedPullRequests", [/* @todo */]>;

  /**
   * @description How many repositories the user created.
   */

  totalRepositoryContributions: (variables: {
    excludeFirst: unknown;
  }) => Field<"totalRepositoryContributions", [/* @todo */]>;

  /**
   * @description The user who made the contributions in this collection.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const ContributionsCollection: ContributionsCollectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Commit contributions made by the user, grouped by repository.
   */

  commitContributionsByRepository: (variables, select) =>
    new Field(
      "commitContributionsByRepository",
      [new Argument("maxRepositories", variables.maxRepositories)],
      new SelectionSet(select(CommitContributionsByRepository))
    ),

  /**
   * @description A calendar of this user's contributions on GitHub.
   */

  contributionCalendar: (select) =>
    new Field(
      "contributionCalendar",
      undefined as never,
      new SelectionSet(select(ContributionCalendar))
    ),

  /**
   * @description The years the user has been making contributions with the most recent year first.
   */
  contributionYears: () => new Field("contributionYears"),

  /**
   * @description Determine if this collection's time span ends in the current month.
   */
  doesEndInCurrentMonth: () => new Field("doesEndInCurrentMonth"),

  /**
     * @description The date of the first restricted contribution the user made in this time
period. Can only be non-null when the user has enabled private contribution counts.
     */
  earliestRestrictedContributionDate: () =>
    new Field("earliestRestrictedContributionDate"),

  /**
   * @description The ending date and time of this collection.
   */
  endedAt: () => new Field("endedAt"),

  /**
     * @description The first issue the user opened on GitHub. This will be null if that issue was
opened outside the collection's time range and ignoreTimeRange is false. If
the issue is not visible but the user has opted to show private contributions,
a RestrictedContribution will be returned.
     */

  firstIssueContribution: (select) =>
    new Field(
      "firstIssueContribution",
      undefined as never,
      new SelectionSet(select(CreatedIssueOrRestrictedContribution))
    ),

  /**
     * @description The first pull request the user opened on GitHub. This will be null if that
pull request was opened outside the collection's time range and
ignoreTimeRange is not true. If the pull request is not visible but the user
has opted to show private contributions, a RestrictedContribution will be returned.
     */

  firstPullRequestContribution: (select) =>
    new Field(
      "firstPullRequestContribution",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestOrRestrictedContribution))
    ),

  /**
     * @description The first repository the user created on GitHub. This will be null if that
first repository was created outside the collection's time range and
ignoreTimeRange is false. If the repository is not visible, then a
RestrictedContribution is returned.
     */

  firstRepositoryContribution: (select) =>
    new Field(
      "firstRepositoryContribution",
      undefined as never,
      new SelectionSet(select(CreatedRepositoryOrRestrictedContribution))
    ),

  /**
   * @description Does the user have any more activity in the timeline that occurred prior to the collection's time range?
   */
  hasActivityInThePast: () => new Field("hasActivityInThePast"),

  /**
   * @description Determine if there are any contributions in this collection.
   */
  hasAnyContributions: () => new Field("hasAnyContributions"),

  /**
     * @description Determine if the user made any contributions in this time frame whose details
are not visible because they were made in a private repository. Can only be
true if the user enabled private contribution counts.
     */
  hasAnyRestrictedContributions: () =>
    new Field("hasAnyRestrictedContributions"),

  /**
   * @description Whether or not the collector's time span is all within the same day.
   */
  isSingleDay: () => new Field("isSingleDay"),

  /**
   * @description A list of issues the user opened.
   */

  issueContributions: (variables, select) =>
    new Field(
      "issueContributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("excludePopular", variables.excludePopular),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedIssueContributionConnection))
    ),

  /**
   * @description Issue contributions made by the user, grouped by repository.
   */

  issueContributionsByRepository: (variables, select) =>
    new Field(
      "issueContributionsByRepository",
      [
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("excludePopular", variables.excludePopular),
        new Argument("maxRepositories", variables.maxRepositories),
      ],
      new SelectionSet(select(IssueContributionsByRepository))
    ),

  /**
     * @description When the user signed up for GitHub. This will be null if that sign up date
falls outside the collection's time range and ignoreTimeRange is false.
     */

  joinedGitHubContribution: (select) =>
    new Field(
      "joinedGitHubContribution",
      undefined as never,
      new SelectionSet(select(JoinedGitHubContribution))
    ),

  /**
     * @description The date of the most recent restricted contribution the user made in this time
period. Can only be non-null when the user has enabled private contribution counts.
     */
  latestRestrictedContributionDate: () =>
    new Field("latestRestrictedContributionDate"),

  /**
     * @description When this collection's time range does not include any activity from the user, use this
to get a different collection from an earlier time range that does have activity.
     */

  mostRecentCollectionWithActivity: (select) =>
    new Field(
      "mostRecentCollectionWithActivity",
      undefined as never,
      new SelectionSet(select(ContributionsCollection))
    ),

  /**
     * @description Returns a different contributions collection from an earlier time range than this one
that does not have any contributions.
     */

  mostRecentCollectionWithoutActivity: (select) =>
    new Field(
      "mostRecentCollectionWithoutActivity",
      undefined as never,
      new SelectionSet(select(ContributionsCollection))
    ),

  /**
     * @description The issue the user opened on GitHub that received the most comments in the specified
time frame.
     */

  popularIssueContribution: (select) =>
    new Field(
      "popularIssueContribution",
      undefined as never,
      new SelectionSet(select(CreatedIssueContribution))
    ),

  /**
     * @description The pull request the user opened on GitHub that received the most comments in the
specified time frame.
     */

  popularPullRequestContribution: (select) =>
    new Field(
      "popularPullRequestContribution",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestContribution))
    ),

  /**
   * @description Pull request contributions made by the user.
   */

  pullRequestContributions: (variables, select) =>
    new Field(
      "pullRequestContributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("excludePopular", variables.excludePopular),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedPullRequestContributionConnection))
    ),

  /**
   * @description Pull request contributions made by the user, grouped by repository.
   */

  pullRequestContributionsByRepository: (variables, select) =>
    new Field(
      "pullRequestContributionsByRepository",
      [
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("excludePopular", variables.excludePopular),
        new Argument("maxRepositories", variables.maxRepositories),
      ],
      new SelectionSet(select(PullRequestContributionsByRepository))
    ),

  /**
   * @description Pull request review contributions made by the user.
   */

  pullRequestReviewContributions: (variables, select) =>
    new Field(
      "pullRequestReviewContributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedPullRequestReviewContributionConnection))
    ),

  /**
   * @description Pull request review contributions made by the user, grouped by repository.
   */

  pullRequestReviewContributionsByRepository: (variables, select) =>
    new Field(
      "pullRequestReviewContributionsByRepository",
      [new Argument("maxRepositories", variables.maxRepositories)],
      new SelectionSet(select(PullRequestReviewContributionsByRepository))
    ),

  /**
   * @description A list of repositories owned by the user that the user created in this time range.
   */

  repositoryContributions: (variables, select) =>
    new Field(
      "repositoryContributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("excludeFirst", variables.excludeFirst),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedRepositoryContributionConnection))
    ),

  /**
     * @description A count of contributions made by the user that the viewer cannot access. Only
non-zero when the user has chosen to share their private contribution counts.
     */
  restrictedContributionsCount: () => new Field("restrictedContributionsCount"),

  /**
   * @description The beginning date and time of this collection.
   */
  startedAt: () => new Field("startedAt"),

  /**
   * @description How many commits were made by the user in this time span.
   */
  totalCommitContributions: () => new Field("totalCommitContributions"),

  /**
   * @description How many issues the user opened.
   */
  totalIssueContributions: (variables) => new Field("totalIssueContributions"),

  /**
   * @description How many pull requests the user opened.
   */
  totalPullRequestContributions: (variables) =>
    new Field("totalPullRequestContributions"),

  /**
   * @description How many pull request reviews the user left.
   */
  totalPullRequestReviewContributions: () =>
    new Field("totalPullRequestReviewContributions"),

  /**
   * @description How many different repositories the user committed to.
   */
  totalRepositoriesWithContributedCommits: () =>
    new Field("totalRepositoriesWithContributedCommits"),

  /**
   * @description How many different repositories the user opened issues in.
   */
  totalRepositoriesWithContributedIssues: (variables) =>
    new Field("totalRepositoriesWithContributedIssues"),

  /**
   * @description How many different repositories the user left pull request reviews in.
   */
  totalRepositoriesWithContributedPullRequestReviews: () =>
    new Field("totalRepositoriesWithContributedPullRequestReviews"),

  /**
   * @description How many different repositories the user opened pull requests in.
   */
  totalRepositoriesWithContributedPullRequests: (variables) =>
    new Field("totalRepositoriesWithContributedPullRequests"),

  /**
   * @description How many repositories the user created.
   */
  totalRepositoryContributions: (variables) =>
    new Field("totalRepositoryContributions"),

  /**
   * @description The user who made the contributions in this collection.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IConvertProjectCardNoteToIssuePayload {
  clientMutationId: string;
  projectCard: IProjectCard;
}

interface ConvertProjectCardNoteToIssuePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated ProjectCard.
   */

  projectCard: <T extends Array<Selection>>(
    select: (t: ProjectCardSelector) => T
  ) => Field<"projectCard", never, SelectionSet<T>>;
}

export const ConvertProjectCardNoteToIssuePayload: ConvertProjectCardNoteToIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated ProjectCard.
   */

  projectCard: (select) =>
    new Field(
      "projectCard",
      undefined as never,
      new SelectionSet(select(ProjectCard))
    ),
};

export interface IConvertToDraftEvent extends INode, IUniformResourceLocatable {
  __typename: "ConvertToDraftEvent";
  actor: IActor;
  createdAt: unknown;
  pullRequest: IPullRequest;
}

interface ConvertToDraftEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this convert to draft event.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this convert to draft event.
   */

  url: () => Field<"url">;
}

export const isConvertToDraftEvent = (
  object: Record<string, any>
): object is Partial<IConvertToDraftEvent> => {
  return object.__typename === "ConvertToDraftEvent";
};

export const ConvertToDraftEvent: ConvertToDraftEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this convert to draft event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this convert to draft event.
   */
  url: () => new Field("url"),
};

export interface IConvertedNoteToIssueEvent extends INode {
  __typename: "ConvertedNoteToIssueEvent";
  actor: IActor;
  createdAt: unknown;
  databaseId: number;
}

interface ConvertedNoteToIssueEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;
}

export const isConvertedNoteToIssueEvent = (
  object: Record<string, any>
): object is Partial<IConvertedNoteToIssueEvent> => {
  return object.__typename === "ConvertedNoteToIssueEvent";
};

export const ConvertedNoteToIssueEvent: ConvertedNoteToIssueEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface ICreateBranchProtectionRulePayload {
  branchProtectionRule: IBranchProtectionRule;
  clientMutationId: string;
}

interface CreateBranchProtectionRulePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The newly created BranchProtectionRule.
   */

  branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const CreateBranchProtectionRulePayload: CreateBranchProtectionRulePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The newly created BranchProtectionRule.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface ICreateCheckRunPayload {
  checkRun: ICheckRun;
  clientMutationId: string;
}

interface CreateCheckRunPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The newly created check run.
   */

  checkRun: <T extends Array<Selection>>(
    select: (t: CheckRunSelector) => T
  ) => Field<"checkRun", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const CreateCheckRunPayload: CreateCheckRunPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The newly created check run.
   */

  checkRun: (select) =>
    new Field(
      "checkRun",
      undefined as never,
      new SelectionSet(select(CheckRun))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface ICreateCheckSuitePayload {
  checkSuite: ICheckSuite;
  clientMutationId: string;
}

interface CreateCheckSuitePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The newly created check suite.
   */

  checkSuite: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"checkSuite", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const CreateCheckSuitePayload: CreateCheckSuitePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The newly created check suite.
   */

  checkSuite: (select) =>
    new Field(
      "checkSuite",
      undefined as never,
      new SelectionSet(select(CheckSuite))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface ICreateEnterpriseOrganizationPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  organization: IOrganization;
}

interface CreateEnterpriseOrganizationPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise that owns the created organization.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description The organization that was created.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;
}

export const CreateEnterpriseOrganizationPayload: CreateEnterpriseOrganizationPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise that owns the created organization.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description The organization that was created.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),
};

export interface ICreateIpAllowListEntryPayload {
  clientMutationId: string;
  ipAllowListEntry: IIpAllowListEntry;
}

interface CreateIpAllowListEntryPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The IP allow list entry that was created.
   */

  ipAllowListEntry: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"ipAllowListEntry", never, SelectionSet<T>>;
}

export const CreateIpAllowListEntryPayload: CreateIpAllowListEntryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The IP allow list entry that was created.
   */

  ipAllowListEntry: (select) =>
    new Field(
      "ipAllowListEntry",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),
};

export interface ICreateIssuePayload {
  clientMutationId: string;
  issue: IIssue;
}

interface CreateIssuePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new issue.
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const CreateIssuePayload: CreateIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new issue.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface ICreateProjectPayload {
  clientMutationId: string;
  project: IProject;
}

interface CreateProjectPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new project.
   */

  project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const CreateProjectPayload: CreateProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface ICreatePullRequestPayload {
  clientMutationId: string;
  pullRequest: IPullRequest;
}

interface CreatePullRequestPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new pull request.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const CreatePullRequestPayload: CreatePullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new pull request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface ICreateRefPayload {
  clientMutationId: string;
  ref: IRef;
}

interface CreateRefPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The newly created ref.
   */

  ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const CreateRefPayload: CreateRefPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The newly created ref.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface ICreateRepositoryPayload {
  clientMutationId: string;
  repository: IRepository;
}

interface CreateRepositoryPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new repository.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const CreateRepositoryPayload: CreateRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ICreateTeamDiscussionCommentPayload {
  clientMutationId: string;
  teamDiscussionComment: ITeamDiscussionComment;
}

interface CreateTeamDiscussionCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new comment.
   */

  teamDiscussionComment: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentSelector) => T
  ) => Field<"teamDiscussionComment", never, SelectionSet<T>>;
}

export const CreateTeamDiscussionCommentPayload: CreateTeamDiscussionCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new comment.
   */

  teamDiscussionComment: (select) =>
    new Field(
      "teamDiscussionComment",
      undefined as never,
      new SelectionSet(select(TeamDiscussionComment))
    ),
};

export interface ICreateTeamDiscussionPayload {
  clientMutationId: string;
  teamDiscussion: ITeamDiscussion;
}

interface CreateTeamDiscussionPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new discussion.
   */

  teamDiscussion: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"teamDiscussion", never, SelectionSet<T>>;
}

export const CreateTeamDiscussionPayload: CreateTeamDiscussionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new discussion.
   */

  teamDiscussion: (select) =>
    new Field(
      "teamDiscussion",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),
};

export interface ICreatedCommitContribution extends IContribution {
  __typename: "CreatedCommitContribution";
  commitCount: number;
  repository: IRepository;
}

interface CreatedCommitContributionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description How many commits were made on this day to this repository by the user.
   */

  commitCount: () => Field<"commitCount">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  occurredAt: () => Field<"occurredAt">;

  /**
   * @description The repository the user made a commit in.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this contribution.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedCommitContribution = (
  object: Record<string, any>
): object is Partial<ICreatedCommitContribution> => {
  return object.__typename === "CreatedCommitContribution";
};

export const CreatedCommitContribution: CreatedCommitContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description How many commits were made on this day to this repository by the user.
   */
  commitCount: () => new Field("commitCount"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The repository the user made a commit in.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedCommitContributionConnection {
  edges: ICreatedCommitContributionEdge[];
  nodes: ICreatedCommitContribution[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CreatedCommitContributionConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CreatedCommitContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CreatedCommitContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of commits across days and repositories in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CreatedCommitContributionConnection: CreatedCommitContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedCommitContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedCommitContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of commits across days and repositories in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedCommitContributionEdge {
  cursor: string;
  node: ICreatedCommitContribution;
}

interface CreatedCommitContributionEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CreatedCommitContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedCommitContributionEdge: CreatedCommitContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedCommitContribution))
    ),
};

export interface ICreatedIssueContribution extends IContribution {
  __typename: "CreatedIssueContribution";
  issue: IIssue;
}

interface CreatedIssueContributionSelector {
  __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  isRestricted: () => Field<"isRestricted">;

  /**
   * @description The issue that was opened.
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;

  /**
   * @description When this contribution was made.
   */

  occurredAt: () => Field<"occurredAt">;

  /**
   * @description The HTTP path for this contribution.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedIssueContribution = (
  object: Record<string, any>
): object is Partial<ICreatedIssueContribution> => {
  return object.__typename === "CreatedIssueContribution";
};

export const CreatedIssueContribution: CreatedIssueContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description The issue that was opened.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedIssueContributionConnection {
  edges: ICreatedIssueContributionEdge[];
  nodes: ICreatedIssueContribution[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CreatedIssueContributionConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CreatedIssueContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CreatedIssueContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CreatedIssueContributionConnection: CreatedIssueContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedIssueContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedIssueContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedIssueContributionEdge {
  cursor: string;
  node: ICreatedIssueContribution;
}

interface CreatedIssueContributionEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CreatedIssueContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedIssueContributionEdge: CreatedIssueContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedIssueContribution))
    ),
};

export interface ICreatedPullRequestContribution extends IContribution {
  __typename: "CreatedPullRequestContribution";
  pullRequest: IPullRequest;
}

interface CreatedPullRequestContributionSelector {
  __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  occurredAt: () => Field<"occurredAt">;

  /**
   * @description The pull request that was opened.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this contribution.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedPullRequestContribution = (
  object: Record<string, any>
): object is Partial<ICreatedPullRequestContribution> => {
  return object.__typename === "CreatedPullRequestContribution";
};

export const CreatedPullRequestContribution: CreatedPullRequestContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The pull request that was opened.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedPullRequestContributionConnection {
  edges: ICreatedPullRequestContributionEdge[];
  nodes: ICreatedPullRequestContribution[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CreatedPullRequestContributionConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CreatedPullRequestContributionConnection: CreatedPullRequestContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedPullRequestContributionEdge {
  cursor: string;
  node: ICreatedPullRequestContribution;
}

interface CreatedPullRequestContributionEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedPullRequestContributionEdge: CreatedPullRequestContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestContribution))
    ),
};

export interface ICreatedPullRequestReviewContribution extends IContribution {
  __typename: "CreatedPullRequestReviewContribution";
  pullRequest: IPullRequest;
  pullRequestReview: IPullRequestReview;
  repository: IRepository;
}

interface CreatedPullRequestReviewContributionSelector {
  __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  occurredAt: () => Field<"occurredAt">;

  /**
   * @description The pull request the user reviewed.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The review the user left on the pull request.
   */

  pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;

  /**
   * @description The repository containing the pull request that the user reviewed.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this contribution.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedPullRequestReviewContribution = (
  object: Record<string, any>
): object is Partial<ICreatedPullRequestReviewContribution> => {
  return object.__typename === "CreatedPullRequestReviewContribution";
};

export const CreatedPullRequestReviewContribution: CreatedPullRequestReviewContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The pull request the user reviewed.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The review the user left on the pull request.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description The repository containing the pull request that the user reviewed.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedPullRequestReviewContributionConnection {
  edges: ICreatedPullRequestReviewContributionEdge[];
  nodes: ICreatedPullRequestReviewContribution[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CreatedPullRequestReviewContributionConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestReviewContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestReviewContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CreatedPullRequestReviewContributionConnection: CreatedPullRequestReviewContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestReviewContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestReviewContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedPullRequestReviewContributionEdge {
  cursor: string;
  node: ICreatedPullRequestReviewContribution;
}

interface CreatedPullRequestReviewContributionEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CreatedPullRequestReviewContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedPullRequestReviewContributionEdge: CreatedPullRequestReviewContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedPullRequestReviewContribution))
    ),
};

export interface ICreatedRepositoryContribution extends IContribution {
  __typename: "CreatedRepositoryContribution";
  repository: IRepository;
}

interface CreatedRepositoryContributionSelector {
  __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  occurredAt: () => Field<"occurredAt">;

  /**
   * @description The repository that was created.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this contribution.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isCreatedRepositoryContribution = (
  object: Record<string, any>
): object is Partial<ICreatedRepositoryContribution> => {
  return object.__typename === "CreatedRepositoryContribution";
};

export const CreatedRepositoryContribution: CreatedRepositoryContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The repository that was created.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ICreatedRepositoryContributionConnection {
  edges: ICreatedRepositoryContributionEdge[];
  nodes: ICreatedRepositoryContribution[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface CreatedRepositoryContributionConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: CreatedRepositoryContributionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: CreatedRepositoryContributionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const CreatedRepositoryContributionConnection: CreatedRepositoryContributionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(CreatedRepositoryContributionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(CreatedRepositoryContribution))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ICreatedRepositoryContributionEdge {
  cursor: string;
  node: ICreatedRepositoryContribution;
}

interface CreatedRepositoryContributionEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: CreatedRepositoryContributionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const CreatedRepositoryContributionEdge: CreatedRepositoryContributionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(CreatedRepositoryContribution))
    ),
};

export interface ICrossReferencedEvent
  extends INode,
    IUniformResourceLocatable {
  __typename: "CrossReferencedEvent";
  actor: IActor;
  createdAt: unknown;
  isCrossRepository: boolean;
  referencedAt: unknown;
  source: IReferencedSubject;
  target: IReferencedSubject;
  willCloseTarget: boolean;
}

interface CrossReferencedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Reference originated in a different repository.
   */

  isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Identifies when the reference was made.
   */

  referencedAt: () => Field<"referencedAt">;

  /**
   * @description The HTTP path for this pull request.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Issue or pull request that made the reference.
   */

  source: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"source", never, SelectionSet<T>>;

  /**
   * @description Issue or pull request to which the reference was made.
   */

  target: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"target", never, SelectionSet<T>>;

  /**
   * @description The HTTP URL for this pull request.
   */

  url: () => Field<"url">;

  /**
   * @description Checks if the target will be closed when the source is merged.
   */

  willCloseTarget: () => Field<"willCloseTarget">;
}

export const isCrossReferencedEvent = (
  object: Record<string, any>
): object is Partial<ICrossReferencedEvent> => {
  return object.__typename === "CrossReferencedEvent";
};

export const CrossReferencedEvent: CrossReferencedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reference originated in a different repository.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Identifies when the reference was made.
   */
  referencedAt: () => new Field("referencedAt"),

  /**
   * @description The HTTP path for this pull request.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Issue or pull request that made the reference.
   */

  source: (select) =>
    new Field(
      "source",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),

  /**
   * @description Issue or pull request to which the reference was made.
   */

  target: (select) =>
    new Field(
      "target",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),

  /**
   * @description The HTTP URL for this pull request.
   */
  url: () => new Field("url"),

  /**
   * @description Checks if the target will be closed when the source is merged.
   */
  willCloseTarget: () => new Field("willCloseTarget"),
};

export interface IDeclineTopicSuggestionPayload {
  clientMutationId: string;
  topic: ITopic;
}

interface DeclineTopicSuggestionPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The declined topic.
   */

  topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;
}

export const DeclineTopicSuggestionPayload: DeclineTopicSuggestionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The declined topic.
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),
};

export interface IDeletable {
  __typename: string;
  viewerCanDelete: boolean;
}

interface DeletableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Check if the current viewer can delete this object.
   */

  viewerCanDelete: () => Field<"viewerCanDelete">;

  on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "IssueComment"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Deletable: DeletableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IDeleteBranchProtectionRulePayload {
  clientMutationId: string;
}

interface DeleteBranchProtectionRulePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteBranchProtectionRulePayload: DeleteBranchProtectionRulePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteDeploymentPayload {
  clientMutationId: string;
}

interface DeleteDeploymentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteDeploymentPayload: DeleteDeploymentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteIpAllowListEntryPayload {
  clientMutationId: string;
  ipAllowListEntry: IIpAllowListEntry;
}

interface DeleteIpAllowListEntryPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The IP allow list entry that was deleted.
   */

  ipAllowListEntry: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"ipAllowListEntry", never, SelectionSet<T>>;
}

export const DeleteIpAllowListEntryPayload: DeleteIpAllowListEntryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The IP allow list entry that was deleted.
   */

  ipAllowListEntry: (select) =>
    new Field(
      "ipAllowListEntry",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),
};

export interface IDeleteIssueCommentPayload {
  clientMutationId: string;
}

interface DeleteIssueCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteIssueCommentPayload: DeleteIssueCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteIssuePayload {
  clientMutationId: string;
  repository: IRepository;
}

interface DeleteIssuePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository the issue belonged to
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const DeleteIssuePayload: DeleteIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository the issue belonged to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IDeleteProjectCardPayload {
  clientMutationId: string;
  column: IProjectColumn;
  deletedCardId: string;
}

interface DeleteProjectCardPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The column the deleted card was in.
   */

  column: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"column", never, SelectionSet<T>>;

  /**
   * @description The deleted card ID.
   */

  deletedCardId: () => Field<"deletedCardId">;
}

export const DeleteProjectCardPayload: DeleteProjectCardPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The column the deleted card was in.
   */

  column: (select) =>
    new Field(
      "column",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),

  /**
   * @description The deleted card ID.
   */
  deletedCardId: () => new Field("deletedCardId"),
};

export interface IDeleteProjectColumnPayload {
  clientMutationId: string;
  deletedColumnId: string;
  project: IProject;
}

interface DeleteProjectColumnPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The deleted column ID.
   */

  deletedColumnId: () => Field<"deletedColumnId">;

  /**
   * @description The project the deleted column was in.
   */

  project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const DeleteProjectColumnPayload: DeleteProjectColumnPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The deleted column ID.
   */
  deletedColumnId: () => new Field("deletedColumnId"),

  /**
   * @description The project the deleted column was in.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface IDeleteProjectPayload {
  clientMutationId: string;
  owner: IProjectOwner;
}

interface DeleteProjectPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository or organization the project was removed from.
   */

  owner: <T extends Array<Selection>>(
    select: (t: ProjectOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;
}

export const DeleteProjectPayload: DeleteProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository or organization the project was removed from.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(ProjectOwner))
    ),
};

export interface IDeletePullRequestReviewCommentPayload {
  clientMutationId: string;
  pullRequestReview: IPullRequestReview;
}

interface DeletePullRequestReviewCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request review the deleted comment belonged to.
   */

  pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const DeletePullRequestReviewCommentPayload: DeletePullRequestReviewCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request review the deleted comment belonged to.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IDeletePullRequestReviewPayload {
  clientMutationId: string;
  pullRequestReview: IPullRequestReview;
}

interface DeletePullRequestReviewPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The deleted pull request review.
   */

  pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const DeletePullRequestReviewPayload: DeletePullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The deleted pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IDeleteRefPayload {
  clientMutationId: string;
}

interface DeleteRefPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteRefPayload: DeleteRefPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteTeamDiscussionCommentPayload {
  clientMutationId: string;
}

interface DeleteTeamDiscussionCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteTeamDiscussionCommentPayload: DeleteTeamDiscussionCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDeleteTeamDiscussionPayload {
  clientMutationId: string;
}

interface DeleteTeamDiscussionPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const DeleteTeamDiscussionPayload: DeleteTeamDiscussionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IDemilestonedEvent extends INode {
  __typename: "DemilestonedEvent";
  actor: IActor;
  createdAt: unknown;
  milestoneTitle: string;
  subject: IMilestoneItem;
}

interface DemilestonedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Identifies the milestone title associated with the 'demilestoned' event.
   */

  milestoneTitle: () => Field<"milestoneTitle">;

  /**
   * @description Object referenced by event.
   */

  subject: <T extends Array<Selection>>(
    select: (t: MilestoneItemSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isDemilestonedEvent = (
  object: Record<string, any>
): object is Partial<IDemilestonedEvent> => {
  return object.__typename === "DemilestonedEvent";
};

export const DemilestonedEvent: DemilestonedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the milestone title associated with the 'demilestoned' event.
   */
  milestoneTitle: () => new Field("milestoneTitle"),

  /**
   * @description Object referenced by event.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(MilestoneItem))
    ),
};

export interface IDeployKey extends INode {
  __typename: "DeployKey";
  createdAt: unknown;
  key: string;
  readOnly: boolean;
  title: string;
  verified: boolean;
}

interface DeployKeySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The deploy key.
   */

  key: () => Field<"key">;

  /**
   * @description Whether or not the deploy key is read only.
   */

  readOnly: () => Field<"readOnly">;

  /**
   * @description The deploy key title.
   */

  title: () => Field<"title">;

  /**
   * @description Whether or not the deploy key has been verified.
   */

  verified: () => Field<"verified">;
}

export const isDeployKey = (
  object: Record<string, any>
): object is Partial<IDeployKey> => {
  return object.__typename === "DeployKey";
};

export const DeployKey: DeployKeySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The deploy key.
   */
  key: () => new Field("key"),

  /**
   * @description Whether or not the deploy key is read only.
   */
  readOnly: () => new Field("readOnly"),

  /**
   * @description The deploy key title.
   */
  title: () => new Field("title"),

  /**
   * @description Whether or not the deploy key has been verified.
   */
  verified: () => new Field("verified"),
};

export interface IDeployKeyConnection {
  edges: IDeployKeyEdge[];
  nodes: IDeployKey[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface DeployKeyConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: DeployKeyEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: DeployKeySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const DeployKeyConnection: DeployKeyConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(DeployKeyEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(DeployKey))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IDeployKeyEdge {
  cursor: string;
  node: IDeployKey;
}

interface DeployKeyEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: DeployKeySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const DeployKeyEdge: DeployKeyEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(DeployKey))),
};

export interface IDeployedEvent extends INode {
  __typename: "DeployedEvent";
  actor: IActor;
  createdAt: unknown;
  databaseId: number;
  deployment: IDeployment;
  pullRequest: IPullRequest;
  ref: IRef;
}

interface DeployedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The deployment associated with the 'deployed' event.
   */

  deployment: <T extends Array<Selection>>(
    select: (t: DeploymentSelector) => T
  ) => Field<"deployment", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The ref associated with the 'deployed' event.
   */

  ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const isDeployedEvent = (
  object: Record<string, any>
): object is Partial<IDeployedEvent> => {
  return object.__typename === "DeployedEvent";
};

export const DeployedEvent: DeployedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The deployment associated with the 'deployed' event.
   */

  deployment: (select) =>
    new Field(
      "deployment",
      undefined as never,
      new SelectionSet(select(Deployment))
    ),

  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The ref associated with the 'deployed' event.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IDeployment extends INode {
  __typename: "Deployment";
  commit: ICommit;
  commitOid: string;
  createdAt: unknown;
  creator: IActor;
  databaseId: number;
  description: string;
  environment: string;
  latestEnvironment: string;
  latestStatus: IDeploymentStatus;
  originalEnvironment: string;
  payload: string;
  ref: IRef;
  repository: IRepository;
  state: DeploymentState;
  statuses: IDeploymentStatusConnection;
  task: string;
  updatedAt: unknown;
}

interface DeploymentSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the commit sha of the deployment.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the oid of the deployment commit, even if the commit has been deleted.
   */

  commitOid: () => Field<"commitOid">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the actor who triggered the deployment.
   */

  creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The deployment description.
   */

  description: () => Field<"description">;

  /**
   * @description The latest environment to which this deployment was made.
   */

  environment: () => Field<"environment">;

  id: () => Field<"id">;

  /**
   * @description The latest environment to which this deployment was made.
   */

  latestEnvironment: () => Field<"latestEnvironment">;

  /**
   * @description The latest status of this deployment.
   */

  latestStatus: <T extends Array<Selection>>(
    select: (t: DeploymentStatusSelector) => T
  ) => Field<"latestStatus", never, SelectionSet<T>>;

  /**
   * @description The original environment to which this deployment was made.
   */

  originalEnvironment: () => Field<"originalEnvironment">;

  /**
   * @description Extra information that a deployment system might need.
   */

  payload: () => Field<"payload">;

  /**
   * @description Identifies the Ref of the deployment, if the deployment was created by ref.
   */

  ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;

  /**
   * @description Identifies the repository associated with the deployment.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The current state of the deployment.
   */

  state: () => Field<"state">;

  /**
   * @description A list of statuses associated with the deployment.
   */

  statuses: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: DeploymentStatusConnectionSelector) => T
  ) => Field<
    "statuses",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The deployment task.
   */

  task: () => Field<"task">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;
}

export const isDeployment = (
  object: Record<string, any>
): object is Partial<IDeployment> => {
  return object.__typename === "Deployment";
};

export const Deployment: DeploymentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the commit sha of the deployment.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the oid of the deployment commit, even if the commit has been deleted.
   */
  commitOid: () => new Field("commitOid"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the actor who triggered the deployment.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The deployment description.
   */
  description: () => new Field("description"),

  /**
   * @description The latest environment to which this deployment was made.
   */
  environment: () => new Field("environment"),
  id: () => new Field("id"),

  /**
   * @description The latest environment to which this deployment was made.
   */
  latestEnvironment: () => new Field("latestEnvironment"),

  /**
   * @description The latest status of this deployment.
   */

  latestStatus: (select) =>
    new Field(
      "latestStatus",
      undefined as never,
      new SelectionSet(select(DeploymentStatus))
    ),

  /**
   * @description The original environment to which this deployment was made.
   */
  originalEnvironment: () => new Field("originalEnvironment"),

  /**
   * @description Extra information that a deployment system might need.
   */
  payload: () => new Field("payload"),

  /**
   * @description Identifies the Ref of the deployment, if the deployment was created by ref.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the repository associated with the deployment.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The current state of the deployment.
   */
  state: () => new Field("state"),

  /**
   * @description A list of statuses associated with the deployment.
   */

  statuses: (variables, select) =>
    new Field(
      "statuses",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(DeploymentStatusConnection))
    ),

  /**
   * @description The deployment task.
   */
  task: () => new Field("task"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IDeploymentConnection {
  edges: IDeploymentEdge[];
  nodes: IDeployment[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface DeploymentConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: DeploymentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: DeploymentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const DeploymentConnection: DeploymentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(DeploymentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Deployment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IDeploymentEdge {
  cursor: string;
  node: IDeployment;
}

interface DeploymentEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: DeploymentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const DeploymentEdge: DeploymentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Deployment))),
};

export interface IDeploymentEnvironmentChangedEvent extends INode {
  __typename: "DeploymentEnvironmentChangedEvent";
  actor: IActor;
  createdAt: unknown;
  deploymentStatus: IDeploymentStatus;
  pullRequest: IPullRequest;
}

interface DeploymentEnvironmentChangedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The deployment status that updated the deployment environment.
   */

  deploymentStatus: <T extends Array<Selection>>(
    select: (t: DeploymentStatusSelector) => T
  ) => Field<"deploymentStatus", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isDeploymentEnvironmentChangedEvent = (
  object: Record<string, any>
): object is Partial<IDeploymentEnvironmentChangedEvent> => {
  return object.__typename === "DeploymentEnvironmentChangedEvent";
};

export const DeploymentEnvironmentChangedEvent: DeploymentEnvironmentChangedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The deployment status that updated the deployment environment.
   */

  deploymentStatus: (select) =>
    new Field(
      "deploymentStatus",
      undefined as never,
      new SelectionSet(select(DeploymentStatus))
    ),

  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IDeploymentStatus extends INode {
  __typename: "DeploymentStatus";
  createdAt: unknown;
  creator: IActor;
  deployment: IDeployment;
  description: string;
  environmentUrl: unknown;
  logUrl: unknown;
  state: DeploymentStatusState;
  updatedAt: unknown;
}

interface DeploymentStatusSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the actor who triggered the deployment.
   */

  creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the deployment associated with status.
   */

  deployment: <T extends Array<Selection>>(
    select: (t: DeploymentSelector) => T
  ) => Field<"deployment", never, SelectionSet<T>>;

  /**
   * @description Identifies the description of the deployment.
   */

  description: () => Field<"description">;

  /**
   * @description Identifies the environment URL of the deployment.
   */

  environmentUrl: () => Field<"environmentUrl">;

  id: () => Field<"id">;

  /**
   * @description Identifies the log URL of the deployment.
   */

  logUrl: () => Field<"logUrl">;

  /**
   * @description Identifies the current state of the deployment.
   */

  state: () => Field<"state">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;
}

export const isDeploymentStatus = (
  object: Record<string, any>
): object is Partial<IDeploymentStatus> => {
  return object.__typename === "DeploymentStatus";
};

export const DeploymentStatus: DeploymentStatusSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the actor who triggered the deployment.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the deployment associated with status.
   */

  deployment: (select) =>
    new Field(
      "deployment",
      undefined as never,
      new SelectionSet(select(Deployment))
    ),

  /**
   * @description Identifies the description of the deployment.
   */
  description: () => new Field("description"),

  /**
   * @description Identifies the environment URL of the deployment.
   */
  environmentUrl: () => new Field("environmentUrl"),
  id: () => new Field("id"),

  /**
   * @description Identifies the log URL of the deployment.
   */
  logUrl: () => new Field("logUrl"),

  /**
   * @description Identifies the current state of the deployment.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IDeploymentStatusConnection {
  edges: IDeploymentStatusEdge[];
  nodes: IDeploymentStatus[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface DeploymentStatusConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: DeploymentStatusEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: DeploymentStatusSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const DeploymentStatusConnection: DeploymentStatusConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(DeploymentStatusEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(DeploymentStatus))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IDeploymentStatusEdge {
  cursor: string;
  node: IDeploymentStatus;
}

interface DeploymentStatusEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: DeploymentStatusSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const DeploymentStatusEdge: DeploymentStatusEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(DeploymentStatus))
    ),
};

export interface IDisconnectedEvent extends INode {
  __typename: "DisconnectedEvent";
  actor: IActor;
  createdAt: unknown;
  isCrossRepository: boolean;
  source: IReferencedSubject;
  subject: IReferencedSubject;
}

interface DisconnectedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Reference originated in a different repository.
   */

  isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Issue or pull request from which the issue was disconnected.
   */

  source: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"source", never, SelectionSet<T>>;

  /**
   * @description Issue or pull request which was disconnected.
   */

  subject: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isDisconnectedEvent = (
  object: Record<string, any>
): object is Partial<IDisconnectedEvent> => {
  return object.__typename === "DisconnectedEvent";
};

export const DisconnectedEvent: DisconnectedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reference originated in a different repository.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Issue or pull request from which the issue was disconnected.
   */

  source: (select) =>
    new Field(
      "source",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),

  /**
   * @description Issue or pull request which was disconnected.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),
};

export interface IDismissPullRequestReviewPayload {
  clientMutationId: string;
  pullRequestReview: IPullRequestReview;
}

interface DismissPullRequestReviewPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The dismissed pull request review.
   */

  pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const DismissPullRequestReviewPayload: DismissPullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The dismissed pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IEnterprise extends INode {
  __typename: "Enterprise";
  avatarUrl: unknown;
  billingInfo: IEnterpriseBillingInfo;
  createdAt: unknown;
  databaseId: number;
  description: string;
  descriptionHTML: unknown;
  location: string;
  members: IEnterpriseMemberConnection;
  name: string;
  organizations: IOrganizationConnection;
  ownerInfo: IEnterpriseOwnerInfo;
  resourcePath: unknown;
  slug: string;
  url: unknown;
  userAccounts: IEnterpriseUserAccountConnection;
  viewerIsAdmin: boolean;
  websiteUrl: unknown;
}

interface EnterpriseSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the enterprise's public avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description Enterprise billing information visible to enterprise billing managers.
   */

  billingInfo: <T extends Array<Selection>>(
    select: (t: EnterpriseBillingInfoSelector) => T
  ) => Field<"billingInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The description of the enterprise.
   */

  description: () => Field<"description">;

  /**
   * @description The description of the enterprise as HTML.
   */

  descriptionHTML: () => Field<"descriptionHTML">;

  id: () => Field<"id">;

  /**
   * @description The location of the enterprise.
   */

  location: () => Field<"location">;

  /**
   * @description A list of users who are members of this enterprise.
   */

  members: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      deployment?: Variable<"deployment"> | EnterpriseUserDeployment;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseMemberOrder;
      organizationLogins?: Variable<"organizationLogins"> | string;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | EnterpriseUserAccountMembershipRole;
    },
    select: (t: EnterpriseMemberConnectionSelector) => T
  ) => Field<
    "members",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"deployment", Variable<"deployment"> | EnterpriseUserDeployment>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | EnterpriseMemberOrder>,
      Argument<"organizationLogins", Variable<"organizationLogins"> | string>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseUserAccountMembershipRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The name of the enterprise.
   */

  name: () => Field<"name">;

  /**
   * @description A list of organizations that belong to this enterprise.
   */

  organizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "organizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Enterprise information only visible to enterprise owners.
   */

  ownerInfo: <T extends Array<Selection>>(
    select: (t: EnterpriseOwnerInfoSelector) => T
  ) => Field<"ownerInfo", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this enterprise.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The URL-friendly identifier for the enterprise.
   */

  slug: () => Field<"slug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  url: () => Field<"url">;

  /**
   * @description A list of user accounts on this enterprise.
   */

  userAccounts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: EnterpriseUserAccountConnectionSelector) => T
  ) => Field<
    "userAccounts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Is the current viewer an admin of this enterprise?
   */

  viewerIsAdmin: () => Field<"viewerIsAdmin">;

  /**
   * @description The URL of the enterprise website.
   */

  websiteUrl: () => Field<"websiteUrl">;
}

export const isEnterprise = (
  object: Record<string, any>
): object is Partial<IEnterprise> => {
  return object.__typename === "Enterprise";
};

export const Enterprise: EnterpriseSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the enterprise's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Enterprise billing information visible to enterprise billing managers.
   */

  billingInfo: (select) =>
    new Field(
      "billingInfo",
      undefined as never,
      new SelectionSet(select(EnterpriseBillingInfo))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The description of the enterprise.
   */
  description: () => new Field("description"),

  /**
   * @description The description of the enterprise as HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),
  id: () => new Field("id"),

  /**
   * @description The location of the enterprise.
   */
  location: () => new Field("location"),

  /**
   * @description A list of users who are members of this enterprise.
   */

  members: (variables, select) =>
    new Field(
      "members",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument(
          "deployment",
          variables.deployment,
          EnterpriseUserDeployment
        ),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("organizationLogins", variables.organizationLogins),
        new Argument("query", variables.query),
        new Argument(
          "role",
          variables.role,
          EnterpriseUserAccountMembershipRole
        ),
      ],
      new SelectionSet(select(EnterpriseMemberConnection))
    ),

  /**
   * @description The name of the enterprise.
   */
  name: () => new Field("name"),

  /**
   * @description A list of organizations that belong to this enterprise.
   */

  organizations: (variables, select) =>
    new Field(
      "organizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description Enterprise information only visible to enterprise owners.
   */

  ownerInfo: (select) =>
    new Field(
      "ownerInfo",
      undefined as never,
      new SelectionSet(select(EnterpriseOwnerInfo))
    ),

  /**
   * @description The HTTP path for this enterprise.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The URL-friendly identifier for the enterprise.
   */
  slug: () => new Field("slug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  url: () => new Field("url"),

  /**
   * @description A list of user accounts on this enterprise.
   */

  userAccounts: (variables, select) =>
    new Field(
      "userAccounts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(EnterpriseUserAccountConnection))
    ),

  /**
   * @description Is the current viewer an admin of this enterprise?
   */
  viewerIsAdmin: () => new Field("viewerIsAdmin"),

  /**
   * @description The URL of the enterprise website.
   */
  websiteUrl: () => new Field("websiteUrl"),
};

export interface IEnterpriseAdministratorConnection {
  edges: IEnterpriseAdministratorEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseAdministratorConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseAdministratorConnection: EnterpriseAdministratorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseAdministratorEdge {
  cursor: string;
  node: IUser;
  role: EnterpriseAdministratorRole;
}

interface EnterpriseAdministratorEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The role of the administrator.
   */

  role: () => Field<"role">;
}

export const EnterpriseAdministratorEdge: EnterpriseAdministratorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The role of the administrator.
   */
  role: () => new Field("role"),
};

export interface IEnterpriseAdministratorInvitation extends INode {
  __typename: "EnterpriseAdministratorInvitation";
  createdAt: unknown;
  email: string;
  enterprise: IEnterprise;
  invitee: IUser;
  inviter: IUser;
  role: EnterpriseAdministratorRole;
}

interface EnterpriseAdministratorInvitationSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The email of the person who was invited to the enterprise.
   */

  email: () => Field<"email">;

  /**
   * @description The enterprise the invitation is for.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description The user who was invited to the enterprise.
   */

  invitee: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"invitee", never, SelectionSet<T>>;

  /**
   * @description The user who created the invitation.
   */

  inviter: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"inviter", never, SelectionSet<T>>;

  /**
   * @description The invitee's pending role in the enterprise (owner or billing_manager).
   */

  role: () => Field<"role">;
}

export const isEnterpriseAdministratorInvitation = (
  object: Record<string, any>
): object is Partial<IEnterpriseAdministratorInvitation> => {
  return object.__typename === "EnterpriseAdministratorInvitation";
};

export const EnterpriseAdministratorInvitation: EnterpriseAdministratorInvitationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The email of the person who was invited to the enterprise.
   */
  email: () => new Field("email"),

  /**
   * @description The enterprise the invitation is for.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  id: () => new Field("id"),

  /**
   * @description The user who was invited to the enterprise.
   */

  invitee: (select) =>
    new Field("invitee", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The user who created the invitation.
   */

  inviter: (select) =>
    new Field("inviter", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The invitee's pending role in the enterprise (owner or billing_manager).
   */
  role: () => new Field("role"),
};

export interface IEnterpriseAdministratorInvitationConnection {
  edges: IEnterpriseAdministratorInvitationEdge[];
  nodes: IEnterpriseAdministratorInvitation[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseAdministratorInvitationConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseAdministratorInvitationConnection: EnterpriseAdministratorInvitationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseAdministratorInvitationEdge {
  cursor: string;
  node: IEnterpriseAdministratorInvitation;
}

interface EnterpriseAdministratorInvitationEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseAdministratorInvitationEdge: EnterpriseAdministratorInvitationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),
};

export interface IEnterpriseAuditEntryData {
  __typename: string;
  enterpriseResourcePath: unknown;
  enterpriseSlug: string;
  enterpriseUrl: unknown;
}

interface EnterpriseAuditEntryDataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The HTTP path for this enterprise.
   */

  enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  enterpriseUrl: () => Field<"enterpriseUrl">;

  on: <
    T extends Array<Selection>,
    F extends
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const EnterpriseAuditEntryData: EnterpriseAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),

  on: (type, select) => {
    switch (type) {
      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IEnterpriseBillingInfo {
  allLicensableUsersCount: number;
  assetPacks: number;
  availableSeats: number;
  bandwidthQuota: number;
  bandwidthUsage: number;
  bandwidthUsagePercentage: number;
  seats: number;
  storageQuota: number;
  storageUsage: number;
  storageUsagePercentage: number;
  totalAvailableLicenses: number;
  totalLicenses: number;
}

interface EnterpriseBillingInfoSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The number of licenseable users/emails across the enterprise.
   */

  allLicensableUsersCount: () => Field<"allLicensableUsersCount">;

  /**
   * @description The number of data packs used by all organizations owned by the enterprise.
   */

  assetPacks: () => Field<"assetPacks">;

  /**
   * @description The number of available seats across all owned organizations based on the unique number of billable users.
   * @deprecated `availableSeats` will be replaced with `totalAvailableLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalAvailableLicenses instead. Removal on 2020-01-01 UTC.
   */

  availableSeats: () => Field<"availableSeats">;

  /**
   * @description The bandwidth quota in GB for all organizations owned by the enterprise.
   */

  bandwidthQuota: () => Field<"bandwidthQuota">;

  /**
   * @description The bandwidth usage in GB for all organizations owned by the enterprise.
   */

  bandwidthUsage: () => Field<"bandwidthUsage">;

  /**
   * @description The bandwidth usage as a percentage of the bandwidth quota.
   */

  bandwidthUsagePercentage: () => Field<"bandwidthUsagePercentage">;

  /**
   * @description The total seats across all organizations owned by the enterprise.
   * @deprecated `seats` will be replaced with `totalLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalLicenses instead. Removal on 2020-01-01 UTC.
   */

  seats: () => Field<"seats">;

  /**
   * @description The storage quota in GB for all organizations owned by the enterprise.
   */

  storageQuota: () => Field<"storageQuota">;

  /**
   * @description The storage usage in GB for all organizations owned by the enterprise.
   */

  storageUsage: () => Field<"storageUsage">;

  /**
   * @description The storage usage as a percentage of the storage quota.
   */

  storageUsagePercentage: () => Field<"storageUsagePercentage">;

  /**
   * @description The number of available licenses across all owned organizations based on the unique number of billable users.
   */

  totalAvailableLicenses: () => Field<"totalAvailableLicenses">;

  /**
   * @description The total number of licenses allocated.
   */

  totalLicenses: () => Field<"totalLicenses">;
}

export const EnterpriseBillingInfo: EnterpriseBillingInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The number of licenseable users/emails across the enterprise.
   */
  allLicensableUsersCount: () => new Field("allLicensableUsersCount"),

  /**
   * @description The number of data packs used by all organizations owned by the enterprise.
   */
  assetPacks: () => new Field("assetPacks"),

  /**
   * @description The number of available seats across all owned organizations based on the unique number of billable users.
   * @deprecated `availableSeats` will be replaced with `totalAvailableLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalAvailableLicenses instead. Removal on 2020-01-01 UTC.
   */
  availableSeats: () => new Field("availableSeats"),

  /**
   * @description The bandwidth quota in GB for all organizations owned by the enterprise.
   */
  bandwidthQuota: () => new Field("bandwidthQuota"),

  /**
   * @description The bandwidth usage in GB for all organizations owned by the enterprise.
   */
  bandwidthUsage: () => new Field("bandwidthUsage"),

  /**
   * @description The bandwidth usage as a percentage of the bandwidth quota.
   */
  bandwidthUsagePercentage: () => new Field("bandwidthUsagePercentage"),

  /**
   * @description The total seats across all organizations owned by the enterprise.
   * @deprecated `seats` will be replaced with `totalLicenses` to provide more clarity on the value being returned Use EnterpriseBillingInfo.totalLicenses instead. Removal on 2020-01-01 UTC.
   */
  seats: () => new Field("seats"),

  /**
   * @description The storage quota in GB for all organizations owned by the enterprise.
   */
  storageQuota: () => new Field("storageQuota"),

  /**
   * @description The storage usage in GB for all organizations owned by the enterprise.
   */
  storageUsage: () => new Field("storageUsage"),

  /**
   * @description The storage usage as a percentage of the storage quota.
   */
  storageUsagePercentage: () => new Field("storageUsagePercentage"),

  /**
   * @description The number of available licenses across all owned organizations based on the unique number of billable users.
   */
  totalAvailableLicenses: () => new Field("totalAvailableLicenses"),

  /**
   * @description The total number of licenses allocated.
   */
  totalLicenses: () => new Field("totalLicenses"),
};

export interface IEnterpriseIdentityProvider extends INode {
  __typename: "EnterpriseIdentityProvider";
  digestMethod: SamlDigestAlgorithm;
  enterprise: IEnterprise;
  externalIdentities: IExternalIdentityConnection;
  idpCertificate: unknown;
  issuer: string;
  recoveryCodes: string[];
  signatureMethod: SamlSignatureAlgorithm;
  ssoUrl: unknown;
}

interface EnterpriseIdentityProviderSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The digest algorithm used to sign SAML requests for the identity provider.
   */

  digestMethod: () => Field<"digestMethod">;

  /**
   * @description The enterprise this identity provider belongs to.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description ExternalIdentities provisioned by this identity provider.
   */

  externalIdentities: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ExternalIdentityConnectionSelector) => T
  ) => Field<
    "externalIdentities",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  id: () => Field<"id">;

  /**
   * @description The x509 certificate used by the identity provider to sign assertions and responses.
   */

  idpCertificate: () => Field<"idpCertificate">;

  /**
   * @description The Issuer Entity ID for the SAML identity provider.
   */

  issuer: () => Field<"issuer">;

  /**
   * @description Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable.
   */

  recoveryCodes: () => Field<"recoveryCodes">;

  /**
   * @description The signature algorithm used to sign SAML requests for the identity provider.
   */

  signatureMethod: () => Field<"signatureMethod">;

  /**
   * @description The URL endpoint for the identity provider's SAML SSO.
   */

  ssoUrl: () => Field<"ssoUrl">;
}

export const isEnterpriseIdentityProvider = (
  object: Record<string, any>
): object is Partial<IEnterpriseIdentityProvider> => {
  return object.__typename === "EnterpriseIdentityProvider";
};

export const EnterpriseIdentityProvider: EnterpriseIdentityProviderSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The digest algorithm used to sign SAML requests for the identity provider.
   */
  digestMethod: () => new Field("digestMethod"),

  /**
   * @description The enterprise this identity provider belongs to.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description ExternalIdentities provisioned by this identity provider.
   */

  externalIdentities: (variables, select) =>
    new Field(
      "externalIdentities",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ExternalIdentityConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The x509 certificate used by the identity provider to sign assertions and responses.
   */
  idpCertificate: () => new Field("idpCertificate"),

  /**
   * @description The Issuer Entity ID for the SAML identity provider.
   */
  issuer: () => new Field("issuer"),

  /**
   * @description Recovery codes that can be used by admins to access the enterprise if the identity provider is unavailable.
   */
  recoveryCodes: () => new Field("recoveryCodes"),

  /**
   * @description The signature algorithm used to sign SAML requests for the identity provider.
   */
  signatureMethod: () => new Field("signatureMethod"),

  /**
   * @description The URL endpoint for the identity provider's SAML SSO.
   */
  ssoUrl: () => new Field("ssoUrl"),
};

export interface IEnterpriseMemberConnection {
  edges: IEnterpriseMemberEdge[];
  nodes: IEnterpriseMember[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseMemberConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseMemberEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseMemberSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseMemberConnection: EnterpriseMemberConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseMemberEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseMember))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseMemberEdge {
  cursor: string;
  isUnlicensed: boolean;
  node: IEnterpriseMember;
}

interface EnterpriseMemberEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description Whether the user does not have a license for the enterprise.
   * @deprecated All members consume a license Removal on 2021-01-01 UTC.
   */

  isUnlicensed: () => Field<"isUnlicensed">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: EnterpriseMemberSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseMemberEdge: EnterpriseMemberEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the user does not have a license for the enterprise.
   * @deprecated All members consume a license Removal on 2021-01-01 UTC.
   */
  isUnlicensed: () => new Field("isUnlicensed"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseMember))
    ),
};

export interface IEnterpriseOrganizationMembershipConnection {
  edges: IEnterpriseOrganizationMembershipEdge[];
  nodes: IOrganization[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseOrganizationMembershipConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseOrganizationMembershipEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseOrganizationMembershipConnection: EnterpriseOrganizationMembershipConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseOrganizationMembershipEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseOrganizationMembershipEdge {
  cursor: string;
  node: IOrganization;
  role: EnterpriseUserAccountMembershipRole;
}

interface EnterpriseOrganizationMembershipEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The role of the user in the enterprise membership.
   */

  role: () => Field<"role">;
}

export const EnterpriseOrganizationMembershipEdge: EnterpriseOrganizationMembershipEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The role of the user in the enterprise membership.
   */
  role: () => new Field("role"),
};

export interface IEnterpriseOutsideCollaboratorConnection {
  edges: IEnterpriseOutsideCollaboratorEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseOutsideCollaboratorConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseOutsideCollaboratorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseOutsideCollaboratorConnection: EnterpriseOutsideCollaboratorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseOutsideCollaboratorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseOutsideCollaboratorEdge {
  cursor: string;
  isUnlicensed: boolean;
  node: IUser;
  repositories: IEnterpriseRepositoryInfoConnection;
}

interface EnterpriseOutsideCollaboratorEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description Whether the outside collaborator does not have a license for the enterprise.
   * @deprecated All outside collaborators consume a license Removal on 2021-01-01 UTC.
   */

  isUnlicensed: () => Field<"isUnlicensed">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The enterprise organization repositories this user is a member of.
   */

  repositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
    },
    select: (t: EnterpriseRepositoryInfoConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>
    ],
    SelectionSet<T>
  >;
}

export const EnterpriseOutsideCollaboratorEdge: EnterpriseOutsideCollaboratorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the outside collaborator does not have a license for the enterprise.
   * @deprecated All outside collaborators consume a license Removal on 2021-01-01 UTC.
   */
  isUnlicensed: () => new Field("isUnlicensed"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The enterprise organization repositories this user is a member of.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseRepositoryInfoConnection))
    ),
};

export interface IEnterpriseOwnerInfo {
  admins: IEnterpriseAdministratorConnection;
  affiliatedUsersWithTwoFactorDisabled: IUserConnection;
  affiliatedUsersWithTwoFactorDisabledExist: boolean;
  allowPrivateRepositoryForkingSetting: EnterpriseEnabledDisabledSettingValue;
  allowPrivateRepositoryForkingSettingOrganizations: IOrganizationConnection;
  defaultRepositoryPermissionSetting: EnterpriseDefaultRepositoryPermissionSettingValue;
  defaultRepositoryPermissionSettingOrganizations: IOrganizationConnection;
  enterpriseServerInstallations: IEnterpriseServerInstallationConnection;
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
  ipAllowListEntries: IIpAllowListEntryConnection;
  isUpdatingDefaultRepositoryPermission: boolean;
  isUpdatingTwoFactorRequirement: boolean;
  membersCanChangeRepositoryVisibilitySetting: EnterpriseEnabledDisabledSettingValue;
  membersCanChangeRepositoryVisibilitySettingOrganizations: IOrganizationConnection;
  membersCanCreateInternalRepositoriesSetting: boolean;
  membersCanCreatePrivateRepositoriesSetting: boolean;
  membersCanCreatePublicRepositoriesSetting: boolean;
  membersCanCreateRepositoriesSetting: EnterpriseMembersCanCreateRepositoriesSettingValue;
  membersCanCreateRepositoriesSettingOrganizations: IOrganizationConnection;
  membersCanDeleteIssuesSetting: EnterpriseEnabledDisabledSettingValue;
  membersCanDeleteIssuesSettingOrganizations: IOrganizationConnection;
  membersCanDeleteRepositoriesSetting: EnterpriseEnabledDisabledSettingValue;
  membersCanDeleteRepositoriesSettingOrganizations: IOrganizationConnection;
  membersCanInviteCollaboratorsSetting: EnterpriseEnabledDisabledSettingValue;
  membersCanInviteCollaboratorsSettingOrganizations: IOrganizationConnection;
  membersCanMakePurchasesSetting: EnterpriseMembersCanMakePurchasesSettingValue;
  membersCanUpdateProtectedBranchesSetting: EnterpriseEnabledDisabledSettingValue;
  membersCanUpdateProtectedBranchesSettingOrganizations: IOrganizationConnection;
  membersCanViewDependencyInsightsSetting: EnterpriseEnabledDisabledSettingValue;
  membersCanViewDependencyInsightsSettingOrganizations: IOrganizationConnection;
  organizationProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  organizationProjectsSettingOrganizations: IOrganizationConnection;
  outsideCollaborators: IEnterpriseOutsideCollaboratorConnection;
  pendingAdminInvitations: IEnterpriseAdministratorInvitationConnection;
  pendingCollaboratorInvitations: IRepositoryInvitationConnection;
  pendingCollaborators: IEnterprisePendingCollaboratorConnection;
  pendingMemberInvitations: IEnterprisePendingMemberInvitationConnection;
  repositoryProjectsSetting: EnterpriseEnabledDisabledSettingValue;
  repositoryProjectsSettingOrganizations: IOrganizationConnection;
  samlIdentityProvider: IEnterpriseIdentityProvider;
  samlIdentityProviderSettingOrganizations: IOrganizationConnection;
  teamDiscussionsSetting: EnterpriseEnabledDisabledSettingValue;
  teamDiscussionsSettingOrganizations: IOrganizationConnection;
  twoFactorRequiredSetting: EnterpriseEnabledSettingValue;
  twoFactorRequiredSettingOrganizations: IOrganizationConnection;
}

interface EnterpriseOwnerInfoSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of all of the administrators for this enterprise.
   */

  admins: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseMemberOrder;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | EnterpriseAdministratorRole;
    },
    select: (t: EnterpriseAdministratorConnectionSelector) => T
  ) => Field<
    "admins",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | EnterpriseMemberOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseAdministratorRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users in the enterprise who currently have two-factor authentication disabled.
   */

  affiliatedUsersWithTwoFactorDisabled: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "affiliatedUsersWithTwoFactorDisabled",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not affiliated users with two-factor authentication disabled exist in the enterprise.
   */

  affiliatedUsersWithTwoFactorDisabledExist: () => Field<"affiliatedUsersWithTwoFactorDisabledExist">;

  /**
   * @description The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise.
   */

  allowPrivateRepositoryForkingSetting: () => Field<"allowPrivateRepositoryForkingSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided private repository forking setting value.
   */

  allowPrivateRepositoryForkingSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "allowPrivateRepositoryForkingSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for base repository permissions for organizations in this enterprise.
   */

  defaultRepositoryPermissionSetting: () => Field<"defaultRepositoryPermissionSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided default repository permission.
   */

  defaultRepositoryPermissionSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | DefaultRepositoryPermissionField;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "defaultRepositoryPermissionSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | DefaultRepositoryPermissionField>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Enterprise Server installations owned by the enterprise.
   */

  enterpriseServerInstallations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      connectedOnly?: Variable<"connectedOnly"> | boolean;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseServerInstallationOrder;
    },
    select: (t: EnterpriseServerInstallationConnectionSelector) => T
  ) => Field<
    "enterpriseServerInstallations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"connectedOnly", Variable<"connectedOnly"> | boolean>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseServerInstallationOrder
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether the enterprise has an IP allow list enabled.
   */

  ipAllowListEnabledSetting: () => Field<"ipAllowListEnabledSetting">;

  /**
   * @description The IP addresses that are allowed to access resources owned by the enterprise.
   */

  ipAllowListEntries: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IpAllowListEntryOrder;
    },
    select: (t: IpAllowListEntryConnectionSelector) => T
  ) => Field<
    "ipAllowListEntries",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IpAllowListEntryOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not the default repository permission is currently being updated.
   */

  isUpdatingDefaultRepositoryPermission: () => Field<"isUpdatingDefaultRepositoryPermission">;

  /**
   * @description Whether the two-factor authentication requirement is currently being enforced.
   */

  isUpdatingTwoFactorRequirement: () => Field<"isUpdatingTwoFactorRequirement">;

  /**
     * @description The setting value for whether organization members with admin permissions on a
repository can change repository visibility.
     */

  membersCanChangeRepositoryVisibilitySetting: () => Field<"membersCanChangeRepositoryVisibilitySetting">;

  /**
   * @description A list of enterprise organizations configured with the provided can change repository visibility setting value.
   */

  membersCanChangeRepositoryVisibilitySettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanChangeRepositoryVisibilitySettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members of organizations in the enterprise can create internal repositories.
   */

  membersCanCreateInternalRepositoriesSetting: () => Field<"membersCanCreateInternalRepositoriesSetting">;

  /**
   * @description The setting value for whether members of organizations in the enterprise can create private repositories.
   */

  membersCanCreatePrivateRepositoriesSetting: () => Field<"membersCanCreatePrivateRepositoriesSetting">;

  /**
   * @description The setting value for whether members of organizations in the enterprise can create public repositories.
   */

  membersCanCreatePublicRepositoriesSetting: () => Field<"membersCanCreatePublicRepositoriesSetting">;

  /**
   * @description The setting value for whether members of organizations in the enterprise can create repositories.
   */

  membersCanCreateRepositoriesSetting: () => Field<"membersCanCreateRepositoriesSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided repository creation setting value.
   */

  membersCanCreateRepositoriesSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?:
        | Variable<"value">
        | OrganizationMembersCanCreateRepositoriesSettingValue;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanCreateRepositoriesSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<
        "value",
        Variable<"value"> | OrganizationMembersCanCreateRepositoriesSettingValue
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members with admin permissions for repositories can delete issues.
   */

  membersCanDeleteIssuesSetting: () => Field<"membersCanDeleteIssuesSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can delete issues setting value.
   */

  membersCanDeleteIssuesSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanDeleteIssuesSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members with admin permissions for repositories can delete or transfer repositories.
   */

  membersCanDeleteRepositoriesSetting: () => Field<"membersCanDeleteRepositoriesSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can delete repositories setting value.
   */

  membersCanDeleteRepositoriesSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanDeleteRepositoriesSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members of organizations in the enterprise can invite outside collaborators.
   */

  membersCanInviteCollaboratorsSetting: () => Field<"membersCanInviteCollaboratorsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can invite collaborators setting value.
   */

  membersCanInviteCollaboratorsSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanInviteCollaboratorsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Indicates whether members of this enterprise's organizations can purchase additional services for those organizations.
   */

  membersCanMakePurchasesSetting: () => Field<"membersCanMakePurchasesSetting">;

  /**
   * @description The setting value for whether members with admin permissions for repositories can update protected branches.
   */

  membersCanUpdateProtectedBranchesSetting: () => Field<"membersCanUpdateProtectedBranchesSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can update protected branches setting value.
   */

  membersCanUpdateProtectedBranchesSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanUpdateProtectedBranchesSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether members can view dependency insights.
   */

  membersCanViewDependencyInsightsSetting: () => Field<"membersCanViewDependencyInsightsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided members can view dependency insights setting value.
   */

  membersCanViewDependencyInsightsSettingOrganizations: <
    T extends Array<Selection>
  >(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "membersCanViewDependencyInsightsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether organization projects are enabled for organizations in this enterprise.
   */

  organizationProjectsSetting: () => Field<"organizationProjectsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided organization projects setting value.
   */

  organizationProjectsSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "organizationProjectsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of outside collaborators across the repositories in the enterprise.
   */

  outsideCollaborators: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      login?: Variable<"login"> | string;
      orderBy?: Variable<"orderBy"> | EnterpriseMemberOrder;
      query?: Variable<"query"> | string;
      visibility?: Variable<"visibility"> | RepositoryVisibility;
    },
    select: (t: EnterpriseOutsideCollaboratorConnectionSelector) => T
  ) => Field<
    "outsideCollaborators",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"login", Variable<"login"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | EnterpriseMemberOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"visibility", Variable<"visibility"> | RepositoryVisibility>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pending administrator invitations for the enterprise.
   */

  pendingAdminInvitations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseAdministratorInvitationOrder;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | EnterpriseAdministratorRole;
    },
    select: (t: EnterpriseAdministratorInvitationConnectionSelector) => T
  ) => Field<
    "pendingAdminInvitations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseAdministratorInvitationOrder
      >,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseAdministratorRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pending collaborator invitations across the repositories in the enterprise.
   */

  pendingCollaboratorInvitations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryInvitationOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: RepositoryInvitationConnectionSelector) => T
  ) => Field<
    "pendingCollaboratorInvitations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryInvitationOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pending collaborators across the repositories in the enterprise.
   * @deprecated Repository invitations can now be associated with an email, not only an invitee. Use the `pendingCollaboratorInvitations` field instead. Removal on 2020-10-01 UTC.
   */

  pendingCollaborators: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryInvitationOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: EnterprisePendingCollaboratorConnectionSelector) => T
  ) => Field<
    "pendingCollaborators",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryInvitationOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pending member invitations for organizations in the enterprise.
   */

  pendingMemberInvitations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: EnterprisePendingMemberInvitationConnectionSelector) => T
  ) => Field<
    "pendingMemberInvitations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether repository projects are enabled in this enterprise.
   */

  repositoryProjectsSetting: () => Field<"repositoryProjectsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided repository projects setting value.
   */

  repositoryProjectsSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "repositoryProjectsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The SAML Identity Provider for the enterprise.
   */

  samlIdentityProvider: <T extends Array<Selection>>(
    select: (t: EnterpriseIdentityProviderSelector) => T
  ) => Field<"samlIdentityProvider", never, SelectionSet<T>>;

  /**
   * @description A list of enterprise organizations configured with the SAML single sign-on setting value.
   */

  samlIdentityProviderSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | IdentityProviderConfigurationState;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "samlIdentityProviderSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | IdentityProviderConfigurationState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether team discussions are enabled for organizations in this enterprise.
   */

  teamDiscussionsSetting: () => Field<"teamDiscussionsSetting">;

  /**
   * @description A list of enterprise organizations configured with the provided team discussions setting value.
   */

  teamDiscussionsSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "teamDiscussionsSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The setting value for whether the enterprise requires two-factor authentication for its organizations and users.
   */

  twoFactorRequiredSetting: () => Field<"twoFactorRequiredSetting">;

  /**
   * @description A list of enterprise organizations configured with the two-factor authentication setting value.
   */

  twoFactorRequiredSettingOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      value?: Variable<"value"> | boolean;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "twoFactorRequiredSettingOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"value", Variable<"value"> | boolean>
    ],
    SelectionSet<T>
  >;
}

export const EnterpriseOwnerInfo: EnterpriseOwnerInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of all of the administrators for this enterprise.
   */

  admins: (variables, select) =>
    new Field(
      "admins",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("role", variables.role, EnterpriseAdministratorRole),
      ],
      new SelectionSet(select(EnterpriseAdministratorConnection))
    ),

  /**
   * @description A list of users in the enterprise who currently have two-factor authentication disabled.
   */

  affiliatedUsersWithTwoFactorDisabled: (variables, select) =>
    new Field(
      "affiliatedUsersWithTwoFactorDisabled",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description Whether or not affiliated users with two-factor authentication disabled exist in the enterprise.
   */
  affiliatedUsersWithTwoFactorDisabledExist: () =>
    new Field("affiliatedUsersWithTwoFactorDisabledExist"),

  /**
   * @description The setting value for whether private repository forking is enabled for repositories in organizations in this enterprise.
   */
  allowPrivateRepositoryForkingSetting: () =>
    new Field("allowPrivateRepositoryForkingSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided private repository forking setting value.
   */

  allowPrivateRepositoryForkingSettingOrganizations: (variables, select) =>
    new Field(
      "allowPrivateRepositoryForkingSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for base repository permissions for organizations in this enterprise.
   */
  defaultRepositoryPermissionSetting: () =>
    new Field("defaultRepositoryPermissionSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided default repository permission.
   */

  defaultRepositoryPermissionSettingOrganizations: (variables, select) =>
    new Field(
      "defaultRepositoryPermissionSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "value",
          variables.value,
          DefaultRepositoryPermissionField
        ),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description Enterprise Server installations owned by the enterprise.
   */

  enterpriseServerInstallations: (variables, select) =>
    new Field(
      "enterpriseServerInstallations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("connectedOnly", variables.connectedOnly),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseServerInstallationConnection))
    ),

  /**
   * @description The setting value for whether the enterprise has an IP allow list enabled.
   */
  ipAllowListEnabledSetting: () => new Field("ipAllowListEnabledSetting"),

  /**
   * @description The IP addresses that are allowed to access resources owned by the enterprise.
   */

  ipAllowListEntries: (variables, select) =>
    new Field(
      "ipAllowListEntries",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IpAllowListEntryConnection))
    ),

  /**
   * @description Whether or not the default repository permission is currently being updated.
   */
  isUpdatingDefaultRepositoryPermission: () =>
    new Field("isUpdatingDefaultRepositoryPermission"),

  /**
   * @description Whether the two-factor authentication requirement is currently being enforced.
   */
  isUpdatingTwoFactorRequirement: () =>
    new Field("isUpdatingTwoFactorRequirement"),

  /**
     * @description The setting value for whether organization members with admin permissions on a
repository can change repository visibility.
     */
  membersCanChangeRepositoryVisibilitySetting: () =>
    new Field("membersCanChangeRepositoryVisibilitySetting"),

  /**
   * @description A list of enterprise organizations configured with the provided can change repository visibility setting value.
   */

  membersCanChangeRepositoryVisibilitySettingOrganizations: (
    variables,
    select
  ) =>
    new Field(
      "membersCanChangeRepositoryVisibilitySettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members of organizations in the enterprise can create internal repositories.
   */
  membersCanCreateInternalRepositoriesSetting: () =>
    new Field("membersCanCreateInternalRepositoriesSetting"),

  /**
   * @description The setting value for whether members of organizations in the enterprise can create private repositories.
   */
  membersCanCreatePrivateRepositoriesSetting: () =>
    new Field("membersCanCreatePrivateRepositoriesSetting"),

  /**
   * @description The setting value for whether members of organizations in the enterprise can create public repositories.
   */
  membersCanCreatePublicRepositoriesSetting: () =>
    new Field("membersCanCreatePublicRepositoriesSetting"),

  /**
   * @description The setting value for whether members of organizations in the enterprise can create repositories.
   */
  membersCanCreateRepositoriesSetting: () =>
    new Field("membersCanCreateRepositoriesSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided repository creation setting value.
   */

  membersCanCreateRepositoriesSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanCreateRepositoriesSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "value",
          variables.value,
          OrganizationMembersCanCreateRepositoriesSettingValue
        ),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members with admin permissions for repositories can delete issues.
   */
  membersCanDeleteIssuesSetting: () =>
    new Field("membersCanDeleteIssuesSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can delete issues setting value.
   */

  membersCanDeleteIssuesSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanDeleteIssuesSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members with admin permissions for repositories can delete or transfer repositories.
   */
  membersCanDeleteRepositoriesSetting: () =>
    new Field("membersCanDeleteRepositoriesSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can delete repositories setting value.
   */

  membersCanDeleteRepositoriesSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanDeleteRepositoriesSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members of organizations in the enterprise can invite outside collaborators.
   */
  membersCanInviteCollaboratorsSetting: () =>
    new Field("membersCanInviteCollaboratorsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can invite collaborators setting value.
   */

  membersCanInviteCollaboratorsSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanInviteCollaboratorsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description Indicates whether members of this enterprise's organizations can purchase additional services for those organizations.
   */
  membersCanMakePurchasesSetting: () =>
    new Field("membersCanMakePurchasesSetting"),

  /**
   * @description The setting value for whether members with admin permissions for repositories can update protected branches.
   */
  membersCanUpdateProtectedBranchesSetting: () =>
    new Field("membersCanUpdateProtectedBranchesSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can update protected branches setting value.
   */

  membersCanUpdateProtectedBranchesSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanUpdateProtectedBranchesSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether members can view dependency insights.
   */
  membersCanViewDependencyInsightsSetting: () =>
    new Field("membersCanViewDependencyInsightsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided members can view dependency insights setting value.
   */

  membersCanViewDependencyInsightsSettingOrganizations: (variables, select) =>
    new Field(
      "membersCanViewDependencyInsightsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether organization projects are enabled for organizations in this enterprise.
   */
  organizationProjectsSetting: () => new Field("organizationProjectsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided organization projects setting value.
   */

  organizationProjectsSettingOrganizations: (variables, select) =>
    new Field(
      "organizationProjectsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description A list of outside collaborators across the repositories in the enterprise.
   */

  outsideCollaborators: (variables, select) =>
    new Field(
      "outsideCollaborators",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("login", variables.login),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("visibility", variables.visibility, RepositoryVisibility),
      ],
      new SelectionSet(select(EnterpriseOutsideCollaboratorConnection))
    ),

  /**
   * @description A list of pending administrator invitations for the enterprise.
   */

  pendingAdminInvitations: (variables, select) =>
    new Field(
      "pendingAdminInvitations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("role", variables.role, EnterpriseAdministratorRole),
      ],
      new SelectionSet(select(EnterpriseAdministratorInvitationConnection))
    ),

  /**
   * @description A list of pending collaborator invitations across the repositories in the enterprise.
   */

  pendingCollaboratorInvitations: (variables, select) =>
    new Field(
      "pendingCollaboratorInvitations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(RepositoryInvitationConnection))
    ),

  /**
   * @description A list of pending collaborators across the repositories in the enterprise.
   * @deprecated Repository invitations can now be associated with an email, not only an invitee. Use the `pendingCollaboratorInvitations` field instead. Removal on 2020-10-01 UTC.
   */

  pendingCollaborators: (variables, select) =>
    new Field(
      "pendingCollaborators",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(EnterprisePendingCollaboratorConnection))
    ),

  /**
   * @description A list of pending member invitations for organizations in the enterprise.
   */

  pendingMemberInvitations: (variables, select) =>
    new Field(
      "pendingMemberInvitations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(EnterprisePendingMemberInvitationConnection))
    ),

  /**
   * @description The setting value for whether repository projects are enabled in this enterprise.
   */
  repositoryProjectsSetting: () => new Field("repositoryProjectsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided repository projects setting value.
   */

  repositoryProjectsSettingOrganizations: (variables, select) =>
    new Field(
      "repositoryProjectsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The SAML Identity Provider for the enterprise.
   */

  samlIdentityProvider: (select) =>
    new Field(
      "samlIdentityProvider",
      undefined as never,
      new SelectionSet(select(EnterpriseIdentityProvider))
    ),

  /**
   * @description A list of enterprise organizations configured with the SAML single sign-on setting value.
   */

  samlIdentityProviderSettingOrganizations: (variables, select) =>
    new Field(
      "samlIdentityProviderSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "value",
          variables.value,
          IdentityProviderConfigurationState
        ),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether team discussions are enabled for organizations in this enterprise.
   */
  teamDiscussionsSetting: () => new Field("teamDiscussionsSetting"),

  /**
   * @description A list of enterprise organizations configured with the provided team discussions setting value.
   */

  teamDiscussionsSettingOrganizations: (variables, select) =>
    new Field(
      "teamDiscussionsSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The setting value for whether the enterprise requires two-factor authentication for its organizations and users.
   */
  twoFactorRequiredSetting: () => new Field("twoFactorRequiredSetting"),

  /**
   * @description A list of enterprise organizations configured with the two-factor authentication setting value.
   */

  twoFactorRequiredSettingOrganizations: (variables, select) =>
    new Field(
      "twoFactorRequiredSettingOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("value", variables.value),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),
};

export interface IEnterprisePendingCollaboratorConnection {
  edges: IEnterprisePendingCollaboratorEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterprisePendingCollaboratorConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterprisePendingCollaboratorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterprisePendingCollaboratorConnection: EnterprisePendingCollaboratorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterprisePendingCollaboratorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterprisePendingCollaboratorEdge {
  cursor: string;
  isUnlicensed: boolean;
  node: IUser;
  repositories: IEnterpriseRepositoryInfoConnection;
}

interface EnterprisePendingCollaboratorEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description Whether the invited collaborator does not have a license for the enterprise.
   * @deprecated All pending collaborators consume a license Removal on 2021-01-01 UTC.
   */

  isUnlicensed: () => Field<"isUnlicensed">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The enterprise organization repositories this user is a member of.
   */

  repositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
    },
    select: (t: EnterpriseRepositoryInfoConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>
    ],
    SelectionSet<T>
  >;
}

export const EnterprisePendingCollaboratorEdge: EnterprisePendingCollaboratorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the invited collaborator does not have a license for the enterprise.
   * @deprecated All pending collaborators consume a license Removal on 2021-01-01 UTC.
   */
  isUnlicensed: () => new Field("isUnlicensed"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The enterprise organization repositories this user is a member of.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseRepositoryInfoConnection))
    ),
};

export interface IEnterprisePendingMemberInvitationConnection {
  edges: IEnterprisePendingMemberInvitationEdge[];
  nodes: IOrganizationInvitation[];
  pageInfo: IPageInfo;
  totalCount: number;
  totalUniqueUserCount: number;
}

interface EnterprisePendingMemberInvitationConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterprisePendingMemberInvitationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;

  /**
   * @description Identifies the total count of unique users in the connection.
   */

  totalUniqueUserCount: () => Field<"totalUniqueUserCount">;
}

export const EnterprisePendingMemberInvitationConnection: EnterprisePendingMemberInvitationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterprisePendingMemberInvitationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description Identifies the total count of unique users in the connection.
   */
  totalUniqueUserCount: () => new Field("totalUniqueUserCount"),
};

export interface IEnterprisePendingMemberInvitationEdge {
  cursor: string;
  isUnlicensed: boolean;
  node: IOrganizationInvitation;
}

interface EnterprisePendingMemberInvitationEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description Whether the invitation has a license for the enterprise.
   * @deprecated All pending members consume a license Removal on 2020-07-01 UTC.
   */

  isUnlicensed: () => Field<"isUnlicensed">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterprisePendingMemberInvitationEdge: EnterprisePendingMemberInvitationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the invitation has a license for the enterprise.
   * @deprecated All pending members consume a license Removal on 2020-07-01 UTC.
   */
  isUnlicensed: () => new Field("isUnlicensed"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),
};

export interface IEnterpriseRepositoryInfo extends INode {
  __typename: "EnterpriseRepositoryInfo";
  isPrivate: boolean;
  name: string;
  nameWithOwner: string;
}

interface EnterpriseRepositoryInfoSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description Identifies if the repository is private.
   */

  isPrivate: () => Field<"isPrivate">;

  /**
   * @description The repository's name.
   */

  name: () => Field<"name">;

  /**
   * @description The repository's name with owner.
   */

  nameWithOwner: () => Field<"nameWithOwner">;
}

export const isEnterpriseRepositoryInfo = (
  object: Record<string, any>
): object is Partial<IEnterpriseRepositoryInfo> => {
  return object.__typename === "EnterpriseRepositoryInfo";
};

export const EnterpriseRepositoryInfo: EnterpriseRepositoryInfoSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Identifies if the repository is private.
   */
  isPrivate: () => new Field("isPrivate"),

  /**
   * @description The repository's name.
   */
  name: () => new Field("name"),

  /**
   * @description The repository's name with owner.
   */
  nameWithOwner: () => new Field("nameWithOwner"),
};

export interface IEnterpriseRepositoryInfoConnection {
  edges: IEnterpriseRepositoryInfoEdge[];
  nodes: IEnterpriseRepositoryInfo[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseRepositoryInfoConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseRepositoryInfoEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseRepositoryInfoSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseRepositoryInfoConnection: EnterpriseRepositoryInfoConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseRepositoryInfoEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseRepositoryInfo))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseRepositoryInfoEdge {
  cursor: string;
  node: IEnterpriseRepositoryInfo;
}

interface EnterpriseRepositoryInfoEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: EnterpriseRepositoryInfoSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseRepositoryInfoEdge: EnterpriseRepositoryInfoEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseRepositoryInfo))
    ),
};

export interface IEnterpriseServerInstallation extends INode {
  __typename: "EnterpriseServerInstallation";
  createdAt: unknown;
  customerName: string;
  hostName: string;
  isConnected: boolean;
  updatedAt: unknown;
  userAccounts: IEnterpriseServerUserAccountConnection;
  userAccountsUploads: IEnterpriseServerUserAccountsUploadConnection;
}

interface EnterpriseServerInstallationSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The customer name to which the Enterprise Server installation belongs.
   */

  customerName: () => Field<"customerName">;

  /**
   * @description The host name of the Enterprise Server installation.
   */

  hostName: () => Field<"hostName">;

  id: () => Field<"id">;

  /**
   * @description Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect.
   */

  isConnected: () => Field<"isConnected">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description User accounts on this Enterprise Server installation.
   */

  userAccounts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseServerUserAccountOrder;
    },
    select: (t: EnterpriseServerUserAccountConnectionSelector) => T
  ) => Field<
    "userAccounts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseServerUserAccountOrder
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description User accounts uploads for the Enterprise Server installation.
   */

  userAccountsUploads: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseServerUserAccountsUploadOrder;
    },
    select: (t: EnterpriseServerUserAccountsUploadConnectionSelector) => T
  ) => Field<
    "userAccountsUploads",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseServerUserAccountsUploadOrder
      >
    ],
    SelectionSet<T>
  >;
}

export const isEnterpriseServerInstallation = (
  object: Record<string, any>
): object is Partial<IEnterpriseServerInstallation> => {
  return object.__typename === "EnterpriseServerInstallation";
};

export const EnterpriseServerInstallation: EnterpriseServerInstallationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The customer name to which the Enterprise Server installation belongs.
   */
  customerName: () => new Field("customerName"),

  /**
   * @description The host name of the Enterprise Server installation.
   */
  hostName: () => new Field("hostName"),
  id: () => new Field("id"),

  /**
   * @description Whether or not the installation is connected to an Enterprise Server installation via GitHub Connect.
   */
  isConnected: () => new Field("isConnected"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description User accounts on this Enterprise Server installation.
   */

  userAccounts: (variables, select) =>
    new Field(
      "userAccounts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseServerUserAccountConnection))
    ),

  /**
   * @description User accounts uploads for the Enterprise Server installation.
   */

  userAccountsUploads: (variables, select) =>
    new Field(
      "userAccountsUploads",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseServerUserAccountsUploadConnection))
    ),
};

export interface IEnterpriseServerInstallationConnection {
  edges: IEnterpriseServerInstallationEdge[];
  nodes: IEnterpriseServerInstallation[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseServerInstallationConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseServerInstallationConnection: EnterpriseServerInstallationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseServerInstallationEdge {
  cursor: string;
  node: IEnterpriseServerInstallation;
}

interface EnterpriseServerInstallationEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseServerInstallationEdge: EnterpriseServerInstallationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallation))
    ),
};

export interface IEnterpriseServerUserAccount extends INode {
  __typename: "EnterpriseServerUserAccount";
  createdAt: unknown;
  emails: IEnterpriseServerUserAccountEmailConnection;
  enterpriseServerInstallation: IEnterpriseServerInstallation;
  isSiteAdmin: boolean;
  login: string;
  profileName: string;
  remoteCreatedAt: unknown;
  remoteUserId: number;
  updatedAt: unknown;
}

interface EnterpriseServerUserAccountSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description User emails belonging to this user account.
   */

  emails: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | EnterpriseServerUserAccountEmailOrder;
    },
    select: (t: EnterpriseServerUserAccountEmailConnectionSelector) => T
  ) => Field<
    "emails",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<
        "orderBy",
        Variable<"orderBy"> | EnterpriseServerUserAccountEmailOrder
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description The Enterprise Server installation on which this user account exists.
   */

  enterpriseServerInstallation: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationSelector) => T
  ) => Field<"enterpriseServerInstallation", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Whether the user account is a site administrator on the Enterprise Server installation.
   */

  isSiteAdmin: () => Field<"isSiteAdmin">;

  /**
   * @description The login of the user account on the Enterprise Server installation.
   */

  login: () => Field<"login">;

  /**
   * @description The profile name of the user account on the Enterprise Server installation.
   */

  profileName: () => Field<"profileName">;

  /**
   * @description The date and time when the user account was created on the Enterprise Server installation.
   */

  remoteCreatedAt: () => Field<"remoteCreatedAt">;

  /**
   * @description The ID of the user account on the Enterprise Server installation.
   */

  remoteUserId: () => Field<"remoteUserId">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;
}

export const isEnterpriseServerUserAccount = (
  object: Record<string, any>
): object is Partial<IEnterpriseServerUserAccount> => {
  return object.__typename === "EnterpriseServerUserAccount";
};

export const EnterpriseServerUserAccount: EnterpriseServerUserAccountSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description User emails belonging to this user account.
   */

  emails: (variables, select) =>
    new Field(
      "emails",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(EnterpriseServerUserAccountEmailConnection))
    ),

  /**
   * @description The Enterprise Server installation on which this user account exists.
   */

  enterpriseServerInstallation: (select) =>
    new Field(
      "enterpriseServerInstallation",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallation))
    ),

  id: () => new Field("id"),

  /**
   * @description Whether the user account is a site administrator on the Enterprise Server installation.
   */
  isSiteAdmin: () => new Field("isSiteAdmin"),

  /**
   * @description The login of the user account on the Enterprise Server installation.
   */
  login: () => new Field("login"),

  /**
   * @description The profile name of the user account on the Enterprise Server installation.
   */
  profileName: () => new Field("profileName"),

  /**
   * @description The date and time when the user account was created on the Enterprise Server installation.
   */
  remoteCreatedAt: () => new Field("remoteCreatedAt"),

  /**
   * @description The ID of the user account on the Enterprise Server installation.
   */
  remoteUserId: () => new Field("remoteUserId"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IEnterpriseServerUserAccountConnection {
  edges: IEnterpriseServerUserAccountEdge[];
  nodes: IEnterpriseServerUserAccount[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseServerUserAccountConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseServerUserAccountConnection: EnterpriseServerUserAccountConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccount))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseServerUserAccountEdge {
  cursor: string;
  node: IEnterpriseServerUserAccount;
}

interface EnterpriseServerUserAccountEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseServerUserAccountEdge: EnterpriseServerUserAccountEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccount))
    ),
};

export interface IEnterpriseServerUserAccountEmail extends INode {
  __typename: "EnterpriseServerUserAccountEmail";
  createdAt: unknown;
  email: string;
  isPrimary: boolean;
  updatedAt: unknown;
  userAccount: IEnterpriseServerUserAccount;
}

interface EnterpriseServerUserAccountEmailSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The email address.
   */

  email: () => Field<"email">;

  id: () => Field<"id">;

  /**
   * @description Indicates whether this is the primary email of the associated user account.
   */

  isPrimary: () => Field<"isPrimary">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The user account to which the email belongs.
   */

  userAccount: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountSelector) => T
  ) => Field<"userAccount", never, SelectionSet<T>>;
}

export const isEnterpriseServerUserAccountEmail = (
  object: Record<string, any>
): object is Partial<IEnterpriseServerUserAccountEmail> => {
  return object.__typename === "EnterpriseServerUserAccountEmail";
};

export const EnterpriseServerUserAccountEmail: EnterpriseServerUserAccountEmailSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The email address.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description Indicates whether this is the primary email of the associated user account.
   */
  isPrimary: () => new Field("isPrimary"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The user account to which the email belongs.
   */

  userAccount: (select) =>
    new Field(
      "userAccount",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccount))
    ),
};

export interface IEnterpriseServerUserAccountEmailConnection {
  edges: IEnterpriseServerUserAccountEmailEdge[];
  nodes: IEnterpriseServerUserAccountEmail[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseServerUserAccountEmailConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountEmailEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountEmailSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseServerUserAccountEmailConnection: EnterpriseServerUserAccountEmailConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountEmailEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountEmail))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseServerUserAccountEmailEdge {
  cursor: string;
  node: IEnterpriseServerUserAccountEmail;
}

interface EnterpriseServerUserAccountEmailEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountEmailSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseServerUserAccountEmailEdge: EnterpriseServerUserAccountEmailEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountEmail))
    ),
};

export interface IEnterpriseServerUserAccountsUpload extends INode {
  __typename: "EnterpriseServerUserAccountsUpload";
  createdAt: unknown;
  enterprise: IEnterprise;
  enterpriseServerInstallation: IEnterpriseServerInstallation;
  name: string;
  syncState: EnterpriseServerUserAccountsUploadSyncState;
  updatedAt: unknown;
}

interface EnterpriseServerUserAccountsUploadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The enterprise to which this upload belongs.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description The Enterprise Server installation for which this upload was generated.
   */

  enterpriseServerInstallation: <T extends Array<Selection>>(
    select: (t: EnterpriseServerInstallationSelector) => T
  ) => Field<"enterpriseServerInstallation", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description The name of the file uploaded.
   */

  name: () => Field<"name">;

  /**
   * @description The synchronization state of the upload
   */

  syncState: () => Field<"syncState">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;
}

export const isEnterpriseServerUserAccountsUpload = (
  object: Record<string, any>
): object is Partial<IEnterpriseServerUserAccountsUpload> => {
  return object.__typename === "EnterpriseServerUserAccountsUpload";
};

export const EnterpriseServerUserAccountsUpload: EnterpriseServerUserAccountsUploadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The enterprise to which this upload belongs.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description The Enterprise Server installation for which this upload was generated.
   */

  enterpriseServerInstallation: (select) =>
    new Field(
      "enterpriseServerInstallation",
      undefined as never,
      new SelectionSet(select(EnterpriseServerInstallation))
    ),

  id: () => new Field("id"),

  /**
   * @description The name of the file uploaded.
   */
  name: () => new Field("name"),

  /**
   * @description The synchronization state of the upload
   */
  syncState: () => new Field("syncState"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IEnterpriseServerUserAccountsUploadConnection {
  edges: IEnterpriseServerUserAccountsUploadEdge[];
  nodes: IEnterpriseServerUserAccountsUpload[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseServerUserAccountsUploadConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountsUploadEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountsUploadSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseServerUserAccountsUploadConnection: EnterpriseServerUserAccountsUploadConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountsUploadEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountsUpload))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseServerUserAccountsUploadEdge {
  cursor: string;
  node: IEnterpriseServerUserAccountsUpload;
}

interface EnterpriseServerUserAccountsUploadEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: EnterpriseServerUserAccountsUploadSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseServerUserAccountsUploadEdge: EnterpriseServerUserAccountsUploadEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseServerUserAccountsUpload))
    ),
};

export interface IEnterpriseUserAccount extends IActor, INode {
  __typename: "EnterpriseUserAccount";
  createdAt: unknown;
  enterprise: IEnterprise;
  name: string;
  organizations: IEnterpriseOrganizationMembershipConnection;
  updatedAt: unknown;
  user: IUser;
}

interface EnterpriseUserAccountSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the enterprise user account's public avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The enterprise in which this user account exists.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description An identifier for the enterprise user account, a login or email address
   */

  login: () => Field<"login">;

  /**
   * @description The name of the enterprise user account
   */

  name: () => Field<"name">;

  /**
   * @description A list of enterprise organizations this user is a member of.
   */

  organizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | OrganizationOrder;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | EnterpriseUserAccountMembershipRole;
    },
    select: (t: EnterpriseOrganizationMembershipConnectionSelector) => T
  ) => Field<
    "organizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | OrganizationOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseUserAccountMembershipRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this user.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this user.
   */

  url: () => Field<"url">;

  /**
   * @description The user within the enterprise.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isEnterpriseUserAccount = (
  object: Record<string, any>
): object is Partial<IEnterpriseUserAccount> => {
  return object.__typename === "EnterpriseUserAccount";
};

export const EnterpriseUserAccount: EnterpriseUserAccountSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the enterprise user account's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The enterprise in which this user account exists.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  id: () => new Field("id"),

  /**
   * @description An identifier for the enterprise user account, a login or email address
   */
  login: () => new Field("login"),

  /**
   * @description The name of the enterprise user account
   */
  name: () => new Field("name"),

  /**
   * @description A list of enterprise organizations this user is a member of.
   */

  organizations: (variables, select) =>
    new Field(
      "organizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument(
          "role",
          variables.role,
          EnterpriseUserAccountMembershipRole
        ),
      ],
      new SelectionSet(select(EnterpriseOrganizationMembershipConnection))
    ),

  /**
   * @description The HTTP path for this user.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this user.
   */
  url: () => new Field("url"),

  /**
   * @description The user within the enterprise.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IEnterpriseUserAccountConnection {
  edges: IEnterpriseUserAccountEdge[];
  nodes: IEnterpriseUserAccount[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface EnterpriseUserAccountConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: EnterpriseUserAccountEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: EnterpriseUserAccountSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const EnterpriseUserAccountConnection: EnterpriseUserAccountConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(EnterpriseUserAccountEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(EnterpriseUserAccount))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IEnterpriseUserAccountEdge {
  cursor: string;
  node: IEnterpriseUserAccount;
}

interface EnterpriseUserAccountEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: EnterpriseUserAccountSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const EnterpriseUserAccountEdge: EnterpriseUserAccountEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(EnterpriseUserAccount))
    ),
};

export interface IExternalIdentity extends INode {
  __typename: "ExternalIdentity";
  guid: string;
  organizationInvitation: IOrganizationInvitation;
  samlIdentity: IExternalIdentitySamlAttributes;
  scimIdentity: IExternalIdentityScimAttributes;
  user: IUser;
}

interface ExternalIdentitySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The GUID for this identity
   */

  guid: () => Field<"guid">;

  id: () => Field<"id">;

  /**
   * @description Organization invitation for this SCIM-provisioned external identity
   */

  organizationInvitation: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"organizationInvitation", never, SelectionSet<T>>;

  /**
   * @description SAML Identity attributes
   */

  samlIdentity: <T extends Array<Selection>>(
    select: (t: ExternalIdentitySamlAttributesSelector) => T
  ) => Field<"samlIdentity", never, SelectionSet<T>>;

  /**
   * @description SCIM Identity attributes
   */

  scimIdentity: <T extends Array<Selection>>(
    select: (t: ExternalIdentityScimAttributesSelector) => T
  ) => Field<"scimIdentity", never, SelectionSet<T>>;

  /**
   * @description User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isExternalIdentity = (
  object: Record<string, any>
): object is Partial<IExternalIdentity> => {
  return object.__typename === "ExternalIdentity";
};

export const ExternalIdentity: ExternalIdentitySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The GUID for this identity
   */
  guid: () => new Field("guid"),
  id: () => new Field("id"),

  /**
   * @description Organization invitation for this SCIM-provisioned external identity
   */

  organizationInvitation: (select) =>
    new Field(
      "organizationInvitation",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),

  /**
   * @description SAML Identity attributes
   */

  samlIdentity: (select) =>
    new Field(
      "samlIdentity",
      undefined as never,
      new SelectionSet(select(ExternalIdentitySamlAttributes))
    ),

  /**
   * @description SCIM Identity attributes
   */

  scimIdentity: (select) =>
    new Field(
      "scimIdentity",
      undefined as never,
      new SelectionSet(select(ExternalIdentityScimAttributes))
    ),

  /**
   * @description User linked to this external identity. Will be NULL if this identity has not been claimed by an organization member.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IExternalIdentityConnection {
  edges: IExternalIdentityEdge[];
  nodes: IExternalIdentity[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface ExternalIdentityConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ExternalIdentityEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: ExternalIdentitySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const ExternalIdentityConnection: ExternalIdentityConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ExternalIdentityEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ExternalIdentity))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IExternalIdentityEdge {
  cursor: string;
  node: IExternalIdentity;
}

interface ExternalIdentityEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: ExternalIdentitySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ExternalIdentityEdge: ExternalIdentityEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ExternalIdentity))
    ),
};

export interface IExternalIdentitySamlAttributes {
  emails: IUserEmailMetadata[];
  familyName: string;
  givenName: string;
  groups: string[];
  nameId: string;
  username: string;
}

interface ExternalIdentitySamlAttributesSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The emails associated with the SAML identity
   */

  emails: <T extends Array<Selection>>(
    select: (t: UserEmailMetadataSelector) => T
  ) => Field<"emails", never, SelectionSet<T>>;

  /**
   * @description Family name of the SAML identity
   */

  familyName: () => Field<"familyName">;

  /**
   * @description Given name of the SAML identity
   */

  givenName: () => Field<"givenName">;

  /**
   * @description The groups linked to this identity in IDP
   */

  groups: () => Field<"groups">;

  /**
   * @description The NameID of the SAML identity
   */

  nameId: () => Field<"nameId">;

  /**
   * @description The userName of the SAML identity
   */

  username: () => Field<"username">;
}

export const ExternalIdentitySamlAttributes: ExternalIdentitySamlAttributesSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The emails associated with the SAML identity
   */

  emails: (select) =>
    new Field(
      "emails",
      undefined as never,
      new SelectionSet(select(UserEmailMetadata))
    ),

  /**
   * @description Family name of the SAML identity
   */
  familyName: () => new Field("familyName"),

  /**
   * @description Given name of the SAML identity
   */
  givenName: () => new Field("givenName"),

  /**
   * @description The groups linked to this identity in IDP
   */
  groups: () => new Field("groups"),

  /**
   * @description The NameID of the SAML identity
   */
  nameId: () => new Field("nameId"),

  /**
   * @description The userName of the SAML identity
   */
  username: () => new Field("username"),
};

export interface IExternalIdentityScimAttributes {
  emails: IUserEmailMetadata[];
  familyName: string;
  givenName: string;
  groups: string[];
  username: string;
}

interface ExternalIdentityScimAttributesSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The emails associated with the SCIM identity
   */

  emails: <T extends Array<Selection>>(
    select: (t: UserEmailMetadataSelector) => T
  ) => Field<"emails", never, SelectionSet<T>>;

  /**
   * @description Family name of the SCIM identity
   */

  familyName: () => Field<"familyName">;

  /**
   * @description Given name of the SCIM identity
   */

  givenName: () => Field<"givenName">;

  /**
   * @description The groups linked to this identity in IDP
   */

  groups: () => Field<"groups">;

  /**
   * @description The userName of the SCIM identity
   */

  username: () => Field<"username">;
}

export const ExternalIdentityScimAttributes: ExternalIdentityScimAttributesSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The emails associated with the SCIM identity
   */

  emails: (select) =>
    new Field(
      "emails",
      undefined as never,
      new SelectionSet(select(UserEmailMetadata))
    ),

  /**
   * @description Family name of the SCIM identity
   */
  familyName: () => new Field("familyName"),

  /**
   * @description Given name of the SCIM identity
   */
  givenName: () => new Field("givenName"),

  /**
   * @description The groups linked to this identity in IDP
   */
  groups: () => new Field("groups"),

  /**
   * @description The userName of the SCIM identity
   */
  username: () => new Field("username"),
};

export interface IFollowUserPayload {
  clientMutationId: string;
  user: IUser;
}

interface FollowUserPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The user that was followed.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const FollowUserPayload: FollowUserPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The user that was followed.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IFollowerConnection {
  edges: IUserEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface FollowerConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: UserEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const FollowerConnection: FollowerConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(UserEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IFollowingConnection {
  edges: IUserEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface FollowingConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: UserEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const FollowingConnection: FollowingConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(UserEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IFundingLink {
  platform: FundingPlatform;
  url: unknown;
}

interface FundingLinkSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The funding platform this link is for.
   */

  platform: () => Field<"platform">;

  /**
   * @description The configured URL for this funding link.
   */

  url: () => Field<"url">;
}

export const FundingLink: FundingLinkSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The funding platform this link is for.
   */
  platform: () => new Field("platform"),

  /**
   * @description The configured URL for this funding link.
   */
  url: () => new Field("url"),
};

export interface IGenericHovercardContext extends IHovercardContext {
  __typename: "GenericHovercardContext";
}

interface GenericHovercardContextSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  octicon: () => Field<"octicon">;
}

export const isGenericHovercardContext = (
  object: Record<string, any>
): object is Partial<IGenericHovercardContext> => {
  return object.__typename === "GenericHovercardContext";
};

export const GenericHovercardContext: GenericHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),
};

export interface IGist extends INode, IStarrable, IUniformResourceLocatable {
  __typename: "Gist";
  comments: IGistCommentConnection;
  createdAt: unknown;
  description: string;
  files: IGistFile[];
  forks: IGistConnection;
  isFork: boolean;
  isPublic: boolean;
  name: string;
  owner: IRepositoryOwner;
  pushedAt: unknown;
  updatedAt: unknown;
}

interface GistSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of comments associated with the gist
   */

  comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: GistCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The gist description.
   */

  description: () => Field<"description">;

  /**
   * @description The files in this gist.
   */

  files: <T extends Array<Selection>>(
    variables: {
      limit?: Variable<"limit"> | number;
      oid?: Variable<"oid"> | unknown;
    },
    select: (t: GistFileSelector) => T
  ) => Field<
    "files",
    [
      Argument<"limit", Variable<"limit"> | number>,
      Argument<"oid", Variable<"oid"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of forks associated with the gist
   */

  forks: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | GistOrder;
    },
    select: (t: GistConnectionSelector) => T
  ) => Field<
    "forks",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | GistOrder>
    ],
    SelectionSet<T>
  >;

  id: () => Field<"id">;

  /**
   * @description Identifies if the gist is a fork.
   */

  isFork: () => Field<"isFork">;

  /**
   * @description Whether the gist is public or not.
   */

  isPublic: () => Field<"isPublic">;

  /**
   * @description The gist name.
   */

  name: () => Field<"name">;

  /**
   * @description The gist owner.
   */

  owner: <T extends Array<Selection>>(
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description Identifies when the gist was last pushed to.
   */

  pushedAt: () => Field<"pushedAt">;

  /**
   * @description The HTML path to this resource.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Returns a count of how many stargazers there are on this object
   */

  stargazerCount: () => Field<"stargazerCount">;

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
    },
    select: (t: StargazerConnectionSelector) => T
  ) => Field<
    "stargazers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this Gist.
   */

  url: () => Field<"url">;

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */

  viewerHasStarred: () => Field<"viewerHasStarred">;
}

export const isGist = (
  object: Record<string, any>
): object is Partial<IGist> => {
  return object.__typename === "Gist";
};

export const Gist: GistSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of comments associated with the gist
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(GistCommentConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The gist description.
   */
  description: () => new Field("description"),

  /**
   * @description The files in this gist.
   */

  files: (variables, select) =>
    new Field(
      "files",
      [
        new Argument("limit", variables.limit),
        new Argument("oid", variables.oid),
      ],
      new SelectionSet(select(GistFile))
    ),

  /**
   * @description A list of forks associated with the gist
   */

  forks: (variables, select) =>
    new Field(
      "forks",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(GistConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description Identifies if the gist is a fork.
   */
  isFork: () => new Field("isFork"),

  /**
   * @description Whether the gist is public or not.
   */
  isPublic: () => new Field("isPublic"),

  /**
   * @description The gist name.
   */
  name: () => new Field("name"),

  /**
   * @description The gist owner.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description Identifies when the gist was last pushed to.
   */
  pushedAt: () => new Field("pushedAt"),

  /**
   * @description The HTML path to this resource.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Returns a count of how many stargazers there are on this object
   */
  stargazerCount: () => new Field("stargazerCount"),

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: (variables, select) =>
    new Field(
      "stargazers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(StargazerConnection))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this Gist.
   */
  url: () => new Field("url"),

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */
  viewerHasStarred: () => new Field("viewerHasStarred"),
};

export interface IGistComment
  extends IComment,
    IDeletable,
    IMinimizable,
    INode,
    IUpdatable,
    IUpdatableComment {
  __typename: "GistComment";
  databaseId: number;
  gist: IGist;
}

interface GistCommentSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the gist.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Identifies the comment body.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  /**
   * @description The associated gist.
   */

  gist: <T extends Array<Selection>>(
    select: (t: GistSelector) => T
  ) => Field<"gist", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  isMinimized: () => Field<"isMinimized">;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Returns why the comment was minimized.
   */

  minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  viewerCanMinimize: () => Field<"viewerCanMinimize">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isGistComment = (
  object: Record<string, any>
): object is Partial<IGistComment> => {
  return object.__typename === "GistComment";
};

export const GistComment: GistCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the gist.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Identifies the comment body.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The associated gist.
   */

  gist: (select) =>
    new Field("gist", undefined as never, new SelectionSet(select(Gist))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface IGistCommentConnection {
  edges: IGistCommentEdge[];
  nodes: IGistComment[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface GistCommentConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: GistCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: GistCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const GistCommentConnection: GistCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(GistCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(GistComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IGistCommentEdge {
  cursor: string;
  node: IGistComment;
}

interface GistCommentEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: GistCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const GistCommentEdge: GistCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(GistComment))
    ),
};

export interface IGistConnection {
  edges: IGistEdge[];
  nodes: IGist[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface GistConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: GistEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: GistSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const GistConnection: GistConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(GistEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Gist))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IGistEdge {
  cursor: string;
  node: IGist;
}

interface GistEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: GistSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const GistEdge: GistEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Gist))),
};

export interface IGistFile {
  encodedName: string;
  encoding: string;
  extension: string;
  isImage: boolean;
  isTruncated: boolean;
  language: ILanguage;
  name: string;
  size: number;
  text: string;
}

interface GistFileSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The file name encoded to remove characters that are invalid in URL paths.
   */

  encodedName: () => Field<"encodedName">;

  /**
   * @description The gist file encoding.
   */

  encoding: () => Field<"encoding">;

  /**
   * @description The file extension from the file name.
   */

  extension: () => Field<"extension">;

  /**
   * @description Indicates if this file is an image.
   */

  isImage: () => Field<"isImage">;

  /**
   * @description Whether the file's contents were truncated.
   */

  isTruncated: () => Field<"isTruncated">;

  /**
   * @description The programming language this file is written in.
   */

  language: <T extends Array<Selection>>(
    select: (t: LanguageSelector) => T
  ) => Field<"language", never, SelectionSet<T>>;

  /**
   * @description The gist file name.
   */

  name: () => Field<"name">;

  /**
   * @description The gist file size in bytes.
   */

  size: () => Field<"size">;

  /**
   * @description UTF8 text data or null if the file is binary
   */

  text: (variables: { truncate: unknown }) => Field<"text", [/* @todo */]>;
}

export const GistFile: GistFileSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The file name encoded to remove characters that are invalid in URL paths.
   */
  encodedName: () => new Field("encodedName"),

  /**
   * @description The gist file encoding.
   */
  encoding: () => new Field("encoding"),

  /**
   * @description The file extension from the file name.
   */
  extension: () => new Field("extension"),

  /**
   * @description Indicates if this file is an image.
   */
  isImage: () => new Field("isImage"),

  /**
   * @description Whether the file's contents were truncated.
   */
  isTruncated: () => new Field("isTruncated"),

  /**
   * @description The programming language this file is written in.
   */

  language: (select) =>
    new Field(
      "language",
      undefined as never,
      new SelectionSet(select(Language))
    ),

  /**
   * @description The gist file name.
   */
  name: () => new Field("name"),

  /**
   * @description The gist file size in bytes.
   */
  size: () => new Field("size"),

  /**
   * @description UTF8 text data or null if the file is binary
   */
  text: (variables) => new Field("text"),
};

export interface IGitActor {
  avatarUrl: unknown;
  date: unknown;
  email: string;
  name: string;
  user: IUser;
}

interface GitActorSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the author's public avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description The timestamp of the Git action (authoring or committing).
   */

  date: () => Field<"date">;

  /**
   * @description The email in the Git commit.
   */

  email: () => Field<"email">;

  /**
   * @description The name in the Git commit.
   */

  name: () => Field<"name">;

  /**
   * @description The GitHub user corresponding to the email field. Null if no such user exists.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const GitActor: GitActorSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the author's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description The timestamp of the Git action (authoring or committing).
   */
  date: () => new Field("date"),

  /**
   * @description The email in the Git commit.
   */
  email: () => new Field("email"),

  /**
   * @description The name in the Git commit.
   */
  name: () => new Field("name"),

  /**
   * @description The GitHub user corresponding to the email field. Null if no such user exists.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IGitActorConnection {
  edges: IGitActorEdge[];
  nodes: IGitActor[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface GitActorConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: GitActorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const GitActorConnection: GitActorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(GitActorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(GitActor))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IGitActorEdge {
  cursor: string;
  node: IGitActor;
}

interface GitActorEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const GitActorEdge: GitActorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(GitActor))),
};

export interface IGitHubMetadata {
  gitHubServicesSha: unknown;
  gitIpAddresses: string[];
  hookIpAddresses: string[];
  importerIpAddresses: string[];
  isPasswordAuthenticationVerifiable: boolean;
  pagesIpAddresses: string[];
}

interface GitHubMetadataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Returns a String that's a SHA of `github-services`
   */

  gitHubServicesSha: () => Field<"gitHubServicesSha">;

  /**
   * @description IP addresses that users connect to for git operations
   */

  gitIpAddresses: () => Field<"gitIpAddresses">;

  /**
   * @description IP addresses that service hooks are sent from
   */

  hookIpAddresses: () => Field<"hookIpAddresses">;

  /**
   * @description IP addresses that the importer connects from
   */

  importerIpAddresses: () => Field<"importerIpAddresses">;

  /**
   * @description Whether or not users are verified
   */

  isPasswordAuthenticationVerifiable: () => Field<"isPasswordAuthenticationVerifiable">;

  /**
   * @description IP addresses for GitHub Pages' A records
   */

  pagesIpAddresses: () => Field<"pagesIpAddresses">;
}

export const GitHubMetadata: GitHubMetadataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Returns a String that's a SHA of `github-services`
   */
  gitHubServicesSha: () => new Field("gitHubServicesSha"),

  /**
   * @description IP addresses that users connect to for git operations
   */
  gitIpAddresses: () => new Field("gitIpAddresses"),

  /**
   * @description IP addresses that service hooks are sent from
   */
  hookIpAddresses: () => new Field("hookIpAddresses"),

  /**
   * @description IP addresses that the importer connects from
   */
  importerIpAddresses: () => new Field("importerIpAddresses"),

  /**
   * @description Whether or not users are verified
   */
  isPasswordAuthenticationVerifiable: () =>
    new Field("isPasswordAuthenticationVerifiable"),

  /**
   * @description IP addresses for GitHub Pages' A records
   */
  pagesIpAddresses: () => new Field("pagesIpAddresses"),
};

export interface IGitObject {
  __typename: string;
  abbreviatedOid: string;
  commitResourcePath: unknown;
  commitUrl: unknown;
  id: string;
  oid: unknown;
  repository: IRepository;
}

interface GitObjectSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description The HTTP path for this Git object
   */

  commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  commitUrl: () => Field<"commitUrl">;

  id: () => Field<"id">;

  /**
   * @description The Git object ID
   */

  oid: () => Field<"oid">;

  /**
   * @description The Repository the Git object belongs to
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  on: <
    T extends Array<Selection>,
    F extends "Blob" | "Commit" | "Tag" | "Tree"
  >(
    type: F,
    select: (
      t: F extends "Blob"
        ? BlobSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "Tag"
        ? TagSelector
        : F extends "Tree"
        ? TreeSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const GitObject: GitObjectSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),
  id: () => new Field("id"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The Repository the Git object belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  on: (type, select) => {
    switch (type) {
      case "Blob": {
        return new InlineFragment(
          new NamedType("Blob") as any,
          new SelectionSet(select(Blob as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "Tag": {
        return new InlineFragment(
          new NamedType("Tag") as any,
          new SelectionSet(select(Tag as any))
        );
      }

      case "Tree": {
        return new InlineFragment(
          new NamedType("Tree") as any,
          new SelectionSet(select(Tree as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IGitSignature {
  __typename: string;
  email: string;
  isValid: boolean;
  payload: string;
  signature: string;
  signer: IUser;
  state: GitSignatureState;
  wasSignedByGitHub: boolean;
}

interface GitSignatureSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Email used to sign this object.
   */

  email: () => Field<"email">;

  /**
   * @description True if the signature is valid and verified by GitHub.
   */

  isValid: () => Field<"isValid">;

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */

  payload: () => Field<"payload">;

  /**
   * @description ASCII-armored signature header from object.
   */

  signature: () => Field<"signature">;

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"signer", never, SelectionSet<T>>;

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */

  state: () => Field<"state">;

  /**
   * @description True if the signature was made with GitHub's signing key.
   */

  wasSignedByGitHub: () => Field<"wasSignedByGitHub">;

  on: <
    T extends Array<Selection>,
    F extends "GpgSignature" | "SmimeSignature" | "UnknownSignature"
  >(
    type: F,
    select: (
      t: F extends "GpgSignature"
        ? GpgSignatureSelector
        : F extends "SmimeSignature"
        ? SmimeSignatureSelector
        : F extends "UnknownSignature"
        ? UnknownSignatureSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const GitSignature: GitSignatureSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Email used to sign this object.
   */
  email: () => new Field("email"),

  /**
   * @description True if the signature is valid and verified by GitHub.
   */
  isValid: () => new Field("isValid"),

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */
  payload: () => new Field("payload"),

  /**
   * @description ASCII-armored signature header from object.
   */
  signature: () => new Field("signature"),

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: (select) =>
    new Field("signer", undefined as never, new SelectionSet(select(User))),

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */
  state: () => new Field("state"),

  /**
   * @description True if the signature was made with GitHub's signing key.
   */
  wasSignedByGitHub: () => new Field("wasSignedByGitHub"),

  on: (type, select) => {
    switch (type) {
      case "GpgSignature": {
        return new InlineFragment(
          new NamedType("GpgSignature") as any,
          new SelectionSet(select(GpgSignature as any))
        );
      }

      case "SmimeSignature": {
        return new InlineFragment(
          new NamedType("SmimeSignature") as any,
          new SelectionSet(select(SmimeSignature as any))
        );
      }

      case "UnknownSignature": {
        return new InlineFragment(
          new NamedType("UnknownSignature") as any,
          new SelectionSet(select(UnknownSignature as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IGpgSignature extends IGitSignature {
  __typename: "GpgSignature";
  keyId: string;
}

interface GpgSignatureSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Email used to sign this object.
   */

  email: () => Field<"email">;

  /**
   * @description True if the signature is valid and verified by GitHub.
   */

  isValid: () => Field<"isValid">;

  /**
   * @description Hex-encoded ID of the key that signed this object.
   */

  keyId: () => Field<"keyId">;

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */

  payload: () => Field<"payload">;

  /**
   * @description ASCII-armored signature header from object.
   */

  signature: () => Field<"signature">;

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"signer", never, SelectionSet<T>>;

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */

  state: () => Field<"state">;

  /**
   * @description True if the signature was made with GitHub's signing key.
   */

  wasSignedByGitHub: () => Field<"wasSignedByGitHub">;
}

export const isGpgSignature = (
  object: Record<string, any>
): object is Partial<IGpgSignature> => {
  return object.__typename === "GpgSignature";
};

export const GpgSignature: GpgSignatureSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Email used to sign this object.
   */
  email: () => new Field("email"),

  /**
   * @description True if the signature is valid and verified by GitHub.
   */
  isValid: () => new Field("isValid"),

  /**
   * @description Hex-encoded ID of the key that signed this object.
   */
  keyId: () => new Field("keyId"),

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */
  payload: () => new Field("payload"),

  /**
   * @description ASCII-armored signature header from object.
   */
  signature: () => new Field("signature"),

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: (select) =>
    new Field("signer", undefined as never, new SelectionSet(select(User))),

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */
  state: () => new Field("state"),

  /**
   * @description True if the signature was made with GitHub's signing key.
   */
  wasSignedByGitHub: () => new Field("wasSignedByGitHub"),
};

export interface IHeadRefDeletedEvent extends INode {
  __typename: "HeadRefDeletedEvent";
  actor: IActor;
  createdAt: unknown;
  headRef: IRef;
  headRefName: string;
  pullRequest: IPullRequest;
}

interface HeadRefDeletedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the Ref associated with the `head_ref_deleted` event.
   */

  headRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"headRef", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the Ref associated with the `head_ref_deleted` event.
   */

  headRefName: () => Field<"headRefName">;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isHeadRefDeletedEvent = (
  object: Record<string, any>
): object is Partial<IHeadRefDeletedEvent> => {
  return object.__typename === "HeadRefDeletedEvent";
};

export const HeadRefDeletedEvent: HeadRefDeletedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the Ref associated with the `head_ref_deleted` event.
   */

  headRef: (select) =>
    new Field("headRef", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the name of the Ref associated with the `head_ref_deleted` event.
   */
  headRefName: () => new Field("headRefName"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IHeadRefForcePushedEvent extends INode {
  __typename: "HeadRefForcePushedEvent";
  actor: IActor;
  afterCommit: ICommit;
  beforeCommit: ICommit;
  createdAt: unknown;
  pullRequest: IPullRequest;
  ref: IRef;
}

interface HeadRefForcePushedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the after commit SHA for the 'head_ref_force_pushed' event.
   */

  afterCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"afterCommit", never, SelectionSet<T>>;

  /**
   * @description Identifies the before commit SHA for the 'head_ref_force_pushed' event.
   */

  beforeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"beforeCommit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the fully qualified ref name for the 'head_ref_force_pushed' event.
   */

  ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const isHeadRefForcePushedEvent = (
  object: Record<string, any>
): object is Partial<IHeadRefForcePushedEvent> => {
  return object.__typename === "HeadRefForcePushedEvent";
};

export const HeadRefForcePushedEvent: HeadRefForcePushedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the after commit SHA for the 'head_ref_force_pushed' event.
   */

  afterCommit: (select) =>
    new Field(
      "afterCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Identifies the before commit SHA for the 'head_ref_force_pushed' event.
   */

  beforeCommit: (select) =>
    new Field(
      "beforeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the fully qualified ref name for the 'head_ref_force_pushed' event.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IHeadRefRestoredEvent extends INode {
  __typename: "HeadRefRestoredEvent";
  actor: IActor;
  createdAt: unknown;
  pullRequest: IPullRequest;
}

interface HeadRefRestoredEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const isHeadRefRestoredEvent = (
  object: Record<string, any>
): object is Partial<IHeadRefRestoredEvent> => {
  return object.__typename === "HeadRefRestoredEvent";
};

export const HeadRefRestoredEvent: HeadRefRestoredEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IHovercard {
  contexts: IHovercardContext[];
}

interface HovercardSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Each of the contexts for this hovercard
   */

  contexts: <T extends Array<Selection>>(
    select: (t: HovercardContextSelector) => T
  ) => Field<"contexts", never, SelectionSet<T>>;
}

export const Hovercard: HovercardSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Each of the contexts for this hovercard
   */

  contexts: (select) =>
    new Field(
      "contexts",
      undefined as never,
      new SelectionSet(select(HovercardContext))
    ),
};

export interface IHovercardContext {
  __typename: string;
  message: string;
  octicon: string;
}

interface HovercardContextSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  octicon: () => Field<"octicon">;

  on: <
    T extends Array<Selection>,
    F extends
      | "GenericHovercardContext"
      | "OrganizationTeamsHovercardContext"
      | "OrganizationsHovercardContext"
      | "ReviewStatusHovercardContext"
      | "ViewerHovercardContext"
  >(
    type: F,
    select: (
      t: F extends "GenericHovercardContext"
        ? GenericHovercardContextSelector
        : F extends "OrganizationTeamsHovercardContext"
        ? OrganizationTeamsHovercardContextSelector
        : F extends "OrganizationsHovercardContext"
        ? OrganizationsHovercardContextSelector
        : F extends "ReviewStatusHovercardContext"
        ? ReviewStatusHovercardContextSelector
        : F extends "ViewerHovercardContext"
        ? ViewerHovercardContextSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const HovercardContext: HovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  on: (type, select) => {
    switch (type) {
      case "GenericHovercardContext": {
        return new InlineFragment(
          new NamedType("GenericHovercardContext") as any,
          new SelectionSet(select(GenericHovercardContext as any))
        );
      }

      case "OrganizationTeamsHovercardContext": {
        return new InlineFragment(
          new NamedType("OrganizationTeamsHovercardContext") as any,
          new SelectionSet(select(OrganizationTeamsHovercardContext as any))
        );
      }

      case "OrganizationsHovercardContext": {
        return new InlineFragment(
          new NamedType("OrganizationsHovercardContext") as any,
          new SelectionSet(select(OrganizationsHovercardContext as any))
        );
      }

      case "ReviewStatusHovercardContext": {
        return new InlineFragment(
          new NamedType("ReviewStatusHovercardContext") as any,
          new SelectionSet(select(ReviewStatusHovercardContext as any))
        );
      }

      case "ViewerHovercardContext": {
        return new InlineFragment(
          new NamedType("ViewerHovercardContext") as any,
          new SelectionSet(select(ViewerHovercardContext as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IInviteEnterpriseAdminPayload {
  clientMutationId: string;
  invitation: IEnterpriseAdministratorInvitation;
}

interface InviteEnterpriseAdminPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The created enterprise administrator invitation.
   */

  invitation: <T extends Array<Selection>>(
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<"invitation", never, SelectionSet<T>>;
}

export const InviteEnterpriseAdminPayload: InviteEnterpriseAdminPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The created enterprise administrator invitation.
   */

  invitation: (select) =>
    new Field(
      "invitation",
      undefined as never,
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),
};

export interface IIpAllowListEntry extends INode {
  __typename: "IpAllowListEntry";
  allowListValue: string;
  createdAt: unknown;
  isActive: boolean;
  name: string;
  owner: IIpAllowListOwner;
  updatedAt: unknown;
}

interface IpAllowListEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A single IP address or range of IP addresses in CIDR notation.
   */

  allowListValue: () => Field<"allowListValue">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Whether the entry is currently active.
   */

  isActive: () => Field<"isActive">;

  /**
   * @description The name of the IP allow list entry.
   */

  name: () => Field<"name">;

  /**
   * @description The owner of the IP allow list entry.
   */

  owner: <T extends Array<Selection>>(
    select: (t: IpAllowListOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;
}

export const isIpAllowListEntry = (
  object: Record<string, any>
): object is Partial<IIpAllowListEntry> => {
  return object.__typename === "IpAllowListEntry";
};

export const IpAllowListEntry: IpAllowListEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A single IP address or range of IP addresses in CIDR notation.
   */
  allowListValue: () => new Field("allowListValue"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the entry is currently active.
   */
  isActive: () => new Field("isActive"),

  /**
   * @description The name of the IP allow list entry.
   */
  name: () => new Field("name"),

  /**
   * @description The owner of the IP allow list entry.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(IpAllowListOwner))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IIpAllowListEntryConnection {
  edges: IIpAllowListEntryEdge[];
  nodes: IIpAllowListEntry[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface IpAllowListEntryConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: IpAllowListEntryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const IpAllowListEntryConnection: IpAllowListEntryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(IpAllowListEntryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IIpAllowListEntryEdge {
  cursor: string;
  node: IIpAllowListEntry;
}

interface IpAllowListEntryEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IpAllowListEntryEdge: IpAllowListEntryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),
};

export interface IIssue
  extends IAssignable,
    IClosable,
    IComment,
    ILabelable,
    ILockable,
    INode,
    IReactable,
    IRepositoryNode,
    ISubscribable,
    IUniformResourceLocatable,
    IUpdatable,
    IUpdatableComment {
  __typename: "Issue";
  bodyResourcePath: unknown;
  bodyUrl: unknown;
  comments: IIssueCommentConnection;
  hovercard: IHovercard;
  isReadByViewer: boolean;
  milestone: IMilestone;
  number: number;
  participants: IUserConnection;
  projectCards: IProjectCardConnection;
  state: IssueState;
  timeline: IIssueTimelineConnection;
  timelineItems: IIssueTimelineItemsConnection;
  title: string;
}

interface IssueSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Reason that the conversation was locked.
   */

  activeLockReason: () => Field<"activeLockReason">;

  /**
   * @description A list of Users assigned to this object.
   */

  assignees: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "assignees",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Identifies the body of the issue.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The http path for this issue body
   */

  bodyResourcePath: () => Field<"bodyResourcePath">;

  /**
   * @description Identifies the body of the issue rendered to text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description The http URL for this issue body
   */

  bodyUrl: () => Field<"bodyUrl">;

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */

  closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  closedAt: () => Field<"closedAt">;

  /**
   * @description A list of comments associated with the Issue.
   */

  comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueCommentOrder;
    },
    select: (t: IssueCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueCommentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  /**
   * @description The hovercard information for this issue
   */

  hovercard: <T extends Array<Selection>>(
    variables: {
      includeNotificationContexts?:
        | Variable<"includeNotificationContexts">
        | boolean;
    },
    select: (t: HovercardSelector) => T
  ) => Field<
    "hovercard",
    [
      Argument<
        "includeNotificationContexts",
        Variable<"includeNotificationContexts"> | boolean
      >
    ],
    SelectionSet<T>
  >;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Is this issue read by the viewer
   */

  isReadByViewer: () => Field<"isReadByViewer">;

  /**
   * @description A list of labels associated with the object.
   */

  labels: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LabelOrder;
    },
    select: (t: LabelConnectionSelector) => T
  ) => Field<
    "labels",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LabelOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description `true` if the object is locked
   */

  locked: () => Field<"locked">;

  /**
   * @description Identifies the milestone associated with the issue.
   */

  milestone: <T extends Array<Selection>>(
    select: (t: MilestoneSelector) => T
  ) => Field<"milestone", never, SelectionSet<T>>;

  /**
   * @description Identifies the issue number.
   */

  number: () => Field<"number">;

  /**
   * @description A list of Users that are participating in the Issue conversation.
   */

  participants: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "participants",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description List of project cards associated with this issue.
   */

  projectCards: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      archivedStates?: Variable<"archivedStates"> | ProjectCardArchivedState;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectCardConnectionSelector) => T
  ) => Field<
    "projectCards",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<
        "archivedStates",
        Variable<"archivedStates"> | ProjectCardArchivedState
      >,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this issue
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the state of the issue.
   */

  state: () => Field<"state">;

  /**
   * @description A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */

  timeline: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      since?: Variable<"since"> | unknown;
    },
    select: (t: IssueTimelineConnectionSelector) => T
  ) => Field<
    "timeline",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"since", Variable<"since"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of events, comments, commits, etc. associated with the issue.
   */

  timelineItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      itemTypes?: Variable<"itemTypes"> | IssueTimelineItemsItemType;
      last?: Variable<"last"> | number;
      since?: Variable<"since"> | unknown;
      skip?: Variable<"skip"> | number;
    },
    select: (t: IssueTimelineItemsConnectionSelector) => T
  ) => Field<
    "timelineItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"itemTypes", Variable<"itemTypes"> | IssueTimelineItemsItemType>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"since", Variable<"since"> | unknown>,
      Argument<"skip", Variable<"skip"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the issue title.
   */

  title: () => Field<"title">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this issue
   */

  url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Can user react to this subject
   */

  viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  viewerSubscription: () => Field<"viewerSubscription">;
}

export const isIssue = (
  object: Record<string, any>
): object is Partial<IIssue> => {
  return object.__typename === "Issue";
};

export const Issue: IssueSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Reason that the conversation was locked.
   */
  activeLockReason: () => new Field("activeLockReason"),

  /**
   * @description A list of Users assigned to this object.
   */

  assignees: (variables, select) =>
    new Field(
      "assignees",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Identifies the body of the issue.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The http path for this issue body
   */
  bodyResourcePath: () => new Field("bodyResourcePath"),

  /**
   * @description Identifies the body of the issue rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description The http URL for this issue body
   */
  bodyUrl: () => new Field("bodyUrl"),

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  /**
   * @description A list of comments associated with the Issue.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IssueCommentConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The hovercard information for this issue
   */

  hovercard: (variables, select) =>
    new Field(
      "hovercard",
      [
        new Argument(
          "includeNotificationContexts",
          variables.includeNotificationContexts
        ),
      ],
      new SelectionSet(select(Hovercard))
    ),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Is this issue read by the viewer
   */
  isReadByViewer: () => new Field("isReadByViewer"),

  /**
   * @description A list of labels associated with the object.
   */

  labels: (variables, select) =>
    new Field(
      "labels",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(LabelConnection))
    ),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description `true` if the object is locked
   */
  locked: () => new Field("locked"),

  /**
   * @description Identifies the milestone associated with the issue.
   */

  milestone: (select) =>
    new Field(
      "milestone",
      undefined as never,
      new SelectionSet(select(Milestone))
    ),

  /**
   * @description Identifies the issue number.
   */
  number: () => new Field("number"),

  /**
   * @description A list of Users that are participating in the Issue conversation.
   */

  participants: (variables, select) =>
    new Field(
      "participants",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description List of project cards associated with this issue.
   */

  projectCards: (variables, select) =>
    new Field(
      "projectCards",
      [
        new Argument("after", variables.after),
        new Argument(
          "archivedStates",
          variables.archivedStates,
          ProjectCardArchivedState
        ),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectCardConnection))
    ),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this issue
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the state of the issue.
   */
  state: () => new Field("state"),

  /**
   * @description A list of events, comments, commits, etc. associated with the issue.
   * @deprecated `timeline` will be removed Use Issue.timelineItems instead. Removal on 2020-10-01 UTC.
   */

  timeline: (variables, select) =>
    new Field(
      "timeline",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("since", variables.since),
      ],
      new SelectionSet(select(IssueTimelineConnection))
    ),

  /**
   * @description A list of events, comments, commits, etc. associated with the issue.
   */

  timelineItems: (variables, select) =>
    new Field(
      "timelineItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument(
          "itemTypes",
          variables.itemTypes,
          IssueTimelineItemsItemType
        ),
        new Argument("last", variables.last),
        new Argument("since", variables.since),
        new Argument("skip", variables.skip),
      ],
      new SelectionSet(select(IssueTimelineItemsConnection))
    ),

  /**
   * @description Identifies the issue title.
   */
  title: () => new Field("title"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this issue
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),
};

export interface IIssueComment
  extends IComment,
    IDeletable,
    IMinimizable,
    INode,
    IReactable,
    IRepositoryNode,
    IUpdatable,
    IUpdatableComment {
  __typename: "IssueComment";
  issue: IIssue;
  pullRequest: IPullRequest;
  resourcePath: unknown;
  url: unknown;
}

interface IssueCommentSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The body as Markdown.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  isMinimized: () => Field<"isMinimized">;

  /**
   * @description Identifies the issue associated with the comment.
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Returns why the comment was minimized.
   */

  minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
     * @description Returns the pull request associated with the comment, if this comment was made on a
pull request.
     */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this issue comment
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this issue comment
   */

  url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  viewerCanMinimize: () => Field<"viewerCanMinimize">;

  /**
   * @description Can user react to this subject
   */

  viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isIssueComment = (
  object: Record<string, any>
): object is Partial<IIssueComment> => {
  return object.__typename === "IssueComment";
};

export const IssueComment: IssueCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description Identifies the issue associated with the comment.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
     * @description Returns the pull request associated with the comment, if this comment was made on a
pull request.
     */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this issue comment
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this issue comment
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface IIssueCommentConnection {
  edges: IIssueCommentEdge[];
  nodes: IIssueComment[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface IssueCommentConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: IssueCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: IssueCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const IssueCommentConnection: IssueCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(IssueCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(IssueComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IIssueCommentEdge {
  cursor: string;
  node: IIssueComment;
}

interface IssueCommentEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: IssueCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IssueCommentEdge: IssueCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(IssueComment))
    ),
};

export interface IIssueConnection {
  edges: IIssueEdge[];
  nodes: IIssue[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface IssueConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: IssueEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const IssueConnection: IssueConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(IssueEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Issue))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IIssueContributionsByRepository {
  contributions: ICreatedIssueContributionConnection;
  repository: IRepository;
}

interface IssueContributionsByRepositorySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The issue contributions.
   */

  contributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedIssueContributionConnectionSelector) => T
  ) => Field<
    "contributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository in which the issues were opened.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const IssueContributionsByRepository: IssueContributionsByRepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The issue contributions.
   */

  contributions: (variables, select) =>
    new Field(
      "contributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedIssueContributionConnection))
    ),

  /**
   * @description The repository in which the issues were opened.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IIssueEdge {
  cursor: string;
  node: IIssue;
}

interface IssueEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IssueEdge: IssueEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Issue))),
};

export interface IIssueTemplate {
  about: string;
  body: string;
  name: string;
  title: string;
}

interface IssueTemplateSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The template purpose.
   */

  about: () => Field<"about">;

  /**
   * @description The suggested issue body.
   */

  body: () => Field<"body">;

  /**
   * @description The template name.
   */

  name: () => Field<"name">;

  /**
   * @description The suggested issue title.
   */

  title: () => Field<"title">;
}

export const IssueTemplate: IssueTemplateSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The template purpose.
   */
  about: () => new Field("about"),

  /**
   * @description The suggested issue body.
   */
  body: () => new Field("body"),

  /**
   * @description The template name.
   */
  name: () => new Field("name"),

  /**
   * @description The suggested issue title.
   */
  title: () => new Field("title"),
};

export interface IIssueTimelineConnection {
  edges: IIssueTimelineItemEdge[];
  nodes: IIssueTimelineItem[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface IssueTimelineConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const IssueTimelineConnection: IssueTimelineConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(IssueTimelineItemEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(IssueTimelineItem))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IIssueTimelineItemEdge {
  cursor: string;
  node: IIssueTimelineItem;
}

interface IssueTimelineItemEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IssueTimelineItemEdge: IssueTimelineItemEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(IssueTimelineItem))
    ),
};

export interface IIssueTimelineItemsConnection {
  edges: IIssueTimelineItemsEdge[];
  filteredCount: number;
  nodes: IIssueTimelineItems[];
  pageCount: number;
  pageInfo: IPageInfo;
  totalCount: number;
  updatedAt: unknown;
}

interface IssueTimelineItemsConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemsEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description Identifies the count of items after applying `before` and `after` filters.
   */

  filteredCount: () => Field<"filteredCount">;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemsSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
   */

  pageCount: () => Field<"pageCount">;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;

  /**
   * @description Identifies the date and time when the timeline was last updated.
   */

  updatedAt: () => Field<"updatedAt">;
}

export const IssueTimelineItemsConnection: IssueTimelineItemsConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(IssueTimelineItemsEdge))
    ),

  /**
   * @description Identifies the count of items after applying `before` and `after` filters.
   */
  filteredCount: () => new Field("filteredCount"),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(IssueTimelineItems))
    ),

  /**
   * @description Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
   */
  pageCount: () => new Field("pageCount"),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description Identifies the date and time when the timeline was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IIssueTimelineItemsEdge {
  cursor: string;
  node: IIssueTimelineItems;
}

interface IssueTimelineItemsEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: IssueTimelineItemsSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const IssueTimelineItemsEdge: IssueTimelineItemsEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(IssueTimelineItems))
    ),
};

export interface IJoinedGitHubContribution extends IContribution {
  __typename: "JoinedGitHubContribution";
}

interface JoinedGitHubContributionSelector {
  __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  occurredAt: () => Field<"occurredAt">;

  /**
   * @description The HTTP path for this contribution.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isJoinedGitHubContribution = (
  object: Record<string, any>
): object is Partial<IJoinedGitHubContribution> => {
  return object.__typename === "JoinedGitHubContribution";
};

export const JoinedGitHubContribution: JoinedGitHubContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ILabel extends INode {
  __typename: "Label";
  color: string;
  createdAt: unknown;
  description: string;
  isDefault: boolean;
  issues: IIssueConnection;
  name: string;
  pullRequests: IPullRequestConnection;
  repository: IRepository;
  resourcePath: unknown;
  updatedAt: unknown;
  url: unknown;
}

interface LabelSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the label color.
   */

  color: () => Field<"color">;

  /**
   * @description Identifies the date and time when the label was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description A brief description of this label.
   */

  description: () => Field<"description">;

  id: () => Field<"id">;

  /**
   * @description Indicates whether or not this is a default label.
   */

  isDefault: () => Field<"isDefault">;

  /**
   * @description A list of issues associated with this label.
   */

  issues: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | IssueFilters;
      first?: Variable<"first"> | number;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | IssueState;
    },
    select: (t: IssueConnectionSelector) => T
  ) => Field<
    "issues",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | IssueFilters>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | IssueState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the label name.
   */

  name: () => Field<"name">;

  /**
   * @description A list of pull requests associated with this label.
   */

  pullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "pullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this label.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this label.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the label was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this label.
   */

  url: () => Field<"url">;
}

export const isLabel = (
  object: Record<string, any>
): object is Partial<ILabel> => {
  return object.__typename === "Label";
};

export const Label: LabelSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the label color.
   */
  color: () => new Field("color"),

  /**
   * @description Identifies the date and time when the label was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description A brief description of this label.
   */
  description: () => new Field("description"),
  id: () => new Field("id"),

  /**
   * @description Indicates whether or not this is a default label.
   */
  isDefault: () => new Field("isDefault"),

  /**
   * @description A list of issues associated with this label.
   */

  issues: (variables, select) =>
    new Field(
      "issues",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, IssueState),
      ],
      new SelectionSet(select(IssueConnection))
    ),

  /**
   * @description Identifies the label name.
   */
  name: () => new Field("name"),

  /**
   * @description A list of pull requests associated with this label.
   */

  pullRequests: (variables, select) =>
    new Field(
      "pullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description The repository associated with this label.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this label.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the label was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this label.
   */
  url: () => new Field("url"),
};

export interface ILabelConnection {
  edges: ILabelEdge[];
  nodes: ILabel[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface LabelConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: LabelEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: LabelSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const LabelConnection: LabelConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(LabelEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Label))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ILabelEdge {
  cursor: string;
  node: ILabel;
}

interface LabelEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: LabelSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const LabelEdge: LabelEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Label))),
};

export interface ILabelable {
  __typename: string;
  labels: ILabelConnection;
}

interface LabelableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of labels associated with the object.
   */

  labels: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LabelOrder;
    },
    select: (t: LabelConnectionSelector) => T
  ) => Field<
    "labels",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LabelOrder>
    ],
    SelectionSet<T>
  >;

  on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Labelable: LabelableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of labels associated with the object.
   */

  labels: (variables, select) =>
    new Field(
      "labels",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(LabelConnection))
    ),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface ILabeledEvent extends INode {
  __typename: "LabeledEvent";
  actor: IActor;
  createdAt: unknown;
  label: ILabel;
  labelable: ILabelable;
}

interface LabeledEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Identifies the label associated with the 'labeled' event.
   */

  label: <T extends Array<Selection>>(
    select: (t: LabelSelector) => T
  ) => Field<"label", never, SelectionSet<T>>;

  /**
   * @description Identifies the `Labelable` associated with the event.
   */

  labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const isLabeledEvent = (
  object: Record<string, any>
): object is Partial<ILabeledEvent> => {
  return object.__typename === "LabeledEvent";
};

export const LabeledEvent: LabeledEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the label associated with the 'labeled' event.
   */

  label: (select) =>
    new Field("label", undefined as never, new SelectionSet(select(Label))),

  /**
   * @description Identifies the `Labelable` associated with the event.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface ILanguage extends INode {
  __typename: "Language";
  color: string;
  name: string;
}

interface LanguageSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The color defined for the current language.
   */

  color: () => Field<"color">;

  id: () => Field<"id">;

  /**
   * @description The name of the current language.
   */

  name: () => Field<"name">;
}

export const isLanguage = (
  object: Record<string, any>
): object is Partial<ILanguage> => {
  return object.__typename === "Language";
};

export const Language: LanguageSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The color defined for the current language.
   */
  color: () => new Field("color"),
  id: () => new Field("id"),

  /**
   * @description The name of the current language.
   */
  name: () => new Field("name"),
};

export interface ILanguageConnection {
  edges: ILanguageEdge[];
  nodes: ILanguage[];
  pageInfo: IPageInfo;
  totalCount: number;
  totalSize: number;
}

interface LanguageConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: LanguageEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: LanguageSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;

  /**
   * @description The total size in bytes of files written in that language.
   */

  totalSize: () => Field<"totalSize">;
}

export const LanguageConnection: LanguageConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(LanguageEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Language))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description The total size in bytes of files written in that language.
   */
  totalSize: () => new Field("totalSize"),
};

export interface ILanguageEdge {
  cursor: string;
  node: ILanguage;
  size: number;
}

interface LanguageEdgeSelector {
  __typename: () => Field<"__typename">;

  cursor: () => Field<"cursor">;

  node: <T extends Array<Selection>>(
    select: (t: LanguageSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The number of bytes of code written in the language.
   */

  size: () => Field<"size">;
}

export const LanguageEdge: LanguageEdgeSelector = {
  __typename: () => new Field("__typename"),

  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Language))),

  /**
   * @description The number of bytes of code written in the language.
   */
  size: () => new Field("size"),
};

export interface ILicense extends INode {
  __typename: "License";
  body: string;
  conditions: ILicenseRule[];
  description: string;
  featured: boolean;
  hidden: boolean;
  implementation: string;
  key: string;
  limitations: ILicenseRule[];
  name: string;
  nickname: string;
  permissions: ILicenseRule[];
  pseudoLicense: boolean;
  spdxId: string;
  url: unknown;
}

interface LicenseSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The full text of the license
   */

  body: () => Field<"body">;

  /**
   * @description The conditions set by the license
   */

  conditions: <T extends Array<Selection>>(
    select: (t: LicenseRuleSelector) => T
  ) => Field<"conditions", never, SelectionSet<T>>;

  /**
   * @description A human-readable description of the license
   */

  description: () => Field<"description">;

  /**
   * @description Whether the license should be featured
   */

  featured: () => Field<"featured">;

  /**
   * @description Whether the license should be displayed in license pickers
   */

  hidden: () => Field<"hidden">;

  id: () => Field<"id">;

  /**
   * @description Instructions on how to implement the license
   */

  implementation: () => Field<"implementation">;

  /**
   * @description The lowercased SPDX ID of the license
   */

  key: () => Field<"key">;

  /**
   * @description The limitations set by the license
   */

  limitations: <T extends Array<Selection>>(
    select: (t: LicenseRuleSelector) => T
  ) => Field<"limitations", never, SelectionSet<T>>;

  /**
   * @description The license full name specified by <https://spdx.org/licenses>
   */

  name: () => Field<"name">;

  /**
   * @description Customary short name if applicable (e.g, GPLv3)
   */

  nickname: () => Field<"nickname">;

  /**
   * @description The permissions set by the license
   */

  permissions: <T extends Array<Selection>>(
    select: (t: LicenseRuleSelector) => T
  ) => Field<"permissions", never, SelectionSet<T>>;

  /**
   * @description Whether the license is a pseudo-license placeholder (e.g., other, no-license)
   */

  pseudoLicense: () => Field<"pseudoLicense">;

  /**
   * @description Short identifier specified by <https://spdx.org/licenses>
   */

  spdxId: () => Field<"spdxId">;

  /**
   * @description URL to the license on <https://choosealicense.com>
   */

  url: () => Field<"url">;
}

export const isLicense = (
  object: Record<string, any>
): object is Partial<ILicense> => {
  return object.__typename === "License";
};

export const License: LicenseSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The full text of the license
   */
  body: () => new Field("body"),

  /**
   * @description The conditions set by the license
   */

  conditions: (select) =>
    new Field(
      "conditions",
      undefined as never,
      new SelectionSet(select(LicenseRule))
    ),

  /**
   * @description A human-readable description of the license
   */
  description: () => new Field("description"),

  /**
   * @description Whether the license should be featured
   */
  featured: () => new Field("featured"),

  /**
   * @description Whether the license should be displayed in license pickers
   */
  hidden: () => new Field("hidden"),
  id: () => new Field("id"),

  /**
   * @description Instructions on how to implement the license
   */
  implementation: () => new Field("implementation"),

  /**
   * @description The lowercased SPDX ID of the license
   */
  key: () => new Field("key"),

  /**
   * @description The limitations set by the license
   */

  limitations: (select) =>
    new Field(
      "limitations",
      undefined as never,
      new SelectionSet(select(LicenseRule))
    ),

  /**
   * @description The license full name specified by <https://spdx.org/licenses>
   */
  name: () => new Field("name"),

  /**
   * @description Customary short name if applicable (e.g, GPLv3)
   */
  nickname: () => new Field("nickname"),

  /**
   * @description The permissions set by the license
   */

  permissions: (select) =>
    new Field(
      "permissions",
      undefined as never,
      new SelectionSet(select(LicenseRule))
    ),

  /**
   * @description Whether the license is a pseudo-license placeholder (e.g., other, no-license)
   */
  pseudoLicense: () => new Field("pseudoLicense"),

  /**
   * @description Short identifier specified by <https://spdx.org/licenses>
   */
  spdxId: () => new Field("spdxId"),

  /**
   * @description URL to the license on <https://choosealicense.com>
   */
  url: () => new Field("url"),
};

export interface ILicenseRule {
  description: string;
  key: string;
  label: string;
}

interface LicenseRuleSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A description of the rule
   */

  description: () => Field<"description">;

  /**
   * @description The machine-readable rule key
   */

  key: () => Field<"key">;

  /**
   * @description The human-readable rule label
   */

  label: () => Field<"label">;
}

export const LicenseRule: LicenseRuleSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A description of the rule
   */
  description: () => new Field("description"),

  /**
   * @description The machine-readable rule key
   */
  key: () => new Field("key"),

  /**
   * @description The human-readable rule label
   */
  label: () => new Field("label"),
};

export interface ILinkRepositoryToProjectPayload {
  clientMutationId: string;
  project: IProject;
  repository: IRepository;
}

interface LinkRepositoryToProjectPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The linked Project.
   */

  project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;

  /**
   * @description The linked Repository.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const LinkRepositoryToProjectPayload: LinkRepositoryToProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The linked Project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description The linked Repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ILockLockablePayload {
  actor: IActor;
  clientMutationId: string;
  lockedRecord: ILockable;
}

interface LockLockablePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The item that was locked.
   */

  lockedRecord: <T extends Array<Selection>>(
    select: (t: LockableSelector) => T
  ) => Field<"lockedRecord", never, SelectionSet<T>>;
}

export const LockLockablePayload: LockLockablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The item that was locked.
   */

  lockedRecord: (select) =>
    new Field(
      "lockedRecord",
      undefined as never,
      new SelectionSet(select(Lockable))
    ),
};

export interface ILockable {
  __typename: string;
  activeLockReason: LockReason;
  locked: boolean;
}

interface LockableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Reason that the conversation was locked.
   */

  activeLockReason: () => Field<"activeLockReason">;

  /**
   * @description `true` if the object is locked
   */

  locked: () => Field<"locked">;

  on: <T extends Array<Selection>, F extends "Issue" | "PullRequest">(
    type: F,
    select: (
      t: F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Lockable: LockableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Reason that the conversation was locked.
   */
  activeLockReason: () => new Field("activeLockReason"),

  /**
   * @description `true` if the object is locked
   */
  locked: () => new Field("locked"),

  on: (type, select) => {
    switch (type) {
      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface ILockedEvent extends INode {
  __typename: "LockedEvent";
  actor: IActor;
  createdAt: unknown;
  lockReason: LockReason;
  lockable: ILockable;
}

interface LockedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Reason that the conversation was locked (optional).
   */

  lockReason: () => Field<"lockReason">;

  /**
   * @description Object that was locked.
   */

  lockable: <T extends Array<Selection>>(
    select: (t: LockableSelector) => T
  ) => Field<"lockable", never, SelectionSet<T>>;
}

export const isLockedEvent = (
  object: Record<string, any>
): object is Partial<ILockedEvent> => {
  return object.__typename === "LockedEvent";
};

export const LockedEvent: LockedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reason that the conversation was locked (optional).
   */
  lockReason: () => new Field("lockReason"),

  /**
   * @description Object that was locked.
   */

  lockable: (select) =>
    new Field(
      "lockable",
      undefined as never,
      new SelectionSet(select(Lockable))
    ),
};

export interface IMannequin extends IActor, INode, IUniformResourceLocatable {
  __typename: "Mannequin";
  createdAt: unknown;
  databaseId: number;
  email: string;
  updatedAt: unknown;
}

interface MannequinSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the GitHub App's public avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The mannequin's email on the source instance.
   */

  email: () => Field<"email">;

  id: () => Field<"id">;

  /**
   * @description The username of the actor.
   */

  login: () => Field<"login">;

  /**
   * @description The HTML path to this resource.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The URL to this resource.
   */

  url: () => Field<"url">;
}

export const isMannequin = (
  object: Record<string, any>
): object is Partial<IMannequin> => {
  return object.__typename === "Mannequin";
};

export const Mannequin: MannequinSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the GitHub App's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The mannequin's email on the source instance.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description The username of the actor.
   */
  login: () => new Field("login"),

  /**
   * @description The HTML path to this resource.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The URL to this resource.
   */
  url: () => new Field("url"),
};

export interface IMarkFileAsViewedPayload {
  clientMutationId: string;
  pullRequest: IPullRequest;
}

interface MarkFileAsViewedPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated pull request.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const MarkFileAsViewedPayload: MarkFileAsViewedPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated pull request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IMarkPullRequestReadyForReviewPayload {
  clientMutationId: string;
  pullRequest: IPullRequest;
}

interface MarkPullRequestReadyForReviewPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that is ready for review.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const MarkPullRequestReadyForReviewPayload: MarkPullRequestReadyForReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that is ready for review.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IMarkedAsDuplicateEvent extends INode {
  __typename: "MarkedAsDuplicateEvent";
  actor: IActor;
  canonical: IIssueOrPullRequest;
  createdAt: unknown;
  duplicate: IIssueOrPullRequest;
  isCrossRepository: boolean;
}

interface MarkedAsDuplicateEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The authoritative issue or pull request which has been duplicated by another.
   */

  canonical: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"canonical", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The issue or pull request which has been marked as a duplicate of another.
   */

  duplicate: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"duplicate", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Canonical and duplicate belong to different repositories.
   */

  isCrossRepository: () => Field<"isCrossRepository">;
}

export const isMarkedAsDuplicateEvent = (
  object: Record<string, any>
): object is Partial<IMarkedAsDuplicateEvent> => {
  return object.__typename === "MarkedAsDuplicateEvent";
};

export const MarkedAsDuplicateEvent: MarkedAsDuplicateEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The authoritative issue or pull request which has been duplicated by another.
   */

  canonical: (select) =>
    new Field(
      "canonical",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The issue or pull request which has been marked as a duplicate of another.
   */

  duplicate: (select) =>
    new Field(
      "duplicate",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),

  id: () => new Field("id"),

  /**
   * @description Canonical and duplicate belong to different repositories.
   */
  isCrossRepository: () => new Field("isCrossRepository"),
};

export interface IMarketplaceCategory extends INode {
  __typename: "MarketplaceCategory";
  description: string;
  howItWorks: string;
  name: string;
  primaryListingCount: number;
  resourcePath: unknown;
  secondaryListingCount: number;
  slug: string;
  url: unknown;
}

interface MarketplaceCategorySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The category's description.
   */

  description: () => Field<"description">;

  /**
   * @description The technical description of how apps listed in this category work with GitHub.
   */

  howItWorks: () => Field<"howItWorks">;

  id: () => Field<"id">;

  /**
   * @description The category's name.
   */

  name: () => Field<"name">;

  /**
   * @description How many Marketplace listings have this as their primary category.
   */

  primaryListingCount: () => Field<"primaryListingCount">;

  /**
   * @description The HTTP path for this Marketplace category.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description How many Marketplace listings have this as their secondary category.
   */

  secondaryListingCount: () => Field<"secondaryListingCount">;

  /**
   * @description The short name of the category used in its URL.
   */

  slug: () => Field<"slug">;

  /**
   * @description The HTTP URL for this Marketplace category.
   */

  url: () => Field<"url">;
}

export const isMarketplaceCategory = (
  object: Record<string, any>
): object is Partial<IMarketplaceCategory> => {
  return object.__typename === "MarketplaceCategory";
};

export const MarketplaceCategory: MarketplaceCategorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The category's description.
   */
  description: () => new Field("description"),

  /**
   * @description The technical description of how apps listed in this category work with GitHub.
   */
  howItWorks: () => new Field("howItWorks"),
  id: () => new Field("id"),

  /**
   * @description The category's name.
   */
  name: () => new Field("name"),

  /**
   * @description How many Marketplace listings have this as their primary category.
   */
  primaryListingCount: () => new Field("primaryListingCount"),

  /**
   * @description The HTTP path for this Marketplace category.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description How many Marketplace listings have this as their secondary category.
   */
  secondaryListingCount: () => new Field("secondaryListingCount"),

  /**
   * @description The short name of the category used in its URL.
   */
  slug: () => new Field("slug"),

  /**
   * @description The HTTP URL for this Marketplace category.
   */
  url: () => new Field("url"),
};

export interface IMarketplaceListing extends INode {
  __typename: "MarketplaceListing";
  app: IApp;
  companyUrl: unknown;
  configurationResourcePath: unknown;
  configurationUrl: unknown;
  documentationUrl: unknown;
  extendedDescription: string;
  extendedDescriptionHTML: unknown;
  fullDescription: string;
  fullDescriptionHTML: unknown;
  hasPublishedFreeTrialPlans: boolean;
  hasTermsOfService: boolean;
  hasVerifiedOwner: boolean;
  howItWorks: string;
  howItWorksHTML: unknown;
  installationUrl: unknown;
  installedForViewer: boolean;
  isArchived: boolean;
  isDraft: boolean;
  isPaid: boolean;
  isPublic: boolean;
  isRejected: boolean;
  isUnverified: boolean;
  isUnverifiedPending: boolean;
  isVerificationPendingFromDraft: boolean;
  isVerificationPendingFromUnverified: boolean;
  isVerified: boolean;
  logoBackgroundColor: string;
  logoUrl: unknown;
  name: string;
  normalizedShortDescription: string;
  pricingUrl: unknown;
  primaryCategory: IMarketplaceCategory;
  privacyPolicyUrl: unknown;
  resourcePath: unknown;
  screenshotUrls: string[];
  secondaryCategory: IMarketplaceCategory;
  shortDescription: string;
  slug: string;
  statusUrl: unknown;
  supportEmail: string;
  supportUrl: unknown;
  termsOfServiceUrl: unknown;
  url: unknown;
  viewerCanAddPlans: boolean;
  viewerCanApprove: boolean;
  viewerCanDelist: boolean;
  viewerCanEdit: boolean;
  viewerCanEditCategories: boolean;
  viewerCanEditPlans: boolean;
  viewerCanRedraft: boolean;
  viewerCanReject: boolean;
  viewerCanRequestApproval: boolean;
  viewerHasPurchased: boolean;
  viewerHasPurchasedForAllOrganizations: boolean;
  viewerIsListingAdmin: boolean;
}

interface MarketplaceListingSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The GitHub App this listing represents.
   */

  app: <T extends Array<Selection>>(
    select: (t: AppSelector) => T
  ) => Field<"app", never, SelectionSet<T>>;

  /**
   * @description URL to the listing owner's company site.
   */

  companyUrl: () => Field<"companyUrl">;

  /**
   * @description The HTTP path for configuring access to the listing's integration or OAuth app
   */

  configurationResourcePath: () => Field<"configurationResourcePath">;

  /**
   * @description The HTTP URL for configuring access to the listing's integration or OAuth app
   */

  configurationUrl: () => Field<"configurationUrl">;

  /**
   * @description URL to the listing's documentation.
   */

  documentationUrl: () => Field<"documentationUrl">;

  /**
   * @description The listing's detailed description.
   */

  extendedDescription: () => Field<"extendedDescription">;

  /**
   * @description The listing's detailed description rendered to HTML.
   */

  extendedDescriptionHTML: () => Field<"extendedDescriptionHTML">;

  /**
   * @description The listing's introductory description.
   */

  fullDescription: () => Field<"fullDescription">;

  /**
   * @description The listing's introductory description rendered to HTML.
   */

  fullDescriptionHTML: () => Field<"fullDescriptionHTML">;

  /**
   * @description Does this listing have any plans with a free trial?
   */

  hasPublishedFreeTrialPlans: () => Field<"hasPublishedFreeTrialPlans">;

  /**
   * @description Does this listing have a terms of service link?
   */

  hasTermsOfService: () => Field<"hasTermsOfService">;

  /**
   * @description Whether the creator of the app is a verified org
   */

  hasVerifiedOwner: () => Field<"hasVerifiedOwner">;

  /**
   * @description A technical description of how this app works with GitHub.
   */

  howItWorks: () => Field<"howItWorks">;

  /**
   * @description The listing's technical description rendered to HTML.
   */

  howItWorksHTML: () => Field<"howItWorksHTML">;

  id: () => Field<"id">;

  /**
   * @description URL to install the product to the viewer's account or organization.
   */

  installationUrl: () => Field<"installationUrl">;

  /**
   * @description Whether this listing's app has been installed for the current viewer
   */

  installedForViewer: () => Field<"installedForViewer">;

  /**
   * @description Whether this listing has been removed from the Marketplace.
   */

  isArchived: () => Field<"isArchived">;

  /**
     * @description Whether this listing is still an editable draft that has not been submitted
for review and is not publicly visible in the Marketplace.
     */

  isDraft: () => Field<"isDraft">;

  /**
   * @description Whether the product this listing represents is available as part of a paid plan.
   */

  isPaid: () => Field<"isPaid">;

  /**
   * @description Whether this listing has been approved for display in the Marketplace.
   */

  isPublic: () => Field<"isPublic">;

  /**
   * @description Whether this listing has been rejected by GitHub for display in the Marketplace.
   */

  isRejected: () => Field<"isRejected">;

  /**
   * @description Whether this listing has been approved for unverified display in the Marketplace.
   */

  isUnverified: () => Field<"isUnverified">;

  /**
   * @description Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace.
   */

  isUnverifiedPending: () => Field<"isUnverifiedPending">;

  /**
   * @description Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
   */

  isVerificationPendingFromDraft: () => Field<"isVerificationPendingFromDraft">;

  /**
   * @description Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
   */

  isVerificationPendingFromUnverified: () => Field<"isVerificationPendingFromUnverified">;

  /**
   * @description Whether this listing has been approved for verified display in the Marketplace.
   */

  isVerified: () => Field<"isVerified">;

  /**
   * @description The hex color code, without the leading '#', for the logo background.
   */

  logoBackgroundColor: () => Field<"logoBackgroundColor">;

  /**
   * @description URL for the listing's logo image.
   */

  logoUrl: (variables: { size: unknown }) => Field<"logoUrl", [/* @todo */]>;

  /**
   * @description The listing's full name.
   */

  name: () => Field<"name">;

  /**
   * @description The listing's very short description without a trailing period or ampersands.
   */

  normalizedShortDescription: () => Field<"normalizedShortDescription">;

  /**
   * @description URL to the listing's detailed pricing.
   */

  pricingUrl: () => Field<"pricingUrl">;

  /**
   * @description The category that best describes the listing.
   */

  primaryCategory: <T extends Array<Selection>>(
    select: (t: MarketplaceCategorySelector) => T
  ) => Field<"primaryCategory", never, SelectionSet<T>>;

  /**
   * @description URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL.
   */

  privacyPolicyUrl: () => Field<"privacyPolicyUrl">;

  /**
   * @description The HTTP path for the Marketplace listing.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The URLs for the listing's screenshots.
   */

  screenshotUrls: () => Field<"screenshotUrls">;

  /**
   * @description An alternate category that describes the listing.
   */

  secondaryCategory: <T extends Array<Selection>>(
    select: (t: MarketplaceCategorySelector) => T
  ) => Field<"secondaryCategory", never, SelectionSet<T>>;

  /**
   * @description The listing's very short description.
   */

  shortDescription: () => Field<"shortDescription">;

  /**
   * @description The short name of the listing used in its URL.
   */

  slug: () => Field<"slug">;

  /**
   * @description URL to the listing's status page.
   */

  statusUrl: () => Field<"statusUrl">;

  /**
   * @description An email address for support for this listing's app.
   */

  supportEmail: () => Field<"supportEmail">;

  /**
     * @description Either a URL or an email address for support for this listing's app, may
return an empty string for listings that do not require a support URL.
     */

  supportUrl: () => Field<"supportUrl">;

  /**
   * @description URL to the listing's terms of service.
   */

  termsOfServiceUrl: () => Field<"termsOfServiceUrl">;

  /**
   * @description The HTTP URL for the Marketplace listing.
   */

  url: () => Field<"url">;

  /**
   * @description Can the current viewer add plans for this Marketplace listing.
   */

  viewerCanAddPlans: () => Field<"viewerCanAddPlans">;

  /**
   * @description Can the current viewer approve this Marketplace listing.
   */

  viewerCanApprove: () => Field<"viewerCanApprove">;

  /**
   * @description Can the current viewer delist this Marketplace listing.
   */

  viewerCanDelist: () => Field<"viewerCanDelist">;

  /**
   * @description Can the current viewer edit this Marketplace listing.
   */

  viewerCanEdit: () => Field<"viewerCanEdit">;

  /**
     * @description Can the current viewer edit the primary and secondary category of this
Marketplace listing.
     */

  viewerCanEditCategories: () => Field<"viewerCanEditCategories">;

  /**
   * @description Can the current viewer edit the plans for this Marketplace listing.
   */

  viewerCanEditPlans: () => Field<"viewerCanEditPlans">;

  /**
     * @description Can the current viewer return this Marketplace listing to draft state
so it becomes editable again.
     */

  viewerCanRedraft: () => Field<"viewerCanRedraft">;

  /**
     * @description Can the current viewer reject this Marketplace listing by returning it to
an editable draft state or rejecting it entirely.
     */

  viewerCanReject: () => Field<"viewerCanReject">;

  /**
     * @description Can the current viewer request this listing be reviewed for display in
the Marketplace as verified.
     */

  viewerCanRequestApproval: () => Field<"viewerCanRequestApproval">;

  /**
   * @description Indicates whether the current user has an active subscription to this Marketplace listing.
   */

  viewerHasPurchased: () => Field<"viewerHasPurchased">;

  /**
     * @description Indicates if the current user has purchased a subscription to this Marketplace listing
for all of the organizations the user owns.
     */

  viewerHasPurchasedForAllOrganizations: () => Field<"viewerHasPurchasedForAllOrganizations">;

  /**
   * @description Does the current viewer role allow them to administer this Marketplace listing.
   */

  viewerIsListingAdmin: () => Field<"viewerIsListingAdmin">;
}

export const isMarketplaceListing = (
  object: Record<string, any>
): object is Partial<IMarketplaceListing> => {
  return object.__typename === "MarketplaceListing";
};

export const MarketplaceListing: MarketplaceListingSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The GitHub App this listing represents.
   */

  app: (select) =>
    new Field("app", undefined as never, new SelectionSet(select(App))),

  /**
   * @description URL to the listing owner's company site.
   */
  companyUrl: () => new Field("companyUrl"),

  /**
   * @description The HTTP path for configuring access to the listing's integration or OAuth app
   */
  configurationResourcePath: () => new Field("configurationResourcePath"),

  /**
   * @description The HTTP URL for configuring access to the listing's integration or OAuth app
   */
  configurationUrl: () => new Field("configurationUrl"),

  /**
   * @description URL to the listing's documentation.
   */
  documentationUrl: () => new Field("documentationUrl"),

  /**
   * @description The listing's detailed description.
   */
  extendedDescription: () => new Field("extendedDescription"),

  /**
   * @description The listing's detailed description rendered to HTML.
   */
  extendedDescriptionHTML: () => new Field("extendedDescriptionHTML"),

  /**
   * @description The listing's introductory description.
   */
  fullDescription: () => new Field("fullDescription"),

  /**
   * @description The listing's introductory description rendered to HTML.
   */
  fullDescriptionHTML: () => new Field("fullDescriptionHTML"),

  /**
   * @description Does this listing have any plans with a free trial?
   */
  hasPublishedFreeTrialPlans: () => new Field("hasPublishedFreeTrialPlans"),

  /**
   * @description Does this listing have a terms of service link?
   */
  hasTermsOfService: () => new Field("hasTermsOfService"),

  /**
   * @description Whether the creator of the app is a verified org
   */
  hasVerifiedOwner: () => new Field("hasVerifiedOwner"),

  /**
   * @description A technical description of how this app works with GitHub.
   */
  howItWorks: () => new Field("howItWorks"),

  /**
   * @description The listing's technical description rendered to HTML.
   */
  howItWorksHTML: () => new Field("howItWorksHTML"),
  id: () => new Field("id"),

  /**
   * @description URL to install the product to the viewer's account or organization.
   */
  installationUrl: () => new Field("installationUrl"),

  /**
   * @description Whether this listing's app has been installed for the current viewer
   */
  installedForViewer: () => new Field("installedForViewer"),

  /**
   * @description Whether this listing has been removed from the Marketplace.
   */
  isArchived: () => new Field("isArchived"),

  /**
     * @description Whether this listing is still an editable draft that has not been submitted
for review and is not publicly visible in the Marketplace.
     */
  isDraft: () => new Field("isDraft"),

  /**
   * @description Whether the product this listing represents is available as part of a paid plan.
   */
  isPaid: () => new Field("isPaid"),

  /**
   * @description Whether this listing has been approved for display in the Marketplace.
   */
  isPublic: () => new Field("isPublic"),

  /**
   * @description Whether this listing has been rejected by GitHub for display in the Marketplace.
   */
  isRejected: () => new Field("isRejected"),

  /**
   * @description Whether this listing has been approved for unverified display in the Marketplace.
   */
  isUnverified: () => new Field("isUnverified"),

  /**
   * @description Whether this draft listing has been submitted for review for approval to be unverified in the Marketplace.
   */
  isUnverifiedPending: () => new Field("isUnverifiedPending"),

  /**
   * @description Whether this draft listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
   */
  isVerificationPendingFromDraft: () =>
    new Field("isVerificationPendingFromDraft"),

  /**
   * @description Whether this unverified listing has been submitted for review from GitHub for approval to be verified in the Marketplace.
   */
  isVerificationPendingFromUnverified: () =>
    new Field("isVerificationPendingFromUnverified"),

  /**
   * @description Whether this listing has been approved for verified display in the Marketplace.
   */
  isVerified: () => new Field("isVerified"),

  /**
   * @description The hex color code, without the leading '#', for the logo background.
   */
  logoBackgroundColor: () => new Field("logoBackgroundColor"),

  /**
   * @description URL for the listing's logo image.
   */
  logoUrl: (variables) => new Field("logoUrl"),

  /**
   * @description The listing's full name.
   */
  name: () => new Field("name"),

  /**
   * @description The listing's very short description without a trailing period or ampersands.
   */
  normalizedShortDescription: () => new Field("normalizedShortDescription"),

  /**
   * @description URL to the listing's detailed pricing.
   */
  pricingUrl: () => new Field("pricingUrl"),

  /**
   * @description The category that best describes the listing.
   */

  primaryCategory: (select) =>
    new Field(
      "primaryCategory",
      undefined as never,
      new SelectionSet(select(MarketplaceCategory))
    ),

  /**
   * @description URL to the listing's privacy policy, may return an empty string for listings that do not require a privacy policy URL.
   */
  privacyPolicyUrl: () => new Field("privacyPolicyUrl"),

  /**
   * @description The HTTP path for the Marketplace listing.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The URLs for the listing's screenshots.
   */
  screenshotUrls: () => new Field("screenshotUrls"),

  /**
   * @description An alternate category that describes the listing.
   */

  secondaryCategory: (select) =>
    new Field(
      "secondaryCategory",
      undefined as never,
      new SelectionSet(select(MarketplaceCategory))
    ),

  /**
   * @description The listing's very short description.
   */
  shortDescription: () => new Field("shortDescription"),

  /**
   * @description The short name of the listing used in its URL.
   */
  slug: () => new Field("slug"),

  /**
   * @description URL to the listing's status page.
   */
  statusUrl: () => new Field("statusUrl"),

  /**
   * @description An email address for support for this listing's app.
   */
  supportEmail: () => new Field("supportEmail"),

  /**
     * @description Either a URL or an email address for support for this listing's app, may
return an empty string for listings that do not require a support URL.
     */
  supportUrl: () => new Field("supportUrl"),

  /**
   * @description URL to the listing's terms of service.
   */
  termsOfServiceUrl: () => new Field("termsOfServiceUrl"),

  /**
   * @description The HTTP URL for the Marketplace listing.
   */
  url: () => new Field("url"),

  /**
   * @description Can the current viewer add plans for this Marketplace listing.
   */
  viewerCanAddPlans: () => new Field("viewerCanAddPlans"),

  /**
   * @description Can the current viewer approve this Marketplace listing.
   */
  viewerCanApprove: () => new Field("viewerCanApprove"),

  /**
   * @description Can the current viewer delist this Marketplace listing.
   */
  viewerCanDelist: () => new Field("viewerCanDelist"),

  /**
   * @description Can the current viewer edit this Marketplace listing.
   */
  viewerCanEdit: () => new Field("viewerCanEdit"),

  /**
     * @description Can the current viewer edit the primary and secondary category of this
Marketplace listing.
     */
  viewerCanEditCategories: () => new Field("viewerCanEditCategories"),

  /**
   * @description Can the current viewer edit the plans for this Marketplace listing.
   */
  viewerCanEditPlans: () => new Field("viewerCanEditPlans"),

  /**
     * @description Can the current viewer return this Marketplace listing to draft state
so it becomes editable again.
     */
  viewerCanRedraft: () => new Field("viewerCanRedraft"),

  /**
     * @description Can the current viewer reject this Marketplace listing by returning it to
an editable draft state or rejecting it entirely.
     */
  viewerCanReject: () => new Field("viewerCanReject"),

  /**
     * @description Can the current viewer request this listing be reviewed for display in
the Marketplace as verified.
     */
  viewerCanRequestApproval: () => new Field("viewerCanRequestApproval"),

  /**
   * @description Indicates whether the current user has an active subscription to this Marketplace listing.
   */
  viewerHasPurchased: () => new Field("viewerHasPurchased"),

  /**
     * @description Indicates if the current user has purchased a subscription to this Marketplace listing
for all of the organizations the user owns.
     */
  viewerHasPurchasedForAllOrganizations: () =>
    new Field("viewerHasPurchasedForAllOrganizations"),

  /**
   * @description Does the current viewer role allow them to administer this Marketplace listing.
   */
  viewerIsListingAdmin: () => new Field("viewerIsListingAdmin"),
};

export interface IMarketplaceListingConnection {
  edges: IMarketplaceListingEdge[];
  nodes: IMarketplaceListing[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface MarketplaceListingConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: MarketplaceListingEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: MarketplaceListingSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const MarketplaceListingConnection: MarketplaceListingConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(MarketplaceListingEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(MarketplaceListing))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IMarketplaceListingEdge {
  cursor: string;
  node: IMarketplaceListing;
}

interface MarketplaceListingEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: MarketplaceListingSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const MarketplaceListingEdge: MarketplaceListingEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(MarketplaceListing))
    ),
};

export interface IMemberStatusable {
  __typename: string;
  memberStatuses: IUserStatusConnection;
}

interface MemberStatusableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  memberStatuses: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | UserStatusOrder;
    },
    select: (t: UserStatusConnectionSelector) => T
  ) => Field<
    "memberStatuses",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | UserStatusOrder>
    ],
    SelectionSet<T>
  >;

  on: <T extends Array<Selection>, F extends "Organization" | "Team">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "Team"
        ? TeamSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const MemberStatusable: MemberStatusableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  memberStatuses: (variables, select) =>
    new Field(
      "memberStatuses",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(UserStatusConnection))
    ),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IMembersCanDeleteReposClearAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  __typename: "MembersCanDeleteReposClearAuditEntry";
}

interface MembersCanDeleteReposClearAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  enterpriseUrl: () => Field<"enterpriseUrl">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isMembersCanDeleteReposClearAuditEntry = (
  object: Record<string, any>
): object is Partial<IMembersCanDeleteReposClearAuditEntry> => {
  return object.__typename === "MembersCanDeleteReposClearAuditEntry";
};

export const MembersCanDeleteReposClearAuditEntry: MembersCanDeleteReposClearAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IMembersCanDeleteReposDisableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  __typename: "MembersCanDeleteReposDisableAuditEntry";
}

interface MembersCanDeleteReposDisableAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  enterpriseUrl: () => Field<"enterpriseUrl">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isMembersCanDeleteReposDisableAuditEntry = (
  object: Record<string, any>
): object is Partial<IMembersCanDeleteReposDisableAuditEntry> => {
  return object.__typename === "MembersCanDeleteReposDisableAuditEntry";
};

export const MembersCanDeleteReposDisableAuditEntry: MembersCanDeleteReposDisableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IMembersCanDeleteReposEnableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  __typename: "MembersCanDeleteReposEnableAuditEntry";
}

interface MembersCanDeleteReposEnableAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  enterpriseUrl: () => Field<"enterpriseUrl">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isMembersCanDeleteReposEnableAuditEntry = (
  object: Record<string, any>
): object is Partial<IMembersCanDeleteReposEnableAuditEntry> => {
  return object.__typename === "MembersCanDeleteReposEnableAuditEntry";
};

export const MembersCanDeleteReposEnableAuditEntry: MembersCanDeleteReposEnableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IMentionedEvent extends INode {
  __typename: "MentionedEvent";
  actor: IActor;
  createdAt: unknown;
  databaseId: number;
}

interface MentionedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;
}

export const isMentionedEvent = (
  object: Record<string, any>
): object is Partial<IMentionedEvent> => {
  return object.__typename === "MentionedEvent";
};

export const MentionedEvent: MentionedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface IMergeBranchPayload {
  clientMutationId: string;
  mergeCommit: ICommit;
}

interface MergeBranchPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The resulting merge Commit.
   */

  mergeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"mergeCommit", never, SelectionSet<T>>;
}

export const MergeBranchPayload: MergeBranchPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The resulting merge Commit.
   */

  mergeCommit: (select) =>
    new Field(
      "mergeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),
};

export interface IMergePullRequestPayload {
  actor: IActor;
  clientMutationId: string;
  pullRequest: IPullRequest;
}

interface MergePullRequestPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that was merged.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const MergePullRequestPayload: MergePullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that was merged.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IMergedEvent extends INode, IUniformResourceLocatable {
  __typename: "MergedEvent";
  actor: IActor;
  commit: ICommit;
  createdAt: unknown;
  mergeRef: IRef;
  mergeRefName: string;
  pullRequest: IPullRequest;
}

interface MergedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the commit associated with the `merge` event.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Identifies the Ref associated with the `merge` event.
   */

  mergeRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"mergeRef", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the Ref associated with the `merge` event.
   */

  mergeRefName: () => Field<"mergeRefName">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this merged event.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this merged event.
   */

  url: () => Field<"url">;
}

export const isMergedEvent = (
  object: Record<string, any>
): object is Partial<IMergedEvent> => {
  return object.__typename === "MergedEvent";
};

export const MergedEvent: MergedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the commit associated with the `merge` event.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the Ref associated with the `merge` event.
   */

  mergeRef: (select) =>
    new Field("mergeRef", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the name of the Ref associated with the `merge` event.
   */
  mergeRefName: () => new Field("mergeRefName"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this merged event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this merged event.
   */
  url: () => new Field("url"),
};

export interface IMilestone
  extends IClosable,
    INode,
    IUniformResourceLocatable {
  __typename: "Milestone";
  createdAt: unknown;
  creator: IActor;
  description: string;
  dueOn: unknown;
  issues: IIssueConnection;
  number: number;
  progressPercentage: number;
  pullRequests: IPullRequestConnection;
  repository: IRepository;
  state: MilestoneState;
  title: string;
  updatedAt: unknown;
}

interface MilestoneSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */

  closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  closedAt: () => Field<"closedAt">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the actor who created the milestone.
   */

  creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the description of the milestone.
   */

  description: () => Field<"description">;

  /**
   * @description Identifies the due date of the milestone.
   */

  dueOn: () => Field<"dueOn">;

  id: () => Field<"id">;

  /**
   * @description A list of issues associated with the milestone.
   */

  issues: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | IssueFilters;
      first?: Variable<"first"> | number;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | IssueState;
    },
    select: (t: IssueConnectionSelector) => T
  ) => Field<
    "issues",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | IssueFilters>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | IssueState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the number of the milestone.
   */

  number: () => Field<"number">;

  /**
   * @description Indentifies the percentage complete for the milestone
   */

  progressPercentage: () => Field<"progressPercentage">;

  /**
   * @description A list of pull requests associated with the milestone.
   */

  pullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "pullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this milestone.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this milestone
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the state of the milestone.
   */

  state: () => Field<"state">;

  /**
   * @description Identifies the title of the milestone.
   */

  title: () => Field<"title">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this milestone
   */

  url: () => Field<"url">;
}

export const isMilestone = (
  object: Record<string, any>
): object is Partial<IMilestone> => {
  return object.__typename === "Milestone";
};

export const Milestone: MilestoneSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the actor who created the milestone.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the description of the milestone.
   */
  description: () => new Field("description"),

  /**
   * @description Identifies the due date of the milestone.
   */
  dueOn: () => new Field("dueOn"),
  id: () => new Field("id"),

  /**
   * @description A list of issues associated with the milestone.
   */

  issues: (variables, select) =>
    new Field(
      "issues",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, IssueState),
      ],
      new SelectionSet(select(IssueConnection))
    ),

  /**
   * @description Identifies the number of the milestone.
   */
  number: () => new Field("number"),

  /**
   * @description Indentifies the percentage complete for the milestone
   */
  progressPercentage: () => new Field("progressPercentage"),

  /**
   * @description A list of pull requests associated with the milestone.
   */

  pullRequests: (variables, select) =>
    new Field(
      "pullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description The repository associated with this milestone.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this milestone
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the state of the milestone.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies the title of the milestone.
   */
  title: () => new Field("title"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this milestone
   */
  url: () => new Field("url"),
};

export interface IMilestoneConnection {
  edges: IMilestoneEdge[];
  nodes: IMilestone[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface MilestoneConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: MilestoneEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: MilestoneSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const MilestoneConnection: MilestoneConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(MilestoneEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Milestone))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IMilestoneEdge {
  cursor: string;
  node: IMilestone;
}

interface MilestoneEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: MilestoneSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const MilestoneEdge: MilestoneEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Milestone))),
};

export interface IMilestonedEvent extends INode {
  __typename: "MilestonedEvent";
  actor: IActor;
  createdAt: unknown;
  milestoneTitle: string;
  subject: IMilestoneItem;
}

interface MilestonedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Identifies the milestone title associated with the 'milestoned' event.
   */

  milestoneTitle: () => Field<"milestoneTitle">;

  /**
   * @description Object referenced by event.
   */

  subject: <T extends Array<Selection>>(
    select: (t: MilestoneItemSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isMilestonedEvent = (
  object: Record<string, any>
): object is Partial<IMilestonedEvent> => {
  return object.__typename === "MilestonedEvent";
};

export const MilestonedEvent: MilestonedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the milestone title associated with the 'milestoned' event.
   */
  milestoneTitle: () => new Field("milestoneTitle"),

  /**
   * @description Object referenced by event.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(MilestoneItem))
    ),
};

export interface IMinimizable {
  __typename: string;
  isMinimized: boolean;
  minimizedReason: string;
  viewerCanMinimize: boolean;
}

interface MinimizableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  isMinimized: () => Field<"isMinimized">;

  /**
   * @description Returns why the comment was minimized.
   */

  minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  viewerCanMinimize: () => Field<"viewerCanMinimize">;

  on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "IssueComment"
      | "PullRequestReviewComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Minimizable: MinimizableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IMinimizeCommentPayload {
  clientMutationId: string;
  minimizedComment: IMinimizable;
}

interface MinimizeCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The comment that was minimized.
   */

  minimizedComment: <T extends Array<Selection>>(
    select: (t: MinimizableSelector) => T
  ) => Field<"minimizedComment", never, SelectionSet<T>>;
}

export const MinimizeCommentPayload: MinimizeCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The comment that was minimized.
   */

  minimizedComment: (select) =>
    new Field(
      "minimizedComment",
      undefined as never,
      new SelectionSet(select(Minimizable))
    ),
};

export interface IMoveProjectCardPayload {
  cardEdge: IProjectCardEdge;
  clientMutationId: string;
}

interface MoveProjectCardPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The new edge of the moved card.
   */

  cardEdge: <T extends Array<Selection>>(
    select: (t: ProjectCardEdgeSelector) => T
  ) => Field<"cardEdge", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const MoveProjectCardPayload: MoveProjectCardPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The new edge of the moved card.
   */

  cardEdge: (select) =>
    new Field(
      "cardEdge",
      undefined as never,
      new SelectionSet(select(ProjectCardEdge))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IMoveProjectColumnPayload {
  clientMutationId: string;
  columnEdge: IProjectColumnEdge;
}

interface MoveProjectColumnPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The new edge of the moved column.
   */

  columnEdge: <T extends Array<Selection>>(
    select: (t: ProjectColumnEdgeSelector) => T
  ) => Field<"columnEdge", never, SelectionSet<T>>;
}

export const MoveProjectColumnPayload: MoveProjectColumnPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The new edge of the moved column.
   */

  columnEdge: (select) =>
    new Field(
      "columnEdge",
      undefined as never,
      new SelectionSet(select(ProjectColumnEdge))
    ),
};

export interface IMovedColumnsInProjectEvent extends INode {
  __typename: "MovedColumnsInProjectEvent";
  actor: IActor;
  createdAt: unknown;
  databaseId: number;
}

interface MovedColumnsInProjectEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;
}

export const isMovedColumnsInProjectEvent = (
  object: Record<string, any>
): object is Partial<IMovedColumnsInProjectEvent> => {
  return object.__typename === "MovedColumnsInProjectEvent";
};

export const MovedColumnsInProjectEvent: MovedColumnsInProjectEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface IMutation {
  acceptEnterpriseAdministratorInvitation: IAcceptEnterpriseAdministratorInvitationPayload;
  acceptTopicSuggestion: IAcceptTopicSuggestionPayload;
  addAssigneesToAssignable: IAddAssigneesToAssignablePayload;
  addComment: IAddCommentPayload;
  addLabelsToLabelable: IAddLabelsToLabelablePayload;
  addProjectCard: IAddProjectCardPayload;
  addProjectColumn: IAddProjectColumnPayload;
  addPullRequestReview: IAddPullRequestReviewPayload;
  addPullRequestReviewComment: IAddPullRequestReviewCommentPayload;
  addPullRequestReviewThread: IAddPullRequestReviewThreadPayload;
  addReaction: IAddReactionPayload;
  addStar: IAddStarPayload;
  archiveRepository: IArchiveRepositoryPayload;
  cancelEnterpriseAdminInvitation: ICancelEnterpriseAdminInvitationPayload;
  changeUserStatus: IChangeUserStatusPayload;
  clearLabelsFromLabelable: IClearLabelsFromLabelablePayload;
  cloneProject: ICloneProjectPayload;
  cloneTemplateRepository: ICloneTemplateRepositoryPayload;
  closeIssue: ICloseIssuePayload;
  closePullRequest: IClosePullRequestPayload;
  convertProjectCardNoteToIssue: IConvertProjectCardNoteToIssuePayload;
  createBranchProtectionRule: ICreateBranchProtectionRulePayload;
  createCheckRun: ICreateCheckRunPayload;
  createCheckSuite: ICreateCheckSuitePayload;
  createEnterpriseOrganization: ICreateEnterpriseOrganizationPayload;
  createIpAllowListEntry: ICreateIpAllowListEntryPayload;
  createIssue: ICreateIssuePayload;
  createProject: ICreateProjectPayload;
  createPullRequest: ICreatePullRequestPayload;
  createRef: ICreateRefPayload;
  createRepository: ICreateRepositoryPayload;
  createTeamDiscussion: ICreateTeamDiscussionPayload;
  createTeamDiscussionComment: ICreateTeamDiscussionCommentPayload;
  declineTopicSuggestion: IDeclineTopicSuggestionPayload;
  deleteBranchProtectionRule: IDeleteBranchProtectionRulePayload;
  deleteDeployment: IDeleteDeploymentPayload;
  deleteIpAllowListEntry: IDeleteIpAllowListEntryPayload;
  deleteIssue: IDeleteIssuePayload;
  deleteIssueComment: IDeleteIssueCommentPayload;
  deleteProject: IDeleteProjectPayload;
  deleteProjectCard: IDeleteProjectCardPayload;
  deleteProjectColumn: IDeleteProjectColumnPayload;
  deletePullRequestReview: IDeletePullRequestReviewPayload;
  deletePullRequestReviewComment: IDeletePullRequestReviewCommentPayload;
  deleteRef: IDeleteRefPayload;
  deleteTeamDiscussion: IDeleteTeamDiscussionPayload;
  deleteTeamDiscussionComment: IDeleteTeamDiscussionCommentPayload;
  dismissPullRequestReview: IDismissPullRequestReviewPayload;
  followUser: IFollowUserPayload;
  inviteEnterpriseAdmin: IInviteEnterpriseAdminPayload;
  linkRepositoryToProject: ILinkRepositoryToProjectPayload;
  lockLockable: ILockLockablePayload;
  markFileAsViewed: IMarkFileAsViewedPayload;
  markPullRequestReadyForReview: IMarkPullRequestReadyForReviewPayload;
  mergeBranch: IMergeBranchPayload;
  mergePullRequest: IMergePullRequestPayload;
  minimizeComment: IMinimizeCommentPayload;
  moveProjectCard: IMoveProjectCardPayload;
  moveProjectColumn: IMoveProjectColumnPayload;
  regenerateEnterpriseIdentityProviderRecoveryCodes: IRegenerateEnterpriseIdentityProviderRecoveryCodesPayload;
  removeAssigneesFromAssignable: IRemoveAssigneesFromAssignablePayload;
  removeEnterpriseAdmin: IRemoveEnterpriseAdminPayload;
  removeEnterpriseIdentityProvider: IRemoveEnterpriseIdentityProviderPayload;
  removeEnterpriseOrganization: IRemoveEnterpriseOrganizationPayload;
  removeLabelsFromLabelable: IRemoveLabelsFromLabelablePayload;
  removeOutsideCollaborator: IRemoveOutsideCollaboratorPayload;
  removeReaction: IRemoveReactionPayload;
  removeStar: IRemoveStarPayload;
  reopenIssue: IReopenIssuePayload;
  reopenPullRequest: IReopenPullRequestPayload;
  requestReviews: IRequestReviewsPayload;
  rerequestCheckSuite: IRerequestCheckSuitePayload;
  resolveReviewThread: IResolveReviewThreadPayload;
  setEnterpriseIdentityProvider: ISetEnterpriseIdentityProviderPayload;
  setOrganizationInteractionLimit: ISetOrganizationInteractionLimitPayload;
  setRepositoryInteractionLimit: ISetRepositoryInteractionLimitPayload;
  setUserInteractionLimit: ISetUserInteractionLimitPayload;
  submitPullRequestReview: ISubmitPullRequestReviewPayload;
  transferIssue: ITransferIssuePayload;
  unarchiveRepository: IUnarchiveRepositoryPayload;
  unfollowUser: IUnfollowUserPayload;
  unlinkRepositoryFromProject: IUnlinkRepositoryFromProjectPayload;
  unlockLockable: IUnlockLockablePayload;
  unmarkFileAsViewed: IUnmarkFileAsViewedPayload;
  unmarkIssueAsDuplicate: IUnmarkIssueAsDuplicatePayload;
  unminimizeComment: IUnminimizeCommentPayload;
  unresolveReviewThread: IUnresolveReviewThreadPayload;
  updateBranchProtectionRule: IUpdateBranchProtectionRulePayload;
  updateCheckRun: IUpdateCheckRunPayload;
  updateCheckSuitePreferences: IUpdateCheckSuitePreferencesPayload;
  updateEnterpriseAdministratorRole: IUpdateEnterpriseAdministratorRolePayload;
  updateEnterpriseAllowPrivateRepositoryForkingSetting: IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload;
  updateEnterpriseDefaultRepositoryPermissionSetting: IUpdateEnterpriseDefaultRepositoryPermissionSettingPayload;
  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting: IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload;
  updateEnterpriseMembersCanCreateRepositoriesSetting: IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload;
  updateEnterpriseMembersCanDeleteIssuesSetting: IUpdateEnterpriseMembersCanDeleteIssuesSettingPayload;
  updateEnterpriseMembersCanDeleteRepositoriesSetting: IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload;
  updateEnterpriseMembersCanInviteCollaboratorsSetting: IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload;
  updateEnterpriseMembersCanMakePurchasesSetting: IUpdateEnterpriseMembersCanMakePurchasesSettingPayload;
  updateEnterpriseMembersCanUpdateProtectedBranchesSetting: IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload;
  updateEnterpriseMembersCanViewDependencyInsightsSetting: IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload;
  updateEnterpriseOrganizationProjectsSetting: IUpdateEnterpriseOrganizationProjectsSettingPayload;
  updateEnterpriseProfile: IUpdateEnterpriseProfilePayload;
  updateEnterpriseRepositoryProjectsSetting: IUpdateEnterpriseRepositoryProjectsSettingPayload;
  updateEnterpriseTeamDiscussionsSetting: IUpdateEnterpriseTeamDiscussionsSettingPayload;
  updateEnterpriseTwoFactorAuthenticationRequiredSetting: IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload;
  updateIpAllowListEnabledSetting: IUpdateIpAllowListEnabledSettingPayload;
  updateIpAllowListEntry: IUpdateIpAllowListEntryPayload;
  updateIssue: IUpdateIssuePayload;
  updateIssueComment: IUpdateIssueCommentPayload;
  updateProject: IUpdateProjectPayload;
  updateProjectCard: IUpdateProjectCardPayload;
  updateProjectColumn: IUpdateProjectColumnPayload;
  updatePullRequest: IUpdatePullRequestPayload;
  updatePullRequestReview: IUpdatePullRequestReviewPayload;
  updatePullRequestReviewComment: IUpdatePullRequestReviewCommentPayload;
  updateRef: IUpdateRefPayload;
  updateRepository: IUpdateRepositoryPayload;
  updateSubscription: IUpdateSubscriptionPayload;
  updateTeamDiscussion: IUpdateTeamDiscussionPayload;
  updateTeamDiscussionComment: IUpdateTeamDiscussionCommentPayload;
  updateTopics: IUpdateTopicsPayload;
}

interface MutationSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Accepts a pending invitation for a user to become an administrator of an enterprise.
   */

  acceptEnterpriseAdministratorInvitation: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | AcceptEnterpriseAdministratorInvitationInput;
    },
    select: (t: AcceptEnterpriseAdministratorInvitationPayloadSelector) => T
  ) => Field<
    "acceptEnterpriseAdministratorInvitation",
    [
      Argument<
        "input",
        Variable<"input"> | AcceptEnterpriseAdministratorInvitationInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Applies a suggested topic to the repository.
   */

  acceptTopicSuggestion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AcceptTopicSuggestionInput },
    select: (t: AcceptTopicSuggestionPayloadSelector) => T
  ) => Field<
    "acceptTopicSuggestion",
    [Argument<"input", Variable<"input"> | AcceptTopicSuggestionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds assignees to an assignable object.
   */

  addAssigneesToAssignable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddAssigneesToAssignableInput },
    select: (t: AddAssigneesToAssignablePayloadSelector) => T
  ) => Field<
    "addAssigneesToAssignable",
    [Argument<"input", Variable<"input"> | AddAssigneesToAssignableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a comment to an Issue or Pull Request.
   */

  addComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddCommentInput },
    select: (t: AddCommentPayloadSelector) => T
  ) => Field<
    "addComment",
    [Argument<"input", Variable<"input"> | AddCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds labels to a labelable object.
   */

  addLabelsToLabelable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddLabelsToLabelableInput },
    select: (t: AddLabelsToLabelablePayloadSelector) => T
  ) => Field<
    "addLabelsToLabelable",
    [Argument<"input", Variable<"input"> | AddLabelsToLabelableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both.
   */

  addProjectCard: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddProjectCardInput },
    select: (t: AddProjectCardPayloadSelector) => T
  ) => Field<
    "addProjectCard",
    [Argument<"input", Variable<"input"> | AddProjectCardInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a column to a Project.
   */

  addProjectColumn: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddProjectColumnInput },
    select: (t: AddProjectColumnPayloadSelector) => T
  ) => Field<
    "addProjectColumn",
    [Argument<"input", Variable<"input"> | AddProjectColumnInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a review to a Pull Request.
   */

  addPullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddPullRequestReviewInput },
    select: (t: AddPullRequestReviewPayloadSelector) => T
  ) => Field<
    "addPullRequestReview",
    [Argument<"input", Variable<"input"> | AddPullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a comment to a review.
   */

  addPullRequestReviewComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddPullRequestReviewCommentInput },
    select: (t: AddPullRequestReviewCommentPayloadSelector) => T
  ) => Field<
    "addPullRequestReviewComment",
    [Argument<"input", Variable<"input"> | AddPullRequestReviewCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a new thread to a pending Pull Request Review.
   */

  addPullRequestReviewThread: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddPullRequestReviewThreadInput },
    select: (t: AddPullRequestReviewThreadPayloadSelector) => T
  ) => Field<
    "addPullRequestReviewThread",
    [Argument<"input", Variable<"input"> | AddPullRequestReviewThreadInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a reaction to a subject.
   */

  addReaction: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddReactionInput },
    select: (t: AddReactionPayloadSelector) => T
  ) => Field<
    "addReaction",
    [Argument<"input", Variable<"input"> | AddReactionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Adds a star to a Starrable.
   */

  addStar: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | AddStarInput },
    select: (t: AddStarPayloadSelector) => T
  ) => Field<
    "addStar",
    [Argument<"input", Variable<"input"> | AddStarInput>],
    SelectionSet<T>
  >;

  /**
   * @description Marks a repository as archived.
   */

  archiveRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ArchiveRepositoryInput },
    select: (t: ArchiveRepositoryPayloadSelector) => T
  ) => Field<
    "archiveRepository",
    [Argument<"input", Variable<"input"> | ArchiveRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Cancels a pending invitation for an administrator to join an enterprise.
   */

  cancelEnterpriseAdminInvitation: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | CancelEnterpriseAdminInvitationInput;
    },
    select: (t: CancelEnterpriseAdminInvitationPayloadSelector) => T
  ) => Field<
    "cancelEnterpriseAdminInvitation",
    [
      Argument<
        "input",
        Variable<"input"> | CancelEnterpriseAdminInvitationInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Update your status on GitHub.
   */

  changeUserStatus: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ChangeUserStatusInput },
    select: (t: ChangeUserStatusPayloadSelector) => T
  ) => Field<
    "changeUserStatus",
    [Argument<"input", Variable<"input"> | ChangeUserStatusInput>],
    SelectionSet<T>
  >;

  /**
   * @description Clears all labels from a labelable object.
   */

  clearLabelsFromLabelable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ClearLabelsFromLabelableInput },
    select: (t: ClearLabelsFromLabelablePayloadSelector) => T
  ) => Field<
    "clearLabelsFromLabelable",
    [Argument<"input", Variable<"input"> | ClearLabelsFromLabelableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new project by cloning configuration from an existing project.
   */

  cloneProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CloneProjectInput },
    select: (t: CloneProjectPayloadSelector) => T
  ) => Field<
    "cloneProject",
    [Argument<"input", Variable<"input"> | CloneProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new repository with the same files and directory structure as a template repository.
   */

  cloneTemplateRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CloneTemplateRepositoryInput },
    select: (t: CloneTemplateRepositoryPayloadSelector) => T
  ) => Field<
    "cloneTemplateRepository",
    [Argument<"input", Variable<"input"> | CloneTemplateRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Close an issue.
   */

  closeIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CloseIssueInput },
    select: (t: CloseIssuePayloadSelector) => T
  ) => Field<
    "closeIssue",
    [Argument<"input", Variable<"input"> | CloseIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Close a pull request.
   */

  closePullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ClosePullRequestInput },
    select: (t: ClosePullRequestPayloadSelector) => T
  ) => Field<
    "closePullRequest",
    [Argument<"input", Variable<"input"> | ClosePullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Convert a project note card to one associated with a newly created issue.
   */

  convertProjectCardNoteToIssue: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | ConvertProjectCardNoteToIssueInput;
    },
    select: (t: ConvertProjectCardNoteToIssuePayloadSelector) => T
  ) => Field<
    "convertProjectCardNoteToIssue",
    [Argument<"input", Variable<"input"> | ConvertProjectCardNoteToIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new branch protection rule
   */

  createBranchProtectionRule: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateBranchProtectionRuleInput },
    select: (t: CreateBranchProtectionRulePayloadSelector) => T
  ) => Field<
    "createBranchProtectionRule",
    [Argument<"input", Variable<"input"> | CreateBranchProtectionRuleInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a check run.
   */

  createCheckRun: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateCheckRunInput },
    select: (t: CreateCheckRunPayloadSelector) => T
  ) => Field<
    "createCheckRun",
    [Argument<"input", Variable<"input"> | CreateCheckRunInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a check suite
   */

  createCheckSuite: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateCheckSuiteInput },
    select: (t: CreateCheckSuitePayloadSelector) => T
  ) => Field<
    "createCheckSuite",
    [Argument<"input", Variable<"input"> | CreateCheckSuiteInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates an organization as part of an enterprise account.
   */

  createEnterpriseOrganization: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | CreateEnterpriseOrganizationInput;
    },
    select: (t: CreateEnterpriseOrganizationPayloadSelector) => T
  ) => Field<
    "createEnterpriseOrganization",
    [Argument<"input", Variable<"input"> | CreateEnterpriseOrganizationInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new IP allow list entry.
   */

  createIpAllowListEntry: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateIpAllowListEntryInput },
    select: (t: CreateIpAllowListEntryPayloadSelector) => T
  ) => Field<
    "createIpAllowListEntry",
    [Argument<"input", Variable<"input"> | CreateIpAllowListEntryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new issue.
   */

  createIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateIssueInput },
    select: (t: CreateIssuePayloadSelector) => T
  ) => Field<
    "createIssue",
    [Argument<"input", Variable<"input"> | CreateIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new project.
   */

  createProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateProjectInput },
    select: (t: CreateProjectPayloadSelector) => T
  ) => Field<
    "createProject",
    [Argument<"input", Variable<"input"> | CreateProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new pull request
   */

  createPullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreatePullRequestInput },
    select: (t: CreatePullRequestPayloadSelector) => T
  ) => Field<
    "createPullRequest",
    [Argument<"input", Variable<"input"> | CreatePullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new Git Ref.
   */

  createRef: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateRefInput },
    select: (t: CreateRefPayloadSelector) => T
  ) => Field<
    "createRef",
    [Argument<"input", Variable<"input"> | CreateRefInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new repository.
   */

  createRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateRepositoryInput },
    select: (t: CreateRepositoryPayloadSelector) => T
  ) => Field<
    "createRepository",
    [Argument<"input", Variable<"input"> | CreateRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new team discussion.
   */

  createTeamDiscussion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateTeamDiscussionInput },
    select: (t: CreateTeamDiscussionPayloadSelector) => T
  ) => Field<
    "createTeamDiscussion",
    [Argument<"input", Variable<"input"> | CreateTeamDiscussionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a new team discussion comment.
   */

  createTeamDiscussionComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | CreateTeamDiscussionCommentInput },
    select: (t: CreateTeamDiscussionCommentPayloadSelector) => T
  ) => Field<
    "createTeamDiscussionComment",
    [Argument<"input", Variable<"input"> | CreateTeamDiscussionCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Rejects a suggested topic for the repository.
   */

  declineTopicSuggestion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeclineTopicSuggestionInput },
    select: (t: DeclineTopicSuggestionPayloadSelector) => T
  ) => Field<
    "declineTopicSuggestion",
    [Argument<"input", Variable<"input"> | DeclineTopicSuggestionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Delete a branch protection rule
   */

  deleteBranchProtectionRule: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteBranchProtectionRuleInput },
    select: (t: DeleteBranchProtectionRulePayloadSelector) => T
  ) => Field<
    "deleteBranchProtectionRule",
    [Argument<"input", Variable<"input"> | DeleteBranchProtectionRuleInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a deployment.
   */

  deleteDeployment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteDeploymentInput },
    select: (t: DeleteDeploymentPayloadSelector) => T
  ) => Field<
    "deleteDeployment",
    [Argument<"input", Variable<"input"> | DeleteDeploymentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes an IP allow list entry.
   */

  deleteIpAllowListEntry: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteIpAllowListEntryInput },
    select: (t: DeleteIpAllowListEntryPayloadSelector) => T
  ) => Field<
    "deleteIpAllowListEntry",
    [Argument<"input", Variable<"input"> | DeleteIpAllowListEntryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes an Issue object.
   */

  deleteIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteIssueInput },
    select: (t: DeleteIssuePayloadSelector) => T
  ) => Field<
    "deleteIssue",
    [Argument<"input", Variable<"input"> | DeleteIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes an IssueComment object.
   */

  deleteIssueComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteIssueCommentInput },
    select: (t: DeleteIssueCommentPayloadSelector) => T
  ) => Field<
    "deleteIssueComment",
    [Argument<"input", Variable<"input"> | DeleteIssueCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a project.
   */

  deleteProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteProjectInput },
    select: (t: DeleteProjectPayloadSelector) => T
  ) => Field<
    "deleteProject",
    [Argument<"input", Variable<"input"> | DeleteProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a project card.
   */

  deleteProjectCard: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteProjectCardInput },
    select: (t: DeleteProjectCardPayloadSelector) => T
  ) => Field<
    "deleteProjectCard",
    [Argument<"input", Variable<"input"> | DeleteProjectCardInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a project column.
   */

  deleteProjectColumn: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteProjectColumnInput },
    select: (t: DeleteProjectColumnPayloadSelector) => T
  ) => Field<
    "deleteProjectColumn",
    [Argument<"input", Variable<"input"> | DeleteProjectColumnInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a pull request review.
   */

  deletePullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeletePullRequestReviewInput },
    select: (t: DeletePullRequestReviewPayloadSelector) => T
  ) => Field<
    "deletePullRequestReview",
    [Argument<"input", Variable<"input"> | DeletePullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a pull request review comment.
   */

  deletePullRequestReviewComment: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | DeletePullRequestReviewCommentInput;
    },
    select: (t: DeletePullRequestReviewCommentPayloadSelector) => T
  ) => Field<
    "deletePullRequestReviewComment",
    [
      Argument<"input", Variable<"input"> | DeletePullRequestReviewCommentInput>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Delete a Git Ref.
   */

  deleteRef: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteRefInput },
    select: (t: DeleteRefPayloadSelector) => T
  ) => Field<
    "deleteRef",
    [Argument<"input", Variable<"input"> | DeleteRefInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a team discussion.
   */

  deleteTeamDiscussion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteTeamDiscussionInput },
    select: (t: DeleteTeamDiscussionPayloadSelector) => T
  ) => Field<
    "deleteTeamDiscussion",
    [Argument<"input", Variable<"input"> | DeleteTeamDiscussionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a team discussion comment.
   */

  deleteTeamDiscussionComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DeleteTeamDiscussionCommentInput },
    select: (t: DeleteTeamDiscussionCommentPayloadSelector) => T
  ) => Field<
    "deleteTeamDiscussionComment",
    [Argument<"input", Variable<"input"> | DeleteTeamDiscussionCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Dismisses an approved or rejected pull request review.
   */

  dismissPullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | DismissPullRequestReviewInput },
    select: (t: DismissPullRequestReviewPayloadSelector) => T
  ) => Field<
    "dismissPullRequestReview",
    [Argument<"input", Variable<"input"> | DismissPullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Follow a user.
   */

  followUser: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | FollowUserInput },
    select: (t: FollowUserPayloadSelector) => T
  ) => Field<
    "followUser",
    [Argument<"input", Variable<"input"> | FollowUserInput>],
    SelectionSet<T>
  >;

  /**
   * @description Invite someone to become an administrator of the enterprise.
   */

  inviteEnterpriseAdmin: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | InviteEnterpriseAdminInput },
    select: (t: InviteEnterpriseAdminPayloadSelector) => T
  ) => Field<
    "inviteEnterpriseAdmin",
    [Argument<"input", Variable<"input"> | InviteEnterpriseAdminInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates a repository link for a project.
   */

  linkRepositoryToProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | LinkRepositoryToProjectInput },
    select: (t: LinkRepositoryToProjectPayloadSelector) => T
  ) => Field<
    "linkRepositoryToProject",
    [Argument<"input", Variable<"input"> | LinkRepositoryToProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Lock a lockable object
   */

  lockLockable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | LockLockableInput },
    select: (t: LockLockablePayloadSelector) => T
  ) => Field<
    "lockLockable",
    [Argument<"input", Variable<"input"> | LockLockableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Mark a pull request file as viewed
   */

  markFileAsViewed: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MarkFileAsViewedInput },
    select: (t: MarkFileAsViewedPayloadSelector) => T
  ) => Field<
    "markFileAsViewed",
    [Argument<"input", Variable<"input"> | MarkFileAsViewedInput>],
    SelectionSet<T>
  >;

  /**
   * @description Marks a pull request ready for review.
   */

  markPullRequestReadyForReview: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | MarkPullRequestReadyForReviewInput;
    },
    select: (t: MarkPullRequestReadyForReviewPayloadSelector) => T
  ) => Field<
    "markPullRequestReadyForReview",
    [Argument<"input", Variable<"input"> | MarkPullRequestReadyForReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Merge a head into a branch.
   */

  mergeBranch: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MergeBranchInput },
    select: (t: MergeBranchPayloadSelector) => T
  ) => Field<
    "mergeBranch",
    [Argument<"input", Variable<"input"> | MergeBranchInput>],
    SelectionSet<T>
  >;

  /**
   * @description Merge a pull request.
   */

  mergePullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MergePullRequestInput },
    select: (t: MergePullRequestPayloadSelector) => T
  ) => Field<
    "mergePullRequest",
    [Argument<"input", Variable<"input"> | MergePullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Minimizes a comment on an Issue, Commit, Pull Request, or Gist
   */

  minimizeComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MinimizeCommentInput },
    select: (t: MinimizeCommentPayloadSelector) => T
  ) => Field<
    "minimizeComment",
    [Argument<"input", Variable<"input"> | MinimizeCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Moves a project card to another place.
   */

  moveProjectCard: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MoveProjectCardInput },
    select: (t: MoveProjectCardPayloadSelector) => T
  ) => Field<
    "moveProjectCard",
    [Argument<"input", Variable<"input"> | MoveProjectCardInput>],
    SelectionSet<T>
  >;

  /**
   * @description Moves a project column to another place.
   */

  moveProjectColumn: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | MoveProjectColumnInput },
    select: (t: MoveProjectColumnPayloadSelector) => T
  ) => Field<
    "moveProjectColumn",
    [Argument<"input", Variable<"input"> | MoveProjectColumnInput>],
    SelectionSet<T>
  >;

  /**
   * @description Regenerates the identity provider recovery codes for an enterprise
   */

  regenerateEnterpriseIdentityProviderRecoveryCodes: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | RegenerateEnterpriseIdentityProviderRecoveryCodesInput;
    },
    select: (
      t: RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadSelector
    ) => T
  ) => Field<
    "regenerateEnterpriseIdentityProviderRecoveryCodes",
    [
      Argument<
        "input",
        | Variable<"input">
        | RegenerateEnterpriseIdentityProviderRecoveryCodesInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Removes assignees from an assignable object.
   */

  removeAssigneesFromAssignable: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | RemoveAssigneesFromAssignableInput;
    },
    select: (t: RemoveAssigneesFromAssignablePayloadSelector) => T
  ) => Field<
    "removeAssigneesFromAssignable",
    [Argument<"input", Variable<"input"> | RemoveAssigneesFromAssignableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes an administrator from the enterprise.
   */

  removeEnterpriseAdmin: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveEnterpriseAdminInput },
    select: (t: RemoveEnterpriseAdminPayloadSelector) => T
  ) => Field<
    "removeEnterpriseAdmin",
    [Argument<"input", Variable<"input"> | RemoveEnterpriseAdminInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes the identity provider from an enterprise
   */

  removeEnterpriseIdentityProvider: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | RemoveEnterpriseIdentityProviderInput;
    },
    select: (t: RemoveEnterpriseIdentityProviderPayloadSelector) => T
  ) => Field<
    "removeEnterpriseIdentityProvider",
    [
      Argument<
        "input",
        Variable<"input"> | RemoveEnterpriseIdentityProviderInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Removes an organization from the enterprise
   */

  removeEnterpriseOrganization: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | RemoveEnterpriseOrganizationInput;
    },
    select: (t: RemoveEnterpriseOrganizationPayloadSelector) => T
  ) => Field<
    "removeEnterpriseOrganization",
    [Argument<"input", Variable<"input"> | RemoveEnterpriseOrganizationInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes labels from a Labelable object.
   */

  removeLabelsFromLabelable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveLabelsFromLabelableInput },
    select: (t: RemoveLabelsFromLabelablePayloadSelector) => T
  ) => Field<
    "removeLabelsFromLabelable",
    [Argument<"input", Variable<"input"> | RemoveLabelsFromLabelableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes outside collaborator from all repositories in an organization.
   */

  removeOutsideCollaborator: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveOutsideCollaboratorInput },
    select: (t: RemoveOutsideCollaboratorPayloadSelector) => T
  ) => Field<
    "removeOutsideCollaborator",
    [Argument<"input", Variable<"input"> | RemoveOutsideCollaboratorInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes a reaction from a subject.
   */

  removeReaction: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveReactionInput },
    select: (t: RemoveReactionPayloadSelector) => T
  ) => Field<
    "removeReaction",
    [Argument<"input", Variable<"input"> | RemoveReactionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Removes a star from a Starrable.
   */

  removeStar: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RemoveStarInput },
    select: (t: RemoveStarPayloadSelector) => T
  ) => Field<
    "removeStar",
    [Argument<"input", Variable<"input"> | RemoveStarInput>],
    SelectionSet<T>
  >;

  /**
   * @description Reopen a issue.
   */

  reopenIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ReopenIssueInput },
    select: (t: ReopenIssuePayloadSelector) => T
  ) => Field<
    "reopenIssue",
    [Argument<"input", Variable<"input"> | ReopenIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Reopen a pull request.
   */

  reopenPullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ReopenPullRequestInput },
    select: (t: ReopenPullRequestPayloadSelector) => T
  ) => Field<
    "reopenPullRequest",
    [Argument<"input", Variable<"input"> | ReopenPullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Set review requests on a pull request.
   */

  requestReviews: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RequestReviewsInput },
    select: (t: RequestReviewsPayloadSelector) => T
  ) => Field<
    "requestReviews",
    [Argument<"input", Variable<"input"> | RequestReviewsInput>],
    SelectionSet<T>
  >;

  /**
   * @description Rerequests an existing check suite.
   */

  rerequestCheckSuite: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | RerequestCheckSuiteInput },
    select: (t: RerequestCheckSuitePayloadSelector) => T
  ) => Field<
    "rerequestCheckSuite",
    [Argument<"input", Variable<"input"> | RerequestCheckSuiteInput>],
    SelectionSet<T>
  >;

  /**
   * @description Marks a review thread as resolved.
   */

  resolveReviewThread: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | ResolveReviewThreadInput },
    select: (t: ResolveReviewThreadPayloadSelector) => T
  ) => Field<
    "resolveReviewThread",
    [Argument<"input", Variable<"input"> | ResolveReviewThreadInput>],
    SelectionSet<T>
  >;

  /**
   * @description Creates or updates the identity provider for an enterprise.
   */

  setEnterpriseIdentityProvider: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | SetEnterpriseIdentityProviderInput;
    },
    select: (t: SetEnterpriseIdentityProviderPayloadSelector) => T
  ) => Field<
    "setEnterpriseIdentityProvider",
    [Argument<"input", Variable<"input"> | SetEnterpriseIdentityProviderInput>],
    SelectionSet<T>
  >;

  /**
   * @description Set an organization level interaction limit for an organization's public repositories.
   */

  setOrganizationInteractionLimit: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | SetOrganizationInteractionLimitInput;
    },
    select: (t: SetOrganizationInteractionLimitPayloadSelector) => T
  ) => Field<
    "setOrganizationInteractionLimit",
    [
      Argument<
        "input",
        Variable<"input"> | SetOrganizationInteractionLimitInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets an interaction limit setting for a repository.
   */

  setRepositoryInteractionLimit: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | SetRepositoryInteractionLimitInput;
    },
    select: (t: SetRepositoryInteractionLimitPayloadSelector) => T
  ) => Field<
    "setRepositoryInteractionLimit",
    [Argument<"input", Variable<"input"> | SetRepositoryInteractionLimitInput>],
    SelectionSet<T>
  >;

  /**
   * @description Set a user level interaction limit for an user's public repositories.
   */

  setUserInteractionLimit: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | SetUserInteractionLimitInput },
    select: (t: SetUserInteractionLimitPayloadSelector) => T
  ) => Field<
    "setUserInteractionLimit",
    [Argument<"input", Variable<"input"> | SetUserInteractionLimitInput>],
    SelectionSet<T>
  >;

  /**
   * @description Submits a pending pull request review.
   */

  submitPullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | SubmitPullRequestReviewInput },
    select: (t: SubmitPullRequestReviewPayloadSelector) => T
  ) => Field<
    "submitPullRequestReview",
    [Argument<"input", Variable<"input"> | SubmitPullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Transfer an issue to a different repository
   */

  transferIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | TransferIssueInput },
    select: (t: TransferIssuePayloadSelector) => T
  ) => Field<
    "transferIssue",
    [Argument<"input", Variable<"input"> | TransferIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unarchives a repository.
   */

  unarchiveRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnarchiveRepositoryInput },
    select: (t: UnarchiveRepositoryPayloadSelector) => T
  ) => Field<
    "unarchiveRepository",
    [Argument<"input", Variable<"input"> | UnarchiveRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unfollow a user.
   */

  unfollowUser: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnfollowUserInput },
    select: (t: UnfollowUserPayloadSelector) => T
  ) => Field<
    "unfollowUser",
    [Argument<"input", Variable<"input"> | UnfollowUserInput>],
    SelectionSet<T>
  >;

  /**
   * @description Deletes a repository link from a project.
   */

  unlinkRepositoryFromProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnlinkRepositoryFromProjectInput },
    select: (t: UnlinkRepositoryFromProjectPayloadSelector) => T
  ) => Field<
    "unlinkRepositoryFromProject",
    [Argument<"input", Variable<"input"> | UnlinkRepositoryFromProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unlock a lockable object
   */

  unlockLockable: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnlockLockableInput },
    select: (t: UnlockLockablePayloadSelector) => T
  ) => Field<
    "unlockLockable",
    [Argument<"input", Variable<"input"> | UnlockLockableInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unmark a pull request file as viewed
   */

  unmarkFileAsViewed: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnmarkFileAsViewedInput },
    select: (t: UnmarkFileAsViewedPayloadSelector) => T
  ) => Field<
    "unmarkFileAsViewed",
    [Argument<"input", Variable<"input"> | UnmarkFileAsViewedInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unmark an issue as a duplicate of another issue.
   */

  unmarkIssueAsDuplicate: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnmarkIssueAsDuplicateInput },
    select: (t: UnmarkIssueAsDuplicatePayloadSelector) => T
  ) => Field<
    "unmarkIssueAsDuplicate",
    [Argument<"input", Variable<"input"> | UnmarkIssueAsDuplicateInput>],
    SelectionSet<T>
  >;

  /**
   * @description Unminimizes a comment on an Issue, Commit, Pull Request, or Gist
   */

  unminimizeComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnminimizeCommentInput },
    select: (t: UnminimizeCommentPayloadSelector) => T
  ) => Field<
    "unminimizeComment",
    [Argument<"input", Variable<"input"> | UnminimizeCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Marks a review thread as unresolved.
   */

  unresolveReviewThread: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UnresolveReviewThreadInput },
    select: (t: UnresolveReviewThreadPayloadSelector) => T
  ) => Field<
    "unresolveReviewThread",
    [Argument<"input", Variable<"input"> | UnresolveReviewThreadInput>],
    SelectionSet<T>
  >;

  /**
   * @description Create a new branch protection rule
   */

  updateBranchProtectionRule: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateBranchProtectionRuleInput },
    select: (t: UpdateBranchProtectionRulePayloadSelector) => T
  ) => Field<
    "updateBranchProtectionRule",
    [Argument<"input", Variable<"input"> | UpdateBranchProtectionRuleInput>],
    SelectionSet<T>
  >;

  /**
   * @description Update a check run
   */

  updateCheckRun: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateCheckRunInput },
    select: (t: UpdateCheckRunPayloadSelector) => T
  ) => Field<
    "updateCheckRun",
    [Argument<"input", Variable<"input"> | UpdateCheckRunInput>],
    SelectionSet<T>
  >;

  /**
   * @description Modifies the settings of an existing check suite
   */

  updateCheckSuitePreferences: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateCheckSuitePreferencesInput },
    select: (t: UpdateCheckSuitePreferencesPayloadSelector) => T
  ) => Field<
    "updateCheckSuitePreferences",
    [Argument<"input", Variable<"input"> | UpdateCheckSuitePreferencesInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates the role of an enterprise administrator.
   */

  updateEnterpriseAdministratorRole: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | UpdateEnterpriseAdministratorRoleInput;
    },
    select: (t: UpdateEnterpriseAdministratorRolePayloadSelector) => T
  ) => Field<
    "updateEnterpriseAdministratorRole",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseAdministratorRoleInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether private repository forks are enabled for an enterprise.
   */

  updateEnterpriseAllowPrivateRepositoryForkingSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput;
    },
    select: (
      t: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseAllowPrivateRepositoryForkingSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseAllowPrivateRepositoryForkingSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the default repository permission for organizations in an enterprise.
   */

  updateEnterpriseDefaultRepositoryPermissionSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseDefaultRepositoryPermissionSettingInput;
    },
    select: (
      t: UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseDefaultRepositoryPermissionSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseDefaultRepositoryPermissionSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether organization members with admin permissions on a repository can change repository visibility.
   */

  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanChangeRepositoryVisibilitySetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can create repositories setting for an enterprise.
   */

  updateEnterpriseMembersCanCreateRepositoriesSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanCreateRepositoriesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanCreateRepositoriesSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanCreateRepositoriesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can delete issues setting for an enterprise.
   */

  updateEnterpriseMembersCanDeleteIssuesSetting: <T extends Array<Selection>>(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanDeleteIssuesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanDeleteIssuesSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseMembersCanDeleteIssuesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can delete repositories setting for an enterprise.
   */

  updateEnterpriseMembersCanDeleteRepositoriesSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanDeleteRepositoriesSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanDeleteRepositoriesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether members can invite collaborators are enabled for an enterprise.
   */

  updateEnterpriseMembersCanInviteCollaboratorsSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanInviteCollaboratorsSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanInviteCollaboratorsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether or not an organization admin can make purchases.
   */

  updateEnterpriseMembersCanMakePurchasesSetting: <T extends Array<Selection>>(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanMakePurchasesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanMakePurchasesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanMakePurchasesSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseMembersCanMakePurchasesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can update protected branches setting for an enterprise.
   */

  updateEnterpriseMembersCanUpdateProtectedBranchesSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanUpdateProtectedBranchesSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets the members can view dependency insights for an enterprise.
   */

  updateEnterpriseMembersCanViewDependencyInsightsSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput;
    },
    select: (
      t: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseMembersCanViewDependencyInsightsSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseMembersCanViewDependencyInsightsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether organization projects are enabled for an enterprise.
   */

  updateEnterpriseOrganizationProjectsSetting: <T extends Array<Selection>>(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseOrganizationProjectsSettingInput;
    },
    select: (t: UpdateEnterpriseOrganizationProjectsSettingPayloadSelector) => T
  ) => Field<
    "updateEnterpriseOrganizationProjectsSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseOrganizationProjectsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Updates an enterprise's profile.
   */

  updateEnterpriseProfile: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateEnterpriseProfileInput },
    select: (t: UpdateEnterpriseProfilePayloadSelector) => T
  ) => Field<
    "updateEnterpriseProfile",
    [Argument<"input", Variable<"input"> | UpdateEnterpriseProfileInput>],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether repository projects are enabled for a enterprise.
   */

  updateEnterpriseRepositoryProjectsSetting: <T extends Array<Selection>>(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseRepositoryProjectsSettingInput;
    },
    select: (t: UpdateEnterpriseRepositoryProjectsSettingPayloadSelector) => T
  ) => Field<
    "updateEnterpriseRepositoryProjectsSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseRepositoryProjectsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether team discussions are enabled for an enterprise.
   */

  updateEnterpriseTeamDiscussionsSetting: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | UpdateEnterpriseTeamDiscussionsSettingInput;
    },
    select: (t: UpdateEnterpriseTeamDiscussionsSettingPayloadSelector) => T
  ) => Field<
    "updateEnterpriseTeamDiscussionsSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateEnterpriseTeamDiscussionsSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether two factor authentication is required for all users in an enterprise.
   */

  updateEnterpriseTwoFactorAuthenticationRequiredSetting: <
    T extends Array<Selection>
  >(
    variables: {
      input?:
        | Variable<"input">
        | UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput;
    },
    select: (
      t: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadSelector
    ) => T
  ) => Field<
    "updateEnterpriseTwoFactorAuthenticationRequiredSetting",
    [
      Argument<
        "input",
        | Variable<"input">
        | UpdateEnterpriseTwoFactorAuthenticationRequiredSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Sets whether an IP allow list is enabled on an owner.
   */

  updateIpAllowListEnabledSetting: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | UpdateIpAllowListEnabledSettingInput;
    },
    select: (t: UpdateIpAllowListEnabledSettingPayloadSelector) => T
  ) => Field<
    "updateIpAllowListEnabledSetting",
    [
      Argument<
        "input",
        Variable<"input"> | UpdateIpAllowListEnabledSettingInput
      >
    ],
    SelectionSet<T>
  >;

  /**
   * @description Updates an IP allow list entry.
   */

  updateIpAllowListEntry: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateIpAllowListEntryInput },
    select: (t: UpdateIpAllowListEntryPayloadSelector) => T
  ) => Field<
    "updateIpAllowListEntry",
    [Argument<"input", Variable<"input"> | UpdateIpAllowListEntryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an Issue.
   */

  updateIssue: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateIssueInput },
    select: (t: UpdateIssuePayloadSelector) => T
  ) => Field<
    "updateIssue",
    [Argument<"input", Variable<"input"> | UpdateIssueInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an IssueComment object.
   */

  updateIssueComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateIssueCommentInput },
    select: (t: UpdateIssueCommentPayloadSelector) => T
  ) => Field<
    "updateIssueComment",
    [Argument<"input", Variable<"input"> | UpdateIssueCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an existing project.
   */

  updateProject: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateProjectInput },
    select: (t: UpdateProjectPayloadSelector) => T
  ) => Field<
    "updateProject",
    [Argument<"input", Variable<"input"> | UpdateProjectInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an existing project card.
   */

  updateProjectCard: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateProjectCardInput },
    select: (t: UpdateProjectCardPayloadSelector) => T
  ) => Field<
    "updateProjectCard",
    [Argument<"input", Variable<"input"> | UpdateProjectCardInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates an existing project column.
   */

  updateProjectColumn: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateProjectColumnInput },
    select: (t: UpdateProjectColumnPayloadSelector) => T
  ) => Field<
    "updateProjectColumn",
    [Argument<"input", Variable<"input"> | UpdateProjectColumnInput>],
    SelectionSet<T>
  >;

  /**
   * @description Update a pull request
   */

  updatePullRequest: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdatePullRequestInput },
    select: (t: UpdatePullRequestPayloadSelector) => T
  ) => Field<
    "updatePullRequest",
    [Argument<"input", Variable<"input"> | UpdatePullRequestInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates the body of a pull request review.
   */

  updatePullRequestReview: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdatePullRequestReviewInput },
    select: (t: UpdatePullRequestReviewPayloadSelector) => T
  ) => Field<
    "updatePullRequestReview",
    [Argument<"input", Variable<"input"> | UpdatePullRequestReviewInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates a pull request review comment.
   */

  updatePullRequestReviewComment: <T extends Array<Selection>>(
    variables: {
      input?: Variable<"input"> | UpdatePullRequestReviewCommentInput;
    },
    select: (t: UpdatePullRequestReviewCommentPayloadSelector) => T
  ) => Field<
    "updatePullRequestReviewComment",
    [
      Argument<"input", Variable<"input"> | UpdatePullRequestReviewCommentInput>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Update a Git Ref.
   */

  updateRef: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateRefInput },
    select: (t: UpdateRefPayloadSelector) => T
  ) => Field<
    "updateRef",
    [Argument<"input", Variable<"input"> | UpdateRefInput>],
    SelectionSet<T>
  >;

  /**
   * @description Update information about a repository.
   */

  updateRepository: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateRepositoryInput },
    select: (t: UpdateRepositoryPayloadSelector) => T
  ) => Field<
    "updateRepository",
    [Argument<"input", Variable<"input"> | UpdateRepositoryInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates the state for subscribable subjects.
   */

  updateSubscription: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateSubscriptionInput },
    select: (t: UpdateSubscriptionPayloadSelector) => T
  ) => Field<
    "updateSubscription",
    [Argument<"input", Variable<"input"> | UpdateSubscriptionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates a team discussion.
   */

  updateTeamDiscussion: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateTeamDiscussionInput },
    select: (t: UpdateTeamDiscussionPayloadSelector) => T
  ) => Field<
    "updateTeamDiscussion",
    [Argument<"input", Variable<"input"> | UpdateTeamDiscussionInput>],
    SelectionSet<T>
  >;

  /**
   * @description Updates a discussion comment.
   */

  updateTeamDiscussionComment: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateTeamDiscussionCommentInput },
    select: (t: UpdateTeamDiscussionCommentPayloadSelector) => T
  ) => Field<
    "updateTeamDiscussionComment",
    [Argument<"input", Variable<"input"> | UpdateTeamDiscussionCommentInput>],
    SelectionSet<T>
  >;

  /**
   * @description Replaces the repository's topics with the given topics.
   */

  updateTopics: <T extends Array<Selection>>(
    variables: { input?: Variable<"input"> | UpdateTopicsInput },
    select: (t: UpdateTopicsPayloadSelector) => T
  ) => Field<
    "updateTopics",
    [Argument<"input", Variable<"input"> | UpdateTopicsInput>],
    SelectionSet<T>
  >;
}

export const Mutation: MutationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Accepts a pending invitation for a user to become an administrator of an enterprise.
   */

  acceptEnterpriseAdministratorInvitation: (variables, select) =>
    new Field(
      "acceptEnterpriseAdministratorInvitation",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AcceptEnterpriseAdministratorInvitationPayload))
    ),

  /**
   * @description Applies a suggested topic to the repository.
   */

  acceptTopicSuggestion: (variables, select) =>
    new Field(
      "acceptTopicSuggestion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AcceptTopicSuggestionPayload))
    ),

  /**
   * @description Adds assignees to an assignable object.
   */

  addAssigneesToAssignable: (variables, select) =>
    new Field(
      "addAssigneesToAssignable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddAssigneesToAssignablePayload))
    ),

  /**
   * @description Adds a comment to an Issue or Pull Request.
   */

  addComment: (variables, select) =>
    new Field(
      "addComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddCommentPayload))
    ),

  /**
   * @description Adds labels to a labelable object.
   */

  addLabelsToLabelable: (variables, select) =>
    new Field(
      "addLabelsToLabelable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddLabelsToLabelablePayload))
    ),

  /**
   * @description Adds a card to a ProjectColumn. Either `contentId` or `note` must be provided but **not** both.
   */

  addProjectCard: (variables, select) =>
    new Field(
      "addProjectCard",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddProjectCardPayload))
    ),

  /**
   * @description Adds a column to a Project.
   */

  addProjectColumn: (variables, select) =>
    new Field(
      "addProjectColumn",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddProjectColumnPayload))
    ),

  /**
   * @description Adds a review to a Pull Request.
   */

  addPullRequestReview: (variables, select) =>
    new Field(
      "addPullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddPullRequestReviewPayload))
    ),

  /**
   * @description Adds a comment to a review.
   */

  addPullRequestReviewComment: (variables, select) =>
    new Field(
      "addPullRequestReviewComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddPullRequestReviewCommentPayload))
    ),

  /**
   * @description Adds a new thread to a pending Pull Request Review.
   */

  addPullRequestReviewThread: (variables, select) =>
    new Field(
      "addPullRequestReviewThread",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddPullRequestReviewThreadPayload))
    ),

  /**
   * @description Adds a reaction to a subject.
   */

  addReaction: (variables, select) =>
    new Field(
      "addReaction",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddReactionPayload))
    ),

  /**
   * @description Adds a star to a Starrable.
   */

  addStar: (variables, select) =>
    new Field(
      "addStar",
      [new Argument("input", variables.input)],
      new SelectionSet(select(AddStarPayload))
    ),

  /**
   * @description Marks a repository as archived.
   */

  archiveRepository: (variables, select) =>
    new Field(
      "archiveRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ArchiveRepositoryPayload))
    ),

  /**
   * @description Cancels a pending invitation for an administrator to join an enterprise.
   */

  cancelEnterpriseAdminInvitation: (variables, select) =>
    new Field(
      "cancelEnterpriseAdminInvitation",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CancelEnterpriseAdminInvitationPayload))
    ),

  /**
   * @description Update your status on GitHub.
   */

  changeUserStatus: (variables, select) =>
    new Field(
      "changeUserStatus",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ChangeUserStatusPayload))
    ),

  /**
   * @description Clears all labels from a labelable object.
   */

  clearLabelsFromLabelable: (variables, select) =>
    new Field(
      "clearLabelsFromLabelable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ClearLabelsFromLabelablePayload))
    ),

  /**
   * @description Creates a new project by cloning configuration from an existing project.
   */

  cloneProject: (variables, select) =>
    new Field(
      "cloneProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CloneProjectPayload))
    ),

  /**
   * @description Create a new repository with the same files and directory structure as a template repository.
   */

  cloneTemplateRepository: (variables, select) =>
    new Field(
      "cloneTemplateRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CloneTemplateRepositoryPayload))
    ),

  /**
   * @description Close an issue.
   */

  closeIssue: (variables, select) =>
    new Field(
      "closeIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CloseIssuePayload))
    ),

  /**
   * @description Close a pull request.
   */

  closePullRequest: (variables, select) =>
    new Field(
      "closePullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ClosePullRequestPayload))
    ),

  /**
   * @description Convert a project note card to one associated with a newly created issue.
   */

  convertProjectCardNoteToIssue: (variables, select) =>
    new Field(
      "convertProjectCardNoteToIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ConvertProjectCardNoteToIssuePayload))
    ),

  /**
   * @description Create a new branch protection rule
   */

  createBranchProtectionRule: (variables, select) =>
    new Field(
      "createBranchProtectionRule",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateBranchProtectionRulePayload))
    ),

  /**
   * @description Create a check run.
   */

  createCheckRun: (variables, select) =>
    new Field(
      "createCheckRun",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateCheckRunPayload))
    ),

  /**
   * @description Create a check suite
   */

  createCheckSuite: (variables, select) =>
    new Field(
      "createCheckSuite",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateCheckSuitePayload))
    ),

  /**
   * @description Creates an organization as part of an enterprise account.
   */

  createEnterpriseOrganization: (variables, select) =>
    new Field(
      "createEnterpriseOrganization",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateEnterpriseOrganizationPayload))
    ),

  /**
   * @description Creates a new IP allow list entry.
   */

  createIpAllowListEntry: (variables, select) =>
    new Field(
      "createIpAllowListEntry",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateIpAllowListEntryPayload))
    ),

  /**
   * @description Creates a new issue.
   */

  createIssue: (variables, select) =>
    new Field(
      "createIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateIssuePayload))
    ),

  /**
   * @description Creates a new project.
   */

  createProject: (variables, select) =>
    new Field(
      "createProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateProjectPayload))
    ),

  /**
   * @description Create a new pull request
   */

  createPullRequest: (variables, select) =>
    new Field(
      "createPullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreatePullRequestPayload))
    ),

  /**
   * @description Create a new Git Ref.
   */

  createRef: (variables, select) =>
    new Field(
      "createRef",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateRefPayload))
    ),

  /**
   * @description Create a new repository.
   */

  createRepository: (variables, select) =>
    new Field(
      "createRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateRepositoryPayload))
    ),

  /**
   * @description Creates a new team discussion.
   */

  createTeamDiscussion: (variables, select) =>
    new Field(
      "createTeamDiscussion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateTeamDiscussionPayload))
    ),

  /**
   * @description Creates a new team discussion comment.
   */

  createTeamDiscussionComment: (variables, select) =>
    new Field(
      "createTeamDiscussionComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(CreateTeamDiscussionCommentPayload))
    ),

  /**
   * @description Rejects a suggested topic for the repository.
   */

  declineTopicSuggestion: (variables, select) =>
    new Field(
      "declineTopicSuggestion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeclineTopicSuggestionPayload))
    ),

  /**
   * @description Delete a branch protection rule
   */

  deleteBranchProtectionRule: (variables, select) =>
    new Field(
      "deleteBranchProtectionRule",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteBranchProtectionRulePayload))
    ),

  /**
   * @description Deletes a deployment.
   */

  deleteDeployment: (variables, select) =>
    new Field(
      "deleteDeployment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteDeploymentPayload))
    ),

  /**
   * @description Deletes an IP allow list entry.
   */

  deleteIpAllowListEntry: (variables, select) =>
    new Field(
      "deleteIpAllowListEntry",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteIpAllowListEntryPayload))
    ),

  /**
   * @description Deletes an Issue object.
   */

  deleteIssue: (variables, select) =>
    new Field(
      "deleteIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteIssuePayload))
    ),

  /**
   * @description Deletes an IssueComment object.
   */

  deleteIssueComment: (variables, select) =>
    new Field(
      "deleteIssueComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteIssueCommentPayload))
    ),

  /**
   * @description Deletes a project.
   */

  deleteProject: (variables, select) =>
    new Field(
      "deleteProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteProjectPayload))
    ),

  /**
   * @description Deletes a project card.
   */

  deleteProjectCard: (variables, select) =>
    new Field(
      "deleteProjectCard",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteProjectCardPayload))
    ),

  /**
   * @description Deletes a project column.
   */

  deleteProjectColumn: (variables, select) =>
    new Field(
      "deleteProjectColumn",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteProjectColumnPayload))
    ),

  /**
   * @description Deletes a pull request review.
   */

  deletePullRequestReview: (variables, select) =>
    new Field(
      "deletePullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeletePullRequestReviewPayload))
    ),

  /**
   * @description Deletes a pull request review comment.
   */

  deletePullRequestReviewComment: (variables, select) =>
    new Field(
      "deletePullRequestReviewComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeletePullRequestReviewCommentPayload))
    ),

  /**
   * @description Delete a Git Ref.
   */

  deleteRef: (variables, select) =>
    new Field(
      "deleteRef",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteRefPayload))
    ),

  /**
   * @description Deletes a team discussion.
   */

  deleteTeamDiscussion: (variables, select) =>
    new Field(
      "deleteTeamDiscussion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteTeamDiscussionPayload))
    ),

  /**
   * @description Deletes a team discussion comment.
   */

  deleteTeamDiscussionComment: (variables, select) =>
    new Field(
      "deleteTeamDiscussionComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DeleteTeamDiscussionCommentPayload))
    ),

  /**
   * @description Dismisses an approved or rejected pull request review.
   */

  dismissPullRequestReview: (variables, select) =>
    new Field(
      "dismissPullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(DismissPullRequestReviewPayload))
    ),

  /**
   * @description Follow a user.
   */

  followUser: (variables, select) =>
    new Field(
      "followUser",
      [new Argument("input", variables.input)],
      new SelectionSet(select(FollowUserPayload))
    ),

  /**
   * @description Invite someone to become an administrator of the enterprise.
   */

  inviteEnterpriseAdmin: (variables, select) =>
    new Field(
      "inviteEnterpriseAdmin",
      [new Argument("input", variables.input)],
      new SelectionSet(select(InviteEnterpriseAdminPayload))
    ),

  /**
   * @description Creates a repository link for a project.
   */

  linkRepositoryToProject: (variables, select) =>
    new Field(
      "linkRepositoryToProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(LinkRepositoryToProjectPayload))
    ),

  /**
   * @description Lock a lockable object
   */

  lockLockable: (variables, select) =>
    new Field(
      "lockLockable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(LockLockablePayload))
    ),

  /**
   * @description Mark a pull request file as viewed
   */

  markFileAsViewed: (variables, select) =>
    new Field(
      "markFileAsViewed",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MarkFileAsViewedPayload))
    ),

  /**
   * @description Marks a pull request ready for review.
   */

  markPullRequestReadyForReview: (variables, select) =>
    new Field(
      "markPullRequestReadyForReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MarkPullRequestReadyForReviewPayload))
    ),

  /**
   * @description Merge a head into a branch.
   */

  mergeBranch: (variables, select) =>
    new Field(
      "mergeBranch",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MergeBranchPayload))
    ),

  /**
   * @description Merge a pull request.
   */

  mergePullRequest: (variables, select) =>
    new Field(
      "mergePullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MergePullRequestPayload))
    ),

  /**
   * @description Minimizes a comment on an Issue, Commit, Pull Request, or Gist
   */

  minimizeComment: (variables, select) =>
    new Field(
      "minimizeComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MinimizeCommentPayload))
    ),

  /**
   * @description Moves a project card to another place.
   */

  moveProjectCard: (variables, select) =>
    new Field(
      "moveProjectCard",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MoveProjectCardPayload))
    ),

  /**
   * @description Moves a project column to another place.
   */

  moveProjectColumn: (variables, select) =>
    new Field(
      "moveProjectColumn",
      [new Argument("input", variables.input)],
      new SelectionSet(select(MoveProjectColumnPayload))
    ),

  /**
   * @description Regenerates the identity provider recovery codes for an enterprise
   */

  regenerateEnterpriseIdentityProviderRecoveryCodes: (variables, select) =>
    new Field(
      "regenerateEnterpriseIdentityProviderRecoveryCodes",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(RegenerateEnterpriseIdentityProviderRecoveryCodesPayload)
      )
    ),

  /**
   * @description Removes assignees from an assignable object.
   */

  removeAssigneesFromAssignable: (variables, select) =>
    new Field(
      "removeAssigneesFromAssignable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveAssigneesFromAssignablePayload))
    ),

  /**
   * @description Removes an administrator from the enterprise.
   */

  removeEnterpriseAdmin: (variables, select) =>
    new Field(
      "removeEnterpriseAdmin",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveEnterpriseAdminPayload))
    ),

  /**
   * @description Removes the identity provider from an enterprise
   */

  removeEnterpriseIdentityProvider: (variables, select) =>
    new Field(
      "removeEnterpriseIdentityProvider",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveEnterpriseIdentityProviderPayload))
    ),

  /**
   * @description Removes an organization from the enterprise
   */

  removeEnterpriseOrganization: (variables, select) =>
    new Field(
      "removeEnterpriseOrganization",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveEnterpriseOrganizationPayload))
    ),

  /**
   * @description Removes labels from a Labelable object.
   */

  removeLabelsFromLabelable: (variables, select) =>
    new Field(
      "removeLabelsFromLabelable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveLabelsFromLabelablePayload))
    ),

  /**
   * @description Removes outside collaborator from all repositories in an organization.
   */

  removeOutsideCollaborator: (variables, select) =>
    new Field(
      "removeOutsideCollaborator",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveOutsideCollaboratorPayload))
    ),

  /**
   * @description Removes a reaction from a subject.
   */

  removeReaction: (variables, select) =>
    new Field(
      "removeReaction",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveReactionPayload))
    ),

  /**
   * @description Removes a star from a Starrable.
   */

  removeStar: (variables, select) =>
    new Field(
      "removeStar",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RemoveStarPayload))
    ),

  /**
   * @description Reopen a issue.
   */

  reopenIssue: (variables, select) =>
    new Field(
      "reopenIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ReopenIssuePayload))
    ),

  /**
   * @description Reopen a pull request.
   */

  reopenPullRequest: (variables, select) =>
    new Field(
      "reopenPullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ReopenPullRequestPayload))
    ),

  /**
   * @description Set review requests on a pull request.
   */

  requestReviews: (variables, select) =>
    new Field(
      "requestReviews",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RequestReviewsPayload))
    ),

  /**
   * @description Rerequests an existing check suite.
   */

  rerequestCheckSuite: (variables, select) =>
    new Field(
      "rerequestCheckSuite",
      [new Argument("input", variables.input)],
      new SelectionSet(select(RerequestCheckSuitePayload))
    ),

  /**
   * @description Marks a review thread as resolved.
   */

  resolveReviewThread: (variables, select) =>
    new Field(
      "resolveReviewThread",
      [new Argument("input", variables.input)],
      new SelectionSet(select(ResolveReviewThreadPayload))
    ),

  /**
   * @description Creates or updates the identity provider for an enterprise.
   */

  setEnterpriseIdentityProvider: (variables, select) =>
    new Field(
      "setEnterpriseIdentityProvider",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SetEnterpriseIdentityProviderPayload))
    ),

  /**
   * @description Set an organization level interaction limit for an organization's public repositories.
   */

  setOrganizationInteractionLimit: (variables, select) =>
    new Field(
      "setOrganizationInteractionLimit",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SetOrganizationInteractionLimitPayload))
    ),

  /**
   * @description Sets an interaction limit setting for a repository.
   */

  setRepositoryInteractionLimit: (variables, select) =>
    new Field(
      "setRepositoryInteractionLimit",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SetRepositoryInteractionLimitPayload))
    ),

  /**
   * @description Set a user level interaction limit for an user's public repositories.
   */

  setUserInteractionLimit: (variables, select) =>
    new Field(
      "setUserInteractionLimit",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SetUserInteractionLimitPayload))
    ),

  /**
   * @description Submits a pending pull request review.
   */

  submitPullRequestReview: (variables, select) =>
    new Field(
      "submitPullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(SubmitPullRequestReviewPayload))
    ),

  /**
   * @description Transfer an issue to a different repository
   */

  transferIssue: (variables, select) =>
    new Field(
      "transferIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(TransferIssuePayload))
    ),

  /**
   * @description Unarchives a repository.
   */

  unarchiveRepository: (variables, select) =>
    new Field(
      "unarchiveRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnarchiveRepositoryPayload))
    ),

  /**
   * @description Unfollow a user.
   */

  unfollowUser: (variables, select) =>
    new Field(
      "unfollowUser",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnfollowUserPayload))
    ),

  /**
   * @description Deletes a repository link from a project.
   */

  unlinkRepositoryFromProject: (variables, select) =>
    new Field(
      "unlinkRepositoryFromProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnlinkRepositoryFromProjectPayload))
    ),

  /**
   * @description Unlock a lockable object
   */

  unlockLockable: (variables, select) =>
    new Field(
      "unlockLockable",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnlockLockablePayload))
    ),

  /**
   * @description Unmark a pull request file as viewed
   */

  unmarkFileAsViewed: (variables, select) =>
    new Field(
      "unmarkFileAsViewed",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnmarkFileAsViewedPayload))
    ),

  /**
   * @description Unmark an issue as a duplicate of another issue.
   */

  unmarkIssueAsDuplicate: (variables, select) =>
    new Field(
      "unmarkIssueAsDuplicate",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnmarkIssueAsDuplicatePayload))
    ),

  /**
   * @description Unminimizes a comment on an Issue, Commit, Pull Request, or Gist
   */

  unminimizeComment: (variables, select) =>
    new Field(
      "unminimizeComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnminimizeCommentPayload))
    ),

  /**
   * @description Marks a review thread as unresolved.
   */

  unresolveReviewThread: (variables, select) =>
    new Field(
      "unresolveReviewThread",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UnresolveReviewThreadPayload))
    ),

  /**
   * @description Create a new branch protection rule
   */

  updateBranchProtectionRule: (variables, select) =>
    new Field(
      "updateBranchProtectionRule",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateBranchProtectionRulePayload))
    ),

  /**
   * @description Update a check run
   */

  updateCheckRun: (variables, select) =>
    new Field(
      "updateCheckRun",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateCheckRunPayload))
    ),

  /**
   * @description Modifies the settings of an existing check suite
   */

  updateCheckSuitePreferences: (variables, select) =>
    new Field(
      "updateCheckSuitePreferences",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateCheckSuitePreferencesPayload))
    ),

  /**
   * @description Updates the role of an enterprise administrator.
   */

  updateEnterpriseAdministratorRole: (variables, select) =>
    new Field(
      "updateEnterpriseAdministratorRole",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateEnterpriseAdministratorRolePayload))
    ),

  /**
   * @description Sets whether private repository forks are enabled for an enterprise.
   */

  updateEnterpriseAllowPrivateRepositoryForkingSetting: (variables, select) =>
    new Field(
      "updateEnterpriseAllowPrivateRepositoryForkingSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload)
      )
    ),

  /**
   * @description Sets the default repository permission for organizations in an enterprise.
   */

  updateEnterpriseDefaultRepositoryPermissionSetting: (variables, select) =>
    new Field(
      "updateEnterpriseDefaultRepositoryPermissionSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseDefaultRepositoryPermissionSettingPayload)
      )
    ),

  /**
   * @description Sets whether organization members with admin permissions on a repository can change repository visibility.
   */

  updateEnterpriseMembersCanChangeRepositoryVisibilitySetting: (
    variables,
    select
  ) =>
    new Field(
      "updateEnterpriseMembersCanChangeRepositoryVisibilitySetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(
          UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload
        )
      )
    ),

  /**
   * @description Sets the members can create repositories setting for an enterprise.
   */

  updateEnterpriseMembersCanCreateRepositoriesSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanCreateRepositoriesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload)
      )
    ),

  /**
   * @description Sets the members can delete issues setting for an enterprise.
   */

  updateEnterpriseMembersCanDeleteIssuesSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanDeleteIssuesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanDeleteIssuesSettingPayload)
      )
    ),

  /**
   * @description Sets the members can delete repositories setting for an enterprise.
   */

  updateEnterpriseMembersCanDeleteRepositoriesSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanDeleteRepositoriesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload)
      )
    ),

  /**
   * @description Sets whether members can invite collaborators are enabled for an enterprise.
   */

  updateEnterpriseMembersCanInviteCollaboratorsSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanInviteCollaboratorsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload)
      )
    ),

  /**
   * @description Sets whether or not an organization admin can make purchases.
   */

  updateEnterpriseMembersCanMakePurchasesSetting: (variables, select) =>
    new Field(
      "updateEnterpriseMembersCanMakePurchasesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanMakePurchasesSettingPayload)
      )
    ),

  /**
   * @description Sets the members can update protected branches setting for an enterprise.
   */

  updateEnterpriseMembersCanUpdateProtectedBranchesSetting: (
    variables,
    select
  ) =>
    new Field(
      "updateEnterpriseMembersCanUpdateProtectedBranchesSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload)
      )
    ),

  /**
   * @description Sets the members can view dependency insights for an enterprise.
   */

  updateEnterpriseMembersCanViewDependencyInsightsSetting: (
    variables,
    select
  ) =>
    new Field(
      "updateEnterpriseMembersCanViewDependencyInsightsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload)
      )
    ),

  /**
   * @description Sets whether organization projects are enabled for an enterprise.
   */

  updateEnterpriseOrganizationProjectsSetting: (variables, select) =>
    new Field(
      "updateEnterpriseOrganizationProjectsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseOrganizationProjectsSettingPayload)
      )
    ),

  /**
   * @description Updates an enterprise's profile.
   */

  updateEnterpriseProfile: (variables, select) =>
    new Field(
      "updateEnterpriseProfile",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateEnterpriseProfilePayload))
    ),

  /**
   * @description Sets whether repository projects are enabled for a enterprise.
   */

  updateEnterpriseRepositoryProjectsSetting: (variables, select) =>
    new Field(
      "updateEnterpriseRepositoryProjectsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateEnterpriseRepositoryProjectsSettingPayload))
    ),

  /**
   * @description Sets whether team discussions are enabled for an enterprise.
   */

  updateEnterpriseTeamDiscussionsSetting: (variables, select) =>
    new Field(
      "updateEnterpriseTeamDiscussionsSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateEnterpriseTeamDiscussionsSettingPayload))
    ),

  /**
   * @description Sets whether two factor authentication is required for all users in an enterprise.
   */

  updateEnterpriseTwoFactorAuthenticationRequiredSetting: (variables, select) =>
    new Field(
      "updateEnterpriseTwoFactorAuthenticationRequiredSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(
        select(UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload)
      )
    ),

  /**
   * @description Sets whether an IP allow list is enabled on an owner.
   */

  updateIpAllowListEnabledSetting: (variables, select) =>
    new Field(
      "updateIpAllowListEnabledSetting",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateIpAllowListEnabledSettingPayload))
    ),

  /**
   * @description Updates an IP allow list entry.
   */

  updateIpAllowListEntry: (variables, select) =>
    new Field(
      "updateIpAllowListEntry",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateIpAllowListEntryPayload))
    ),

  /**
   * @description Updates an Issue.
   */

  updateIssue: (variables, select) =>
    new Field(
      "updateIssue",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateIssuePayload))
    ),

  /**
   * @description Updates an IssueComment object.
   */

  updateIssueComment: (variables, select) =>
    new Field(
      "updateIssueComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateIssueCommentPayload))
    ),

  /**
   * @description Updates an existing project.
   */

  updateProject: (variables, select) =>
    new Field(
      "updateProject",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateProjectPayload))
    ),

  /**
   * @description Updates an existing project card.
   */

  updateProjectCard: (variables, select) =>
    new Field(
      "updateProjectCard",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateProjectCardPayload))
    ),

  /**
   * @description Updates an existing project column.
   */

  updateProjectColumn: (variables, select) =>
    new Field(
      "updateProjectColumn",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateProjectColumnPayload))
    ),

  /**
   * @description Update a pull request
   */

  updatePullRequest: (variables, select) =>
    new Field(
      "updatePullRequest",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdatePullRequestPayload))
    ),

  /**
   * @description Updates the body of a pull request review.
   */

  updatePullRequestReview: (variables, select) =>
    new Field(
      "updatePullRequestReview",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdatePullRequestReviewPayload))
    ),

  /**
   * @description Updates a pull request review comment.
   */

  updatePullRequestReviewComment: (variables, select) =>
    new Field(
      "updatePullRequestReviewComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdatePullRequestReviewCommentPayload))
    ),

  /**
   * @description Update a Git Ref.
   */

  updateRef: (variables, select) =>
    new Field(
      "updateRef",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateRefPayload))
    ),

  /**
   * @description Update information about a repository.
   */

  updateRepository: (variables, select) =>
    new Field(
      "updateRepository",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateRepositoryPayload))
    ),

  /**
   * @description Updates the state for subscribable subjects.
   */

  updateSubscription: (variables, select) =>
    new Field(
      "updateSubscription",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateSubscriptionPayload))
    ),

  /**
   * @description Updates a team discussion.
   */

  updateTeamDiscussion: (variables, select) =>
    new Field(
      "updateTeamDiscussion",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateTeamDiscussionPayload))
    ),

  /**
   * @description Updates a discussion comment.
   */

  updateTeamDiscussionComment: (variables, select) =>
    new Field(
      "updateTeamDiscussionComment",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateTeamDiscussionCommentPayload))
    ),

  /**
   * @description Replaces the repository's topics with the given topics.
   */

  updateTopics: (variables, select) =>
    new Field(
      "updateTopics",
      [new Argument("input", variables.input)],
      new SelectionSet(select(UpdateTopicsPayload))
    ),
};

export interface INode {
  __typename: string;
  id: string;
}

interface NodeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description ID of the object.
   */

  id: () => Field<"id">;

  on: <
    T extends Array<Selection>,
    F extends
      | "AddedToProjectEvent"
      | "App"
      | "AssignedEvent"
      | "AutomaticBaseChangeFailedEvent"
      | "AutomaticBaseChangeSucceededEvent"
      | "BaseRefChangedEvent"
      | "BaseRefDeletedEvent"
      | "BaseRefForcePushedEvent"
      | "Blob"
      | "Bot"
      | "BranchProtectionRule"
      | "CheckRun"
      | "CheckSuite"
      | "ClosedEvent"
      | "CodeOfConduct"
      | "CommentDeletedEvent"
      | "Commit"
      | "CommitComment"
      | "CommitCommentThread"
      | "ConnectedEvent"
      | "ConvertToDraftEvent"
      | "ConvertedNoteToIssueEvent"
      | "CrossReferencedEvent"
      | "DemilestonedEvent"
      | "DeployKey"
      | "DeployedEvent"
      | "Deployment"
      | "DeploymentEnvironmentChangedEvent"
      | "DeploymentStatus"
      | "DisconnectedEvent"
      | "Enterprise"
      | "EnterpriseAdministratorInvitation"
      | "EnterpriseIdentityProvider"
      | "EnterpriseRepositoryInfo"
      | "EnterpriseServerInstallation"
      | "EnterpriseServerUserAccount"
      | "EnterpriseServerUserAccountEmail"
      | "EnterpriseServerUserAccountsUpload"
      | "EnterpriseUserAccount"
      | "ExternalIdentity"
      | "Gist"
      | "GistComment"
      | "HeadRefDeletedEvent"
      | "HeadRefForcePushedEvent"
      | "HeadRefRestoredEvent"
      | "IpAllowListEntry"
      | "Issue"
      | "IssueComment"
      | "Label"
      | "LabeledEvent"
      | "Language"
      | "License"
      | "LockedEvent"
      | "Mannequin"
      | "MarkedAsDuplicateEvent"
      | "MarketplaceCategory"
      | "MarketplaceListing"
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "MentionedEvent"
      | "MergedEvent"
      | "Milestone"
      | "MilestonedEvent"
      | "MovedColumnsInProjectEvent"
      | "OauthApplicationCreateAuditEntry"
      | "OrgAddBillingManagerAuditEntry"
      | "OrgAddMemberAuditEntry"
      | "OrgBlockUserAuditEntry"
      | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
      | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
      | "OrgCreateAuditEntry"
      | "OrgDisableOauthAppRestrictionsAuditEntry"
      | "OrgDisableSamlAuditEntry"
      | "OrgDisableTwoFactorRequirementAuditEntry"
      | "OrgEnableOauthAppRestrictionsAuditEntry"
      | "OrgEnableSamlAuditEntry"
      | "OrgEnableTwoFactorRequirementAuditEntry"
      | "OrgInviteMemberAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
      | "OrgRemoveBillingManagerAuditEntry"
      | "OrgRemoveMemberAuditEntry"
      | "OrgRemoveOutsideCollaboratorAuditEntry"
      | "OrgRestoreMemberAuditEntry"
      | "OrgUnblockUserAuditEntry"
      | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
      | "OrgUpdateMemberAuditEntry"
      | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
      | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
      | "Organization"
      | "OrganizationIdentityProvider"
      | "OrganizationInvitation"
      | "Package"
      | "PackageFile"
      | "PackageTag"
      | "PackageVersion"
      | "PinnedEvent"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "Project"
      | "ProjectCard"
      | "ProjectColumn"
      | "PublicKey"
      | "PullRequest"
      | "PullRequestCommit"
      | "PullRequestCommitCommentThread"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "PullRequestReviewThread"
      | "Push"
      | "PushAllowance"
      | "Reaction"
      | "ReadyForReviewEvent"
      | "Ref"
      | "ReferencedEvent"
      | "Release"
      | "ReleaseAsset"
      | "RemovedFromProjectEvent"
      | "RenamedTitleEvent"
      | "ReopenedEvent"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "Repository"
      | "RepositoryInvitation"
      | "RepositoryTopic"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
      | "RepositoryVulnerabilityAlert"
      | "ReviewDismissalAllowance"
      | "ReviewDismissedEvent"
      | "ReviewRequest"
      | "ReviewRequestRemovedEvent"
      | "ReviewRequestedEvent"
      | "SavedReply"
      | "SecurityAdvisory"
      | "SponsorsListing"
      | "SponsorsTier"
      | "Sponsorship"
      | "Status"
      | "StatusCheckRollup"
      | "StatusContext"
      | "SubscribedEvent"
      | "Tag"
      | "Team"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
      | "Topic"
      | "TransferredEvent"
      | "Tree"
      | "UnassignedEvent"
      | "UnlabeledEvent"
      | "UnlockedEvent"
      | "UnmarkedAsDuplicateEvent"
      | "UnpinnedEvent"
      | "UnsubscribedEvent"
      | "User"
      | "UserBlockedEvent"
      | "UserContentEdit"
      | "UserStatus"
  >(
    type: F,
    select: (
      t: F extends "AddedToProjectEvent"
        ? AddedToProjectEventSelector
        : F extends "App"
        ? AppSelector
        : F extends "AssignedEvent"
        ? AssignedEventSelector
        : F extends "AutomaticBaseChangeFailedEvent"
        ? AutomaticBaseChangeFailedEventSelector
        : F extends "AutomaticBaseChangeSucceededEvent"
        ? AutomaticBaseChangeSucceededEventSelector
        : F extends "BaseRefChangedEvent"
        ? BaseRefChangedEventSelector
        : F extends "BaseRefDeletedEvent"
        ? BaseRefDeletedEventSelector
        : F extends "BaseRefForcePushedEvent"
        ? BaseRefForcePushedEventSelector
        : F extends "Blob"
        ? BlobSelector
        : F extends "Bot"
        ? BotSelector
        : F extends "BranchProtectionRule"
        ? BranchProtectionRuleSelector
        : F extends "CheckRun"
        ? CheckRunSelector
        : F extends "CheckSuite"
        ? CheckSuiteSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "CodeOfConduct"
        ? CodeOfConductSelector
        : F extends "CommentDeletedEvent"
        ? CommentDeletedEventSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "CommitCommentThread"
        ? CommitCommentThreadSelector
        : F extends "ConnectedEvent"
        ? ConnectedEventSelector
        : F extends "ConvertToDraftEvent"
        ? ConvertToDraftEventSelector
        : F extends "ConvertedNoteToIssueEvent"
        ? ConvertedNoteToIssueEventSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "DemilestonedEvent"
        ? DemilestonedEventSelector
        : F extends "DeployKey"
        ? DeployKeySelector
        : F extends "DeployedEvent"
        ? DeployedEventSelector
        : F extends "Deployment"
        ? DeploymentSelector
        : F extends "DeploymentEnvironmentChangedEvent"
        ? DeploymentEnvironmentChangedEventSelector
        : F extends "DeploymentStatus"
        ? DeploymentStatusSelector
        : F extends "DisconnectedEvent"
        ? DisconnectedEventSelector
        : F extends "Enterprise"
        ? EnterpriseSelector
        : F extends "EnterpriseAdministratorInvitation"
        ? EnterpriseAdministratorInvitationSelector
        : F extends "EnterpriseIdentityProvider"
        ? EnterpriseIdentityProviderSelector
        : F extends "EnterpriseRepositoryInfo"
        ? EnterpriseRepositoryInfoSelector
        : F extends "EnterpriseServerInstallation"
        ? EnterpriseServerInstallationSelector
        : F extends "EnterpriseServerUserAccount"
        ? EnterpriseServerUserAccountSelector
        : F extends "EnterpriseServerUserAccountEmail"
        ? EnterpriseServerUserAccountEmailSelector
        : F extends "EnterpriseServerUserAccountsUpload"
        ? EnterpriseServerUserAccountsUploadSelector
        : F extends "EnterpriseUserAccount"
        ? EnterpriseUserAccountSelector
        : F extends "ExternalIdentity"
        ? ExternalIdentitySelector
        : F extends "Gist"
        ? GistSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "HeadRefDeletedEvent"
        ? HeadRefDeletedEventSelector
        : F extends "HeadRefForcePushedEvent"
        ? HeadRefForcePushedEventSelector
        : F extends "HeadRefRestoredEvent"
        ? HeadRefRestoredEventSelector
        : F extends "IpAllowListEntry"
        ? IpAllowListEntrySelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "Label"
        ? LabelSelector
        : F extends "LabeledEvent"
        ? LabeledEventSelector
        : F extends "Language"
        ? LanguageSelector
        : F extends "License"
        ? LicenseSelector
        : F extends "LockedEvent"
        ? LockedEventSelector
        : F extends "Mannequin"
        ? MannequinSelector
        : F extends "MarkedAsDuplicateEvent"
        ? MarkedAsDuplicateEventSelector
        : F extends "MarketplaceCategory"
        ? MarketplaceCategorySelector
        : F extends "MarketplaceListing"
        ? MarketplaceListingSelector
        : F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "MentionedEvent"
        ? MentionedEventSelector
        : F extends "MergedEvent"
        ? MergedEventSelector
        : F extends "Milestone"
        ? MilestoneSelector
        : F extends "MilestonedEvent"
        ? MilestonedEventSelector
        : F extends "MovedColumnsInProjectEvent"
        ? MovedColumnsInProjectEventSelector
        : F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgAddBillingManagerAuditEntry"
        ? OrgAddBillingManagerAuditEntrySelector
        : F extends "OrgAddMemberAuditEntry"
        ? OrgAddMemberAuditEntrySelector
        : F extends "OrgBlockUserAuditEntry"
        ? OrgBlockUserAuditEntrySelector
        : F extends "OrgConfigDisableCollaboratorsOnlyAuditEntry"
        ? OrgConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgConfigEnableCollaboratorsOnlyAuditEntry"
        ? OrgConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgCreateAuditEntry"
        ? OrgCreateAuditEntrySelector
        : F extends "OrgDisableOauthAppRestrictionsAuditEntry"
        ? OrgDisableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgDisableSamlAuditEntry"
        ? OrgDisableSamlAuditEntrySelector
        : F extends "OrgDisableTwoFactorRequirementAuditEntry"
        ? OrgDisableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgEnableOauthAppRestrictionsAuditEntry"
        ? OrgEnableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgEnableSamlAuditEntry"
        ? OrgEnableSamlAuditEntrySelector
        : F extends "OrgEnableTwoFactorRequirementAuditEntry"
        ? OrgEnableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgInviteMemberAuditEntry"
        ? OrgInviteMemberAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : F extends "OrgRemoveBillingManagerAuditEntry"
        ? OrgRemoveBillingManagerAuditEntrySelector
        : F extends "OrgRemoveMemberAuditEntry"
        ? OrgRemoveMemberAuditEntrySelector
        : F extends "OrgRemoveOutsideCollaboratorAuditEntry"
        ? OrgRemoveOutsideCollaboratorAuditEntrySelector
        : F extends "OrgRestoreMemberAuditEntry"
        ? OrgRestoreMemberAuditEntrySelector
        : F extends "OrgUnblockUserAuditEntry"
        ? OrgUnblockUserAuditEntrySelector
        : F extends "OrgUpdateDefaultRepositoryPermissionAuditEntry"
        ? OrgUpdateDefaultRepositoryPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberAuditEntry"
        ? OrgUpdateMemberAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "OrganizationIdentityProvider"
        ? OrganizationIdentityProviderSelector
        : F extends "OrganizationInvitation"
        ? OrganizationInvitationSelector
        : F extends "Package"
        ? PackageSelector
        : F extends "PackageFile"
        ? PackageFileSelector
        : F extends "PackageTag"
        ? PackageTagSelector
        : F extends "PackageVersion"
        ? PackageVersionSelector
        : F extends "PinnedEvent"
        ? PinnedEventSelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "Project"
        ? ProjectSelector
        : F extends "ProjectCard"
        ? ProjectCardSelector
        : F extends "ProjectColumn"
        ? ProjectColumnSelector
        : F extends "PublicKey"
        ? PublicKeySelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestCommit"
        ? PullRequestCommitSelector
        : F extends "PullRequestCommitCommentThread"
        ? PullRequestCommitCommentThreadSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "PullRequestReviewThread"
        ? PullRequestReviewThreadSelector
        : F extends "Push"
        ? PushSelector
        : F extends "PushAllowance"
        ? PushAllowanceSelector
        : F extends "Reaction"
        ? ReactionSelector
        : F extends "ReadyForReviewEvent"
        ? ReadyForReviewEventSelector
        : F extends "Ref"
        ? RefSelector
        : F extends "ReferencedEvent"
        ? ReferencedEventSelector
        : F extends "Release"
        ? ReleaseSelector
        : F extends "ReleaseAsset"
        ? ReleaseAssetSelector
        : F extends "RemovedFromProjectEvent"
        ? RemovedFromProjectEventSelector
        : F extends "RenamedTitleEvent"
        ? RenamedTitleEventSelector
        : F extends "ReopenedEvent"
        ? ReopenedEventSelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "RepositoryInvitation"
        ? RepositoryInvitationSelector
        : F extends "RepositoryTopic"
        ? RepositoryTopicSelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : F extends "RepositoryVulnerabilityAlert"
        ? RepositoryVulnerabilityAlertSelector
        : F extends "ReviewDismissalAllowance"
        ? ReviewDismissalAllowanceSelector
        : F extends "ReviewDismissedEvent"
        ? ReviewDismissedEventSelector
        : F extends "ReviewRequest"
        ? ReviewRequestSelector
        : F extends "ReviewRequestRemovedEvent"
        ? ReviewRequestRemovedEventSelector
        : F extends "ReviewRequestedEvent"
        ? ReviewRequestedEventSelector
        : F extends "SavedReply"
        ? SavedReplySelector
        : F extends "SecurityAdvisory"
        ? SecurityAdvisorySelector
        : F extends "SponsorsListing"
        ? SponsorsListingSelector
        : F extends "SponsorsTier"
        ? SponsorsTierSelector
        : F extends "Sponsorship"
        ? SponsorshipSelector
        : F extends "Status"
        ? StatusSelector
        : F extends "StatusCheckRollup"
        ? StatusCheckRollupSelector
        : F extends "StatusContext"
        ? StatusContextSelector
        : F extends "SubscribedEvent"
        ? SubscribedEventSelector
        : F extends "Tag"
        ? TagSelector
        : F extends "Team"
        ? TeamSelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : F extends "Topic"
        ? TopicSelector
        : F extends "TransferredEvent"
        ? TransferredEventSelector
        : F extends "Tree"
        ? TreeSelector
        : F extends "UnassignedEvent"
        ? UnassignedEventSelector
        : F extends "UnlabeledEvent"
        ? UnlabeledEventSelector
        : F extends "UnlockedEvent"
        ? UnlockedEventSelector
        : F extends "UnmarkedAsDuplicateEvent"
        ? UnmarkedAsDuplicateEventSelector
        : F extends "UnpinnedEvent"
        ? UnpinnedEventSelector
        : F extends "UnsubscribedEvent"
        ? UnsubscribedEventSelector
        : F extends "User"
        ? UserSelector
        : F extends "UserBlockedEvent"
        ? UserBlockedEventSelector
        : F extends "UserContentEdit"
        ? UserContentEditSelector
        : F extends "UserStatus"
        ? UserStatusSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Node: NodeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description ID of the object.
   */
  id: () => new Field("id"),

  on: (type, select) => {
    switch (type) {
      case "AddedToProjectEvent": {
        return new InlineFragment(
          new NamedType("AddedToProjectEvent") as any,
          new SelectionSet(select(AddedToProjectEvent as any))
        );
      }

      case "App": {
        return new InlineFragment(
          new NamedType("App") as any,
          new SelectionSet(select(App as any))
        );
      }

      case "AssignedEvent": {
        return new InlineFragment(
          new NamedType("AssignedEvent") as any,
          new SelectionSet(select(AssignedEvent as any))
        );
      }

      case "AutomaticBaseChangeFailedEvent": {
        return new InlineFragment(
          new NamedType("AutomaticBaseChangeFailedEvent") as any,
          new SelectionSet(select(AutomaticBaseChangeFailedEvent as any))
        );
      }

      case "AutomaticBaseChangeSucceededEvent": {
        return new InlineFragment(
          new NamedType("AutomaticBaseChangeSucceededEvent") as any,
          new SelectionSet(select(AutomaticBaseChangeSucceededEvent as any))
        );
      }

      case "BaseRefChangedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefChangedEvent") as any,
          new SelectionSet(select(BaseRefChangedEvent as any))
        );
      }

      case "BaseRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefDeletedEvent") as any,
          new SelectionSet(select(BaseRefDeletedEvent as any))
        );
      }

      case "BaseRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("BaseRefForcePushedEvent") as any,
          new SelectionSet(select(BaseRefForcePushedEvent as any))
        );
      }

      case "Blob": {
        return new InlineFragment(
          new NamedType("Blob") as any,
          new SelectionSet(select(Blob as any))
        );
      }

      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "BranchProtectionRule": {
        return new InlineFragment(
          new NamedType("BranchProtectionRule") as any,
          new SelectionSet(select(BranchProtectionRule as any))
        );
      }

      case "CheckRun": {
        return new InlineFragment(
          new NamedType("CheckRun") as any,
          new SelectionSet(select(CheckRun as any))
        );
      }

      case "CheckSuite": {
        return new InlineFragment(
          new NamedType("CheckSuite") as any,
          new SelectionSet(select(CheckSuite as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "CodeOfConduct": {
        return new InlineFragment(
          new NamedType("CodeOfConduct") as any,
          new SelectionSet(select(CodeOfConduct as any))
        );
      }

      case "CommentDeletedEvent": {
        return new InlineFragment(
          new NamedType("CommentDeletedEvent") as any,
          new SelectionSet(select(CommentDeletedEvent as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "CommitCommentThread": {
        return new InlineFragment(
          new NamedType("CommitCommentThread") as any,
          new SelectionSet(select(CommitCommentThread as any))
        );
      }

      case "ConnectedEvent": {
        return new InlineFragment(
          new NamedType("ConnectedEvent") as any,
          new SelectionSet(select(ConnectedEvent as any))
        );
      }

      case "ConvertToDraftEvent": {
        return new InlineFragment(
          new NamedType("ConvertToDraftEvent") as any,
          new SelectionSet(select(ConvertToDraftEvent as any))
        );
      }

      case "ConvertedNoteToIssueEvent": {
        return new InlineFragment(
          new NamedType("ConvertedNoteToIssueEvent") as any,
          new SelectionSet(select(ConvertedNoteToIssueEvent as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "DemilestonedEvent": {
        return new InlineFragment(
          new NamedType("DemilestonedEvent") as any,
          new SelectionSet(select(DemilestonedEvent as any))
        );
      }

      case "DeployKey": {
        return new InlineFragment(
          new NamedType("DeployKey") as any,
          new SelectionSet(select(DeployKey as any))
        );
      }

      case "DeployedEvent": {
        return new InlineFragment(
          new NamedType("DeployedEvent") as any,
          new SelectionSet(select(DeployedEvent as any))
        );
      }

      case "Deployment": {
        return new InlineFragment(
          new NamedType("Deployment") as any,
          new SelectionSet(select(Deployment as any))
        );
      }

      case "DeploymentEnvironmentChangedEvent": {
        return new InlineFragment(
          new NamedType("DeploymentEnvironmentChangedEvent") as any,
          new SelectionSet(select(DeploymentEnvironmentChangedEvent as any))
        );
      }

      case "DeploymentStatus": {
        return new InlineFragment(
          new NamedType("DeploymentStatus") as any,
          new SelectionSet(select(DeploymentStatus as any))
        );
      }

      case "DisconnectedEvent": {
        return new InlineFragment(
          new NamedType("DisconnectedEvent") as any,
          new SelectionSet(select(DisconnectedEvent as any))
        );
      }

      case "Enterprise": {
        return new InlineFragment(
          new NamedType("Enterprise") as any,
          new SelectionSet(select(Enterprise as any))
        );
      }

      case "EnterpriseAdministratorInvitation": {
        return new InlineFragment(
          new NamedType("EnterpriseAdministratorInvitation") as any,
          new SelectionSet(select(EnterpriseAdministratorInvitation as any))
        );
      }

      case "EnterpriseIdentityProvider": {
        return new InlineFragment(
          new NamedType("EnterpriseIdentityProvider") as any,
          new SelectionSet(select(EnterpriseIdentityProvider as any))
        );
      }

      case "EnterpriseRepositoryInfo": {
        return new InlineFragment(
          new NamedType("EnterpriseRepositoryInfo") as any,
          new SelectionSet(select(EnterpriseRepositoryInfo as any))
        );
      }

      case "EnterpriseServerInstallation": {
        return new InlineFragment(
          new NamedType("EnterpriseServerInstallation") as any,
          new SelectionSet(select(EnterpriseServerInstallation as any))
        );
      }

      case "EnterpriseServerUserAccount": {
        return new InlineFragment(
          new NamedType("EnterpriseServerUserAccount") as any,
          new SelectionSet(select(EnterpriseServerUserAccount as any))
        );
      }

      case "EnterpriseServerUserAccountEmail": {
        return new InlineFragment(
          new NamedType("EnterpriseServerUserAccountEmail") as any,
          new SelectionSet(select(EnterpriseServerUserAccountEmail as any))
        );
      }

      case "EnterpriseServerUserAccountsUpload": {
        return new InlineFragment(
          new NamedType("EnterpriseServerUserAccountsUpload") as any,
          new SelectionSet(select(EnterpriseServerUserAccountsUpload as any))
        );
      }

      case "EnterpriseUserAccount": {
        return new InlineFragment(
          new NamedType("EnterpriseUserAccount") as any,
          new SelectionSet(select(EnterpriseUserAccount as any))
        );
      }

      case "ExternalIdentity": {
        return new InlineFragment(
          new NamedType("ExternalIdentity") as any,
          new SelectionSet(select(ExternalIdentity as any))
        );
      }

      case "Gist": {
        return new InlineFragment(
          new NamedType("Gist") as any,
          new SelectionSet(select(Gist as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "HeadRefDeletedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefDeletedEvent") as any,
          new SelectionSet(select(HeadRefDeletedEvent as any))
        );
      }

      case "HeadRefForcePushedEvent": {
        return new InlineFragment(
          new NamedType("HeadRefForcePushedEvent") as any,
          new SelectionSet(select(HeadRefForcePushedEvent as any))
        );
      }

      case "HeadRefRestoredEvent": {
        return new InlineFragment(
          new NamedType("HeadRefRestoredEvent") as any,
          new SelectionSet(select(HeadRefRestoredEvent as any))
        );
      }

      case "IpAllowListEntry": {
        return new InlineFragment(
          new NamedType("IpAllowListEntry") as any,
          new SelectionSet(select(IpAllowListEntry as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "Label": {
        return new InlineFragment(
          new NamedType("Label") as any,
          new SelectionSet(select(Label as any))
        );
      }

      case "LabeledEvent": {
        return new InlineFragment(
          new NamedType("LabeledEvent") as any,
          new SelectionSet(select(LabeledEvent as any))
        );
      }

      case "Language": {
        return new InlineFragment(
          new NamedType("Language") as any,
          new SelectionSet(select(Language as any))
        );
      }

      case "License": {
        return new InlineFragment(
          new NamedType("License") as any,
          new SelectionSet(select(License as any))
        );
      }

      case "LockedEvent": {
        return new InlineFragment(
          new NamedType("LockedEvent") as any,
          new SelectionSet(select(LockedEvent as any))
        );
      }

      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "MarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("MarkedAsDuplicateEvent") as any,
          new SelectionSet(select(MarkedAsDuplicateEvent as any))
        );
      }

      case "MarketplaceCategory": {
        return new InlineFragment(
          new NamedType("MarketplaceCategory") as any,
          new SelectionSet(select(MarketplaceCategory as any))
        );
      }

      case "MarketplaceListing": {
        return new InlineFragment(
          new NamedType("MarketplaceListing") as any,
          new SelectionSet(select(MarketplaceListing as any))
        );
      }

      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "MentionedEvent": {
        return new InlineFragment(
          new NamedType("MentionedEvent") as any,
          new SelectionSet(select(MentionedEvent as any))
        );
      }

      case "MergedEvent": {
        return new InlineFragment(
          new NamedType("MergedEvent") as any,
          new SelectionSet(select(MergedEvent as any))
        );
      }

      case "Milestone": {
        return new InlineFragment(
          new NamedType("Milestone") as any,
          new SelectionSet(select(Milestone as any))
        );
      }

      case "MilestonedEvent": {
        return new InlineFragment(
          new NamedType("MilestonedEvent") as any,
          new SelectionSet(select(MilestonedEvent as any))
        );
      }

      case "MovedColumnsInProjectEvent": {
        return new InlineFragment(
          new NamedType("MovedColumnsInProjectEvent") as any,
          new SelectionSet(select(MovedColumnsInProjectEvent as any))
        );
      }

      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgAddBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgAddBillingManagerAuditEntry as any))
        );
      }

      case "OrgAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddMemberAuditEntry") as any,
          new SelectionSet(select(OrgAddMemberAuditEntry as any))
        );
      }

      case "OrgBlockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgBlockUserAuditEntry") as any,
          new SelectionSet(select(OrgBlockUserAuditEntry as any))
        );
      }

      case "OrgConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgCreateAuditEntry") as any,
          new SelectionSet(select(OrgCreateAuditEntry as any))
        );
      }

      case "OrgDisableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgDisableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableSamlAuditEntry") as any,
          new SelectionSet(select(OrgDisableSamlAuditEntry as any))
        );
      }

      case "OrgDisableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgEnableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgEnableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableSamlAuditEntry") as any,
          new SelectionSet(select(OrgEnableSamlAuditEntry as any))
        );
      }

      case "OrgEnableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgInviteMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteMemberAuditEntry") as any,
          new SelectionSet(select(OrgInviteMemberAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      case "OrgRemoveBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgRemoveBillingManagerAuditEntry as any))
        );
      }

      case "OrgRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveMemberAuditEntry") as any,
          new SelectionSet(select(OrgRemoveMemberAuditEntry as any))
        );
      }

      case "OrgRemoveOutsideCollaboratorAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveOutsideCollaboratorAuditEntry") as any,
          new SelectionSet(
            select(OrgRemoveOutsideCollaboratorAuditEntry as any)
          )
        );
      }

      case "OrgRestoreMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberAuditEntry") as any,
          new SelectionSet(select(OrgRestoreMemberAuditEntry as any))
        );
      }

      case "OrgUnblockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUnblockUserAuditEntry") as any,
          new SelectionSet(select(OrgUnblockUserAuditEntry as any))
        );
      }

      case "OrgUpdateDefaultRepositoryPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateDefaultRepositoryPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateDefaultRepositoryPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUpdateMemberAuditEntry") as any,
          new SelectionSet(select(OrgUpdateMemberAuditEntry as any))
        );
      }

      case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateMemberRepositoryCreationPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(
              OrgUpdateMemberRepositoryInvitationPermissionAuditEntry as any
            )
          )
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "OrganizationIdentityProvider": {
        return new InlineFragment(
          new NamedType("OrganizationIdentityProvider") as any,
          new SelectionSet(select(OrganizationIdentityProvider as any))
        );
      }

      case "OrganizationInvitation": {
        return new InlineFragment(
          new NamedType("OrganizationInvitation") as any,
          new SelectionSet(select(OrganizationInvitation as any))
        );
      }

      case "Package": {
        return new InlineFragment(
          new NamedType("Package") as any,
          new SelectionSet(select(Package as any))
        );
      }

      case "PackageFile": {
        return new InlineFragment(
          new NamedType("PackageFile") as any,
          new SelectionSet(select(PackageFile as any))
        );
      }

      case "PackageTag": {
        return new InlineFragment(
          new NamedType("PackageTag") as any,
          new SelectionSet(select(PackageTag as any))
        );
      }

      case "PackageVersion": {
        return new InlineFragment(
          new NamedType("PackageVersion") as any,
          new SelectionSet(select(PackageVersion as any))
        );
      }

      case "PinnedEvent": {
        return new InlineFragment(
          new NamedType("PinnedEvent") as any,
          new SelectionSet(select(PinnedEvent as any))
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "Project": {
        return new InlineFragment(
          new NamedType("Project") as any,
          new SelectionSet(select(Project as any))
        );
      }

      case "ProjectCard": {
        return new InlineFragment(
          new NamedType("ProjectCard") as any,
          new SelectionSet(select(ProjectCard as any))
        );
      }

      case "ProjectColumn": {
        return new InlineFragment(
          new NamedType("ProjectColumn") as any,
          new SelectionSet(select(ProjectColumn as any))
        );
      }

      case "PublicKey": {
        return new InlineFragment(
          new NamedType("PublicKey") as any,
          new SelectionSet(select(PublicKey as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestCommit": {
        return new InlineFragment(
          new NamedType("PullRequestCommit") as any,
          new SelectionSet(select(PullRequestCommit as any))
        );
      }

      case "PullRequestCommitCommentThread": {
        return new InlineFragment(
          new NamedType("PullRequestCommitCommentThread") as any,
          new SelectionSet(select(PullRequestCommitCommentThread as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "PullRequestReviewThread": {
        return new InlineFragment(
          new NamedType("PullRequestReviewThread") as any,
          new SelectionSet(select(PullRequestReviewThread as any))
        );
      }

      case "Push": {
        return new InlineFragment(
          new NamedType("Push") as any,
          new SelectionSet(select(Push as any))
        );
      }

      case "PushAllowance": {
        return new InlineFragment(
          new NamedType("PushAllowance") as any,
          new SelectionSet(select(PushAllowance as any))
        );
      }

      case "Reaction": {
        return new InlineFragment(
          new NamedType("Reaction") as any,
          new SelectionSet(select(Reaction as any))
        );
      }

      case "ReadyForReviewEvent": {
        return new InlineFragment(
          new NamedType("ReadyForReviewEvent") as any,
          new SelectionSet(select(ReadyForReviewEvent as any))
        );
      }

      case "Ref": {
        return new InlineFragment(
          new NamedType("Ref") as any,
          new SelectionSet(select(Ref as any))
        );
      }

      case "ReferencedEvent": {
        return new InlineFragment(
          new NamedType("ReferencedEvent") as any,
          new SelectionSet(select(ReferencedEvent as any))
        );
      }

      case "Release": {
        return new InlineFragment(
          new NamedType("Release") as any,
          new SelectionSet(select(Release as any))
        );
      }

      case "ReleaseAsset": {
        return new InlineFragment(
          new NamedType("ReleaseAsset") as any,
          new SelectionSet(select(ReleaseAsset as any))
        );
      }

      case "RemovedFromProjectEvent": {
        return new InlineFragment(
          new NamedType("RemovedFromProjectEvent") as any,
          new SelectionSet(select(RemovedFromProjectEvent as any))
        );
      }

      case "RenamedTitleEvent": {
        return new InlineFragment(
          new NamedType("RenamedTitleEvent") as any,
          new SelectionSet(select(RenamedTitleEvent as any))
        );
      }

      case "ReopenedEvent": {
        return new InlineFragment(
          new NamedType("ReopenedEvent") as any,
          new SelectionSet(select(ReopenedEvent as any))
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "RepositoryInvitation": {
        return new InlineFragment(
          new NamedType("RepositoryInvitation") as any,
          new SelectionSet(select(RepositoryInvitation as any))
        );
      }

      case "RepositoryTopic": {
        return new InlineFragment(
          new NamedType("RepositoryTopic") as any,
          new SelectionSet(select(RepositoryTopic as any))
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      case "RepositoryVulnerabilityAlert": {
        return new InlineFragment(
          new NamedType("RepositoryVulnerabilityAlert") as any,
          new SelectionSet(select(RepositoryVulnerabilityAlert as any))
        );
      }

      case "ReviewDismissalAllowance": {
        return new InlineFragment(
          new NamedType("ReviewDismissalAllowance") as any,
          new SelectionSet(select(ReviewDismissalAllowance as any))
        );
      }

      case "ReviewDismissedEvent": {
        return new InlineFragment(
          new NamedType("ReviewDismissedEvent") as any,
          new SelectionSet(select(ReviewDismissedEvent as any))
        );
      }

      case "ReviewRequest": {
        return new InlineFragment(
          new NamedType("ReviewRequest") as any,
          new SelectionSet(select(ReviewRequest as any))
        );
      }

      case "ReviewRequestRemovedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestRemovedEvent") as any,
          new SelectionSet(select(ReviewRequestRemovedEvent as any))
        );
      }

      case "ReviewRequestedEvent": {
        return new InlineFragment(
          new NamedType("ReviewRequestedEvent") as any,
          new SelectionSet(select(ReviewRequestedEvent as any))
        );
      }

      case "SavedReply": {
        return new InlineFragment(
          new NamedType("SavedReply") as any,
          new SelectionSet(select(SavedReply as any))
        );
      }

      case "SecurityAdvisory": {
        return new InlineFragment(
          new NamedType("SecurityAdvisory") as any,
          new SelectionSet(select(SecurityAdvisory as any))
        );
      }

      case "SponsorsListing": {
        return new InlineFragment(
          new NamedType("SponsorsListing") as any,
          new SelectionSet(select(SponsorsListing as any))
        );
      }

      case "SponsorsTier": {
        return new InlineFragment(
          new NamedType("SponsorsTier") as any,
          new SelectionSet(select(SponsorsTier as any))
        );
      }

      case "Sponsorship": {
        return new InlineFragment(
          new NamedType("Sponsorship") as any,
          new SelectionSet(select(Sponsorship as any))
        );
      }

      case "Status": {
        return new InlineFragment(
          new NamedType("Status") as any,
          new SelectionSet(select(Status as any))
        );
      }

      case "StatusCheckRollup": {
        return new InlineFragment(
          new NamedType("StatusCheckRollup") as any,
          new SelectionSet(select(StatusCheckRollup as any))
        );
      }

      case "StatusContext": {
        return new InlineFragment(
          new NamedType("StatusContext") as any,
          new SelectionSet(select(StatusContext as any))
        );
      }

      case "SubscribedEvent": {
        return new InlineFragment(
          new NamedType("SubscribedEvent") as any,
          new SelectionSet(select(SubscribedEvent as any))
        );
      }

      case "Tag": {
        return new InlineFragment(
          new NamedType("Tag") as any,
          new SelectionSet(select(Tag as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      case "Topic": {
        return new InlineFragment(
          new NamedType("Topic") as any,
          new SelectionSet(select(Topic as any))
        );
      }

      case "TransferredEvent": {
        return new InlineFragment(
          new NamedType("TransferredEvent") as any,
          new SelectionSet(select(TransferredEvent as any))
        );
      }

      case "Tree": {
        return new InlineFragment(
          new NamedType("Tree") as any,
          new SelectionSet(select(Tree as any))
        );
      }

      case "UnassignedEvent": {
        return new InlineFragment(
          new NamedType("UnassignedEvent") as any,
          new SelectionSet(select(UnassignedEvent as any))
        );
      }

      case "UnlabeledEvent": {
        return new InlineFragment(
          new NamedType("UnlabeledEvent") as any,
          new SelectionSet(select(UnlabeledEvent as any))
        );
      }

      case "UnlockedEvent": {
        return new InlineFragment(
          new NamedType("UnlockedEvent") as any,
          new SelectionSet(select(UnlockedEvent as any))
        );
      }

      case "UnmarkedAsDuplicateEvent": {
        return new InlineFragment(
          new NamedType("UnmarkedAsDuplicateEvent") as any,
          new SelectionSet(select(UnmarkedAsDuplicateEvent as any))
        );
      }

      case "UnpinnedEvent": {
        return new InlineFragment(
          new NamedType("UnpinnedEvent") as any,
          new SelectionSet(select(UnpinnedEvent as any))
        );
      }

      case "UnsubscribedEvent": {
        return new InlineFragment(
          new NamedType("UnsubscribedEvent") as any,
          new SelectionSet(select(UnsubscribedEvent as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      case "UserBlockedEvent": {
        return new InlineFragment(
          new NamedType("UserBlockedEvent") as any,
          new SelectionSet(select(UserBlockedEvent as any))
        );
      }

      case "UserContentEdit": {
        return new InlineFragment(
          new NamedType("UserContentEdit") as any,
          new SelectionSet(select(UserContentEdit as any))
        );
      }

      case "UserStatus": {
        return new InlineFragment(
          new NamedType("UserStatus") as any,
          new SelectionSet(select(UserStatus as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IOauthApplicationAuditEntryData {
  __typename: string;
  oauthApplicationName: string;
  oauthApplicationResourcePath: unknown;
  oauthApplicationUrl: unknown;
}

interface OauthApplicationAuditEntryDataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The name of the OAuth Application.
   */

  oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  on: <
    T extends Array<Selection>,
    F extends
      | "OauthApplicationCreateAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const OauthApplicationAuditEntryData: OauthApplicationAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  on: (type, select) => {
    switch (type) {
      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IOauthApplicationCreateAuditEntry
  extends IAuditEntry,
    INode,
    IOauthApplicationAuditEntryData,
    IOrganizationAuditEntryData {
  __typename: "OauthApplicationCreateAuditEntry";
  applicationUrl: unknown;
  callbackUrl: unknown;
  rateLimit: number;
  state: OauthApplicationCreateAuditEntryState;
}

interface OauthApplicationCreateAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The application URL of the OAuth Application.
   */

  applicationUrl: () => Field<"applicationUrl">;

  /**
   * @description The callback URL of the OAuth Application.
   */

  callbackUrl: () => Field<"callbackUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The name of the OAuth Application.
   */

  oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The rate limit of the OAuth Application.
   */

  rateLimit: () => Field<"rateLimit">;

  /**
   * @description The state of the OAuth Application.
   */

  state: () => Field<"state">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOauthApplicationCreateAuditEntry = (
  object: Record<string, any>
): object is Partial<IOauthApplicationCreateAuditEntry> => {
  return object.__typename === "OauthApplicationCreateAuditEntry";
};

export const OauthApplicationCreateAuditEntry: OauthApplicationCreateAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The application URL of the OAuth Application.
   */
  applicationUrl: () => new Field("applicationUrl"),

  /**
   * @description The callback URL of the OAuth Application.
   */
  callbackUrl: () => new Field("callbackUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The rate limit of the OAuth Application.
   */
  rateLimit: () => new Field("rateLimit"),

  /**
   * @description The state of the OAuth Application.
   */
  state: () => new Field("state"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgAddBillingManagerAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgAddBillingManagerAuditEntry";
  invitationEmail: string;
}

interface OrgAddBillingManagerAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The email address used to invite a billing manager for the organization.
   */

  invitationEmail: () => Field<"invitationEmail">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgAddBillingManagerAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgAddBillingManagerAuditEntry> => {
  return object.__typename === "OrgAddBillingManagerAuditEntry";
};

export const OrgAddBillingManagerAuditEntry: OrgAddBillingManagerAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The email address used to invite a billing manager for the organization.
   */
  invitationEmail: () => new Field("invitationEmail"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgAddMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgAddMemberAuditEntry";
  permission: OrgAddMemberAuditEntryPermission;
}

interface OrgAddMemberAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The permission level of the member added to the organization.
   */

  permission: () => Field<"permission">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgAddMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgAddMemberAuditEntry> => {
  return object.__typename === "OrgAddMemberAuditEntry";
};

export const OrgAddMemberAuditEntry: OrgAddMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The permission level of the member added to the organization.
   */
  permission: () => new Field("permission"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgBlockUserAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgBlockUserAuditEntry";
  blockedUser: IUser;
  blockedUserName: string;
  blockedUserResourcePath: unknown;
  blockedUserUrl: unknown;
}

interface OrgBlockUserAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The blocked user.
   */

  blockedUser: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"blockedUser", never, SelectionSet<T>>;

  /**
   * @description The username of the blocked user.
   */

  blockedUserName: () => Field<"blockedUserName">;

  /**
   * @description The HTTP path for the blocked user.
   */

  blockedUserResourcePath: () => Field<"blockedUserResourcePath">;

  /**
   * @description The HTTP URL for the blocked user.
   */

  blockedUserUrl: () => Field<"blockedUserUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgBlockUserAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgBlockUserAuditEntry> => {
  return object.__typename === "OrgBlockUserAuditEntry";
};

export const OrgBlockUserAuditEntry: OrgBlockUserAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The blocked user.
   */

  blockedUser: (select) =>
    new Field(
      "blockedUser",
      undefined as never,
      new SelectionSet(select(User))
    ),

  /**
   * @description The username of the blocked user.
   */
  blockedUserName: () => new Field("blockedUserName"),

  /**
   * @description The HTTP path for the blocked user.
   */
  blockedUserResourcePath: () => new Field("blockedUserResourcePath"),

  /**
   * @description The HTTP URL for the blocked user.
   */
  blockedUserUrl: () => new Field("blockedUserUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgConfigDisableCollaboratorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgConfigDisableCollaboratorsOnlyAuditEntry";
}

interface OrgConfigDisableCollaboratorsOnlyAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgConfigDisableCollaboratorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgConfigDisableCollaboratorsOnlyAuditEntry> => {
  return object.__typename === "OrgConfigDisableCollaboratorsOnlyAuditEntry";
};

export const OrgConfigDisableCollaboratorsOnlyAuditEntry: OrgConfigDisableCollaboratorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgConfigEnableCollaboratorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgConfigEnableCollaboratorsOnlyAuditEntry";
}

interface OrgConfigEnableCollaboratorsOnlyAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgConfigEnableCollaboratorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgConfigEnableCollaboratorsOnlyAuditEntry> => {
  return object.__typename === "OrgConfigEnableCollaboratorsOnlyAuditEntry";
};

export const OrgConfigEnableCollaboratorsOnlyAuditEntry: OrgConfigEnableCollaboratorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgCreateAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgCreateAuditEntry";
  billingPlan: OrgCreateAuditEntryBillingPlan;
}

interface OrgCreateAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The billing plan for the Organization.
   */

  billingPlan: () => Field<"billingPlan">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgCreateAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgCreateAuditEntry> => {
  return object.__typename === "OrgCreateAuditEntry";
};

export const OrgCreateAuditEntry: OrgCreateAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The billing plan for the Organization.
   */
  billingPlan: () => new Field("billingPlan"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgDisableOauthAppRestrictionsAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgDisableOauthAppRestrictionsAuditEntry";
}

interface OrgDisableOauthAppRestrictionsAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgDisableOauthAppRestrictionsAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgDisableOauthAppRestrictionsAuditEntry> => {
  return object.__typename === "OrgDisableOauthAppRestrictionsAuditEntry";
};

export const OrgDisableOauthAppRestrictionsAuditEntry: OrgDisableOauthAppRestrictionsAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgDisableSamlAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgDisableSamlAuditEntry";
  digestMethodUrl: unknown;
  issuerUrl: unknown;
  signatureMethodUrl: unknown;
  singleSignOnUrl: unknown;
}

interface OrgDisableSamlAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The SAML provider's digest algorithm URL.
   */

  digestMethodUrl: () => Field<"digestMethodUrl">;

  id: () => Field<"id">;

  /**
   * @description The SAML provider's issuer URL.
   */

  issuerUrl: () => Field<"issuerUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The SAML provider's signature algorithm URL.
   */

  signatureMethodUrl: () => Field<"signatureMethodUrl">;

  /**
   * @description The SAML provider's single sign-on URL.
   */

  singleSignOnUrl: () => Field<"singleSignOnUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgDisableSamlAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgDisableSamlAuditEntry> => {
  return object.__typename === "OrgDisableSamlAuditEntry";
};

export const OrgDisableSamlAuditEntry: OrgDisableSamlAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The SAML provider's digest algorithm URL.
   */
  digestMethodUrl: () => new Field("digestMethodUrl"),
  id: () => new Field("id"),

  /**
   * @description The SAML provider's issuer URL.
   */
  issuerUrl: () => new Field("issuerUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The SAML provider's signature algorithm URL.
   */
  signatureMethodUrl: () => new Field("signatureMethodUrl"),

  /**
   * @description The SAML provider's single sign-on URL.
   */
  singleSignOnUrl: () => new Field("singleSignOnUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgDisableTwoFactorRequirementAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgDisableTwoFactorRequirementAuditEntry";
}

interface OrgDisableTwoFactorRequirementAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgDisableTwoFactorRequirementAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgDisableTwoFactorRequirementAuditEntry> => {
  return object.__typename === "OrgDisableTwoFactorRequirementAuditEntry";
};

export const OrgDisableTwoFactorRequirementAuditEntry: OrgDisableTwoFactorRequirementAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgEnableOauthAppRestrictionsAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgEnableOauthAppRestrictionsAuditEntry";
}

interface OrgEnableOauthAppRestrictionsAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgEnableOauthAppRestrictionsAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgEnableOauthAppRestrictionsAuditEntry> => {
  return object.__typename === "OrgEnableOauthAppRestrictionsAuditEntry";
};

export const OrgEnableOauthAppRestrictionsAuditEntry: OrgEnableOauthAppRestrictionsAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgEnableSamlAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgEnableSamlAuditEntry";
  digestMethodUrl: unknown;
  issuerUrl: unknown;
  signatureMethodUrl: unknown;
  singleSignOnUrl: unknown;
}

interface OrgEnableSamlAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The SAML provider's digest algorithm URL.
   */

  digestMethodUrl: () => Field<"digestMethodUrl">;

  id: () => Field<"id">;

  /**
   * @description The SAML provider's issuer URL.
   */

  issuerUrl: () => Field<"issuerUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The SAML provider's signature algorithm URL.
   */

  signatureMethodUrl: () => Field<"signatureMethodUrl">;

  /**
   * @description The SAML provider's single sign-on URL.
   */

  singleSignOnUrl: () => Field<"singleSignOnUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgEnableSamlAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgEnableSamlAuditEntry> => {
  return object.__typename === "OrgEnableSamlAuditEntry";
};

export const OrgEnableSamlAuditEntry: OrgEnableSamlAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The SAML provider's digest algorithm URL.
   */
  digestMethodUrl: () => new Field("digestMethodUrl"),
  id: () => new Field("id"),

  /**
   * @description The SAML provider's issuer URL.
   */
  issuerUrl: () => new Field("issuerUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The SAML provider's signature algorithm URL.
   */
  signatureMethodUrl: () => new Field("signatureMethodUrl"),

  /**
   * @description The SAML provider's single sign-on URL.
   */
  singleSignOnUrl: () => new Field("singleSignOnUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgEnableTwoFactorRequirementAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgEnableTwoFactorRequirementAuditEntry";
}

interface OrgEnableTwoFactorRequirementAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgEnableTwoFactorRequirementAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgEnableTwoFactorRequirementAuditEntry> => {
  return object.__typename === "OrgEnableTwoFactorRequirementAuditEntry";
};

export const OrgEnableTwoFactorRequirementAuditEntry: OrgEnableTwoFactorRequirementAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgInviteMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgInviteMemberAuditEntry";
  email: string;
  organizationInvitation: IOrganizationInvitation;
}

interface OrgInviteMemberAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The email address of the organization invitation.
   */

  email: () => Field<"email">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The organization invitation.
   */

  organizationInvitation: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"organizationInvitation", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgInviteMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgInviteMemberAuditEntry> => {
  return object.__typename === "OrgInviteMemberAuditEntry";
};

export const OrgInviteMemberAuditEntry: OrgInviteMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The email address of the organization invitation.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The organization invitation.
   */

  organizationInvitation: (select) =>
    new Field(
      "organizationInvitation",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgInviteToBusinessAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgInviteToBusinessAuditEntry";
}

interface OrgInviteToBusinessAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  enterpriseUrl: () => Field<"enterpriseUrl">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgInviteToBusinessAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgInviteToBusinessAuditEntry> => {
  return object.__typename === "OrgInviteToBusinessAuditEntry";
};

export const OrgInviteToBusinessAuditEntry: OrgInviteToBusinessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgOauthAppAccessApprovedAuditEntry
  extends IAuditEntry,
    INode,
    IOauthApplicationAuditEntryData,
    IOrganizationAuditEntryData {
  __typename: "OrgOauthAppAccessApprovedAuditEntry";
}

interface OrgOauthAppAccessApprovedAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The name of the OAuth Application.
   */

  oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgOauthAppAccessApprovedAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgOauthAppAccessApprovedAuditEntry> => {
  return object.__typename === "OrgOauthAppAccessApprovedAuditEntry";
};

export const OrgOauthAppAccessApprovedAuditEntry: OrgOauthAppAccessApprovedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgOauthAppAccessDeniedAuditEntry
  extends IAuditEntry,
    INode,
    IOauthApplicationAuditEntryData,
    IOrganizationAuditEntryData {
  __typename: "OrgOauthAppAccessDeniedAuditEntry";
}

interface OrgOauthAppAccessDeniedAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The name of the OAuth Application.
   */

  oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgOauthAppAccessDeniedAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgOauthAppAccessDeniedAuditEntry> => {
  return object.__typename === "OrgOauthAppAccessDeniedAuditEntry";
};

export const OrgOauthAppAccessDeniedAuditEntry: OrgOauthAppAccessDeniedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgOauthAppAccessRequestedAuditEntry
  extends IAuditEntry,
    INode,
    IOauthApplicationAuditEntryData,
    IOrganizationAuditEntryData {
  __typename: "OrgOauthAppAccessRequestedAuditEntry";
}

interface OrgOauthAppAccessRequestedAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The name of the OAuth Application.
   */

  oauthApplicationName: () => Field<"oauthApplicationName">;

  /**
   * @description The HTTP path for the OAuth Application
   */

  oauthApplicationResourcePath: () => Field<"oauthApplicationResourcePath">;

  /**
   * @description The HTTP URL for the OAuth Application
   */

  oauthApplicationUrl: () => Field<"oauthApplicationUrl">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgOauthAppAccessRequestedAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgOauthAppAccessRequestedAuditEntry> => {
  return object.__typename === "OrgOauthAppAccessRequestedAuditEntry";
};

export const OrgOauthAppAccessRequestedAuditEntry: OrgOauthAppAccessRequestedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The name of the OAuth Application.
   */
  oauthApplicationName: () => new Field("oauthApplicationName"),

  /**
   * @description The HTTP path for the OAuth Application
   */
  oauthApplicationResourcePath: () => new Field("oauthApplicationResourcePath"),

  /**
   * @description The HTTP URL for the OAuth Application
   */
  oauthApplicationUrl: () => new Field("oauthApplicationUrl"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRemoveBillingManagerAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgRemoveBillingManagerAuditEntry";
  reason: OrgRemoveBillingManagerAuditEntryReason;
}

interface OrgRemoveBillingManagerAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The reason for the billing manager being removed.
   */

  reason: () => Field<"reason">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgRemoveBillingManagerAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgRemoveBillingManagerAuditEntry> => {
  return object.__typename === "OrgRemoveBillingManagerAuditEntry";
};

export const OrgRemoveBillingManagerAuditEntry: OrgRemoveBillingManagerAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The reason for the billing manager being removed.
   */
  reason: () => new Field("reason"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRemoveMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgRemoveMemberAuditEntry";
  membershipTypes: OrgRemoveMemberAuditEntryMembershipType[];
  reason: OrgRemoveMemberAuditEntryReason;
}

interface OrgRemoveMemberAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The types of membership the member has with the organization.
   */

  membershipTypes: () => Field<"membershipTypes">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The reason for the member being removed.
   */

  reason: () => Field<"reason">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgRemoveMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgRemoveMemberAuditEntry> => {
  return object.__typename === "OrgRemoveMemberAuditEntry";
};

export const OrgRemoveMemberAuditEntry: OrgRemoveMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The types of membership the member has with the organization.
   */
  membershipTypes: () => new Field("membershipTypes"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The reason for the member being removed.
   */
  reason: () => new Field("reason"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRemoveOutsideCollaboratorAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgRemoveOutsideCollaboratorAuditEntry";
  membershipTypes: OrgRemoveOutsideCollaboratorAuditEntryMembershipType[];
  reason: OrgRemoveOutsideCollaboratorAuditEntryReason;
}

interface OrgRemoveOutsideCollaboratorAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The types of membership the outside collaborator has with the organization.
   */

  membershipTypes: () => Field<"membershipTypes">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The reason for the outside collaborator being removed from the Organization.
   */

  reason: () => Field<"reason">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgRemoveOutsideCollaboratorAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgRemoveOutsideCollaboratorAuditEntry> => {
  return object.__typename === "OrgRemoveOutsideCollaboratorAuditEntry";
};

export const OrgRemoveOutsideCollaboratorAuditEntry: OrgRemoveOutsideCollaboratorAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The types of membership the outside collaborator has with the organization.
   */
  membershipTypes: () => new Field("membershipTypes"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The reason for the outside collaborator being removed from the Organization.
   */
  reason: () => new Field("reason"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRestoreMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgRestoreMemberAuditEntry";
  restoredCustomEmailRoutingsCount: number;
  restoredIssueAssignmentsCount: number;
  restoredMemberships: IOrgRestoreMemberAuditEntryMembership[];
  restoredMembershipsCount: number;
  restoredRepositoriesCount: number;
  restoredRepositoryStarsCount: number;
  restoredRepositoryWatchesCount: number;
}

interface OrgRestoreMemberAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The number of custom email routings for the restored member.
   */

  restoredCustomEmailRoutingsCount: () => Field<"restoredCustomEmailRoutingsCount">;

  /**
   * @description The number of issue assignemnts for the restored member.
   */

  restoredIssueAssignmentsCount: () => Field<"restoredIssueAssignmentsCount">;

  /**
   * @description Restored organization membership objects.
   */

  restoredMemberships: <T extends Array<Selection>>(
    select: (t: OrgRestoreMemberAuditEntryMembershipSelector) => T
  ) => Field<"restoredMemberships", never, SelectionSet<T>>;

  /**
   * @description The number of restored memberships.
   */

  restoredMembershipsCount: () => Field<"restoredMembershipsCount">;

  /**
   * @description The number of repositories of the restored member.
   */

  restoredRepositoriesCount: () => Field<"restoredRepositoriesCount">;

  /**
   * @description The number of starred repositories for the restored member.
   */

  restoredRepositoryStarsCount: () => Field<"restoredRepositoryStarsCount">;

  /**
   * @description The number of watched repositories for the restored member.
   */

  restoredRepositoryWatchesCount: () => Field<"restoredRepositoryWatchesCount">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgRestoreMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgRestoreMemberAuditEntry> => {
  return object.__typename === "OrgRestoreMemberAuditEntry";
};

export const OrgRestoreMemberAuditEntry: OrgRestoreMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The number of custom email routings for the restored member.
   */
  restoredCustomEmailRoutingsCount: () =>
    new Field("restoredCustomEmailRoutingsCount"),

  /**
   * @description The number of issue assignemnts for the restored member.
   */
  restoredIssueAssignmentsCount: () =>
    new Field("restoredIssueAssignmentsCount"),

  /**
   * @description Restored organization membership objects.
   */

  restoredMemberships: (select) =>
    new Field(
      "restoredMemberships",
      undefined as never,
      new SelectionSet(select(OrgRestoreMemberAuditEntryMembership))
    ),

  /**
   * @description The number of restored memberships.
   */
  restoredMembershipsCount: () => new Field("restoredMembershipsCount"),

  /**
   * @description The number of repositories of the restored member.
   */
  restoredRepositoriesCount: () => new Field("restoredRepositoriesCount"),

  /**
   * @description The number of starred repositories for the restored member.
   */
  restoredRepositoryStarsCount: () => new Field("restoredRepositoryStarsCount"),

  /**
   * @description The number of watched repositories for the restored member.
   */
  restoredRepositoryWatchesCount: () =>
    new Field("restoredRepositoryWatchesCount"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgRestoreMemberMembershipOrganizationAuditEntryData
  extends IOrganizationAuditEntryData {
  __typename: "OrgRestoreMemberMembershipOrganizationAuditEntryData";
}

interface OrgRestoreMemberMembershipOrganizationAuditEntryDataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;
}

export const isOrgRestoreMemberMembershipOrganizationAuditEntryData = (
  object: Record<string, any>
): object is Partial<IOrgRestoreMemberMembershipOrganizationAuditEntryData> => {
  return (
    object.__typename === "OrgRestoreMemberMembershipOrganizationAuditEntryData"
  );
};

export const OrgRestoreMemberMembershipOrganizationAuditEntryData: OrgRestoreMemberMembershipOrganizationAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),
};

export interface IOrgRestoreMemberMembershipRepositoryAuditEntryData
  extends IRepositoryAuditEntryData {
  __typename: "OrgRestoreMemberMembershipRepositoryAuditEntryData";
}

interface OrgRestoreMemberMembershipRepositoryAuditEntryDataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;
}

export const isOrgRestoreMemberMembershipRepositoryAuditEntryData = (
  object: Record<string, any>
): object is Partial<IOrgRestoreMemberMembershipRepositoryAuditEntryData> => {
  return (
    object.__typename === "OrgRestoreMemberMembershipRepositoryAuditEntryData"
  );
};

export const OrgRestoreMemberMembershipRepositoryAuditEntryData: OrgRestoreMemberMembershipRepositoryAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),
};

export interface IOrgRestoreMemberMembershipTeamAuditEntryData
  extends ITeamAuditEntryData {
  __typename: "OrgRestoreMemberMembershipTeamAuditEntryData";
}

interface OrgRestoreMemberMembershipTeamAuditEntryDataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The team associated with the action
   */

  team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  teamUrl: () => Field<"teamUrl">;
}

export const isOrgRestoreMemberMembershipTeamAuditEntryData = (
  object: Record<string, any>
): object is Partial<IOrgRestoreMemberMembershipTeamAuditEntryData> => {
  return object.__typename === "OrgRestoreMemberMembershipTeamAuditEntryData";
};

export const OrgRestoreMemberMembershipTeamAuditEntryData: OrgRestoreMemberMembershipTeamAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),
};

export interface IOrgUnblockUserAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgUnblockUserAuditEntry";
  blockedUser: IUser;
  blockedUserName: string;
  blockedUserResourcePath: unknown;
  blockedUserUrl: unknown;
}

interface OrgUnblockUserAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The user being unblocked by the organization.
   */

  blockedUser: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"blockedUser", never, SelectionSet<T>>;

  /**
   * @description The username of the blocked user.
   */

  blockedUserName: () => Field<"blockedUserName">;

  /**
   * @description The HTTP path for the blocked user.
   */

  blockedUserResourcePath: () => Field<"blockedUserResourcePath">;

  /**
   * @description The HTTP URL for the blocked user.
   */

  blockedUserUrl: () => Field<"blockedUserUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgUnblockUserAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUnblockUserAuditEntry> => {
  return object.__typename === "OrgUnblockUserAuditEntry";
};

export const OrgUnblockUserAuditEntry: OrgUnblockUserAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The user being unblocked by the organization.
   */

  blockedUser: (select) =>
    new Field(
      "blockedUser",
      undefined as never,
      new SelectionSet(select(User))
    ),

  /**
   * @description The username of the blocked user.
   */
  blockedUserName: () => new Field("blockedUserName"),

  /**
   * @description The HTTP path for the blocked user.
   */
  blockedUserResourcePath: () => new Field("blockedUserResourcePath"),

  /**
   * @description The HTTP URL for the blocked user.
   */
  blockedUserUrl: () => new Field("blockedUserUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgUpdateDefaultRepositoryPermissionAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgUpdateDefaultRepositoryPermissionAuditEntry";
  permission: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission;
  permissionWas: OrgUpdateDefaultRepositoryPermissionAuditEntryPermission;
}

interface OrgUpdateDefaultRepositoryPermissionAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The new default repository permission level for the organization.
   */

  permission: () => Field<"permission">;

  /**
   * @description The former default repository permission level for the organization.
   */

  permissionWas: () => Field<"permissionWas">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgUpdateDefaultRepositoryPermissionAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUpdateDefaultRepositoryPermissionAuditEntry> => {
  return object.__typename === "OrgUpdateDefaultRepositoryPermissionAuditEntry";
};

export const OrgUpdateDefaultRepositoryPermissionAuditEntry: OrgUpdateDefaultRepositoryPermissionAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The new default repository permission level for the organization.
   */
  permission: () => new Field("permission"),

  /**
   * @description The former default repository permission level for the organization.
   */
  permissionWas: () => new Field("permissionWas"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgUpdateMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgUpdateMemberAuditEntry";
  permission: OrgUpdateMemberAuditEntryPermission;
  permissionWas: OrgUpdateMemberAuditEntryPermission;
}

interface OrgUpdateMemberAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The new member permission level for the organization.
   */

  permission: () => Field<"permission">;

  /**
   * @description The former member permission level for the organization.
   */

  permissionWas: () => Field<"permissionWas">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgUpdateMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUpdateMemberAuditEntry> => {
  return object.__typename === "OrgUpdateMemberAuditEntry";
};

export const OrgUpdateMemberAuditEntry: OrgUpdateMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The new member permission level for the organization.
   */
  permission: () => new Field("permission"),

  /**
   * @description The former member permission level for the organization.
   */
  permissionWas: () => new Field("permissionWas"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrgUpdateMemberRepositoryCreationPermissionAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgUpdateMemberRepositoryCreationPermissionAuditEntry";
  canCreateRepositories: boolean;
  visibility: OrgUpdateMemberRepositoryCreationPermissionAuditEntryVisibility;
}

interface OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description Can members create repositories in the organization.
   */

  canCreateRepositories: () => Field<"canCreateRepositories">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;

  /**
   * @description The permission for visibility level of repositories for this organization.
   */

  visibility: () => Field<"visibility">;
}

export const isOrgUpdateMemberRepositoryCreationPermissionAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUpdateMemberRepositoryCreationPermissionAuditEntry> => {
  return (
    object.__typename ===
    "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
  );
};

export const OrgUpdateMemberRepositoryCreationPermissionAuditEntry: OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description Can members create repositories in the organization.
   */
  canCreateRepositories: () => new Field("canCreateRepositories"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The permission for visibility level of repositories for this organization.
   */
  visibility: () => new Field("visibility"),
};

export interface IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData {
  __typename: "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry";
  canInviteOutsideCollaboratorsToRepositories: boolean;
}

interface OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description Can outside collaborators be invited to repositories in the organization.
   */

  canInviteOutsideCollaboratorsToRepositories: () => Field<"canInviteOutsideCollaboratorsToRepositories">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isOrgUpdateMemberRepositoryInvitationPermissionAuditEntry = (
  object: Record<string, any>
): object is Partial<IOrgUpdateMemberRepositoryInvitationPermissionAuditEntry> => {
  return (
    object.__typename ===
    "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
  );
};

export const OrgUpdateMemberRepositoryInvitationPermissionAuditEntry: OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description Can outside collaborators be invited to repositories in the organization.
   */
  canInviteOutsideCollaboratorsToRepositories: () =>
    new Field("canInviteOutsideCollaboratorsToRepositories"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IOrganization
  extends IActor,
    IMemberStatusable,
    INode,
    IPackageOwner,
    IProfileOwner,
    IProjectOwner,
    IRepositoryOwner,
    ISponsorable,
    IUniformResourceLocatable {
  __typename: "Organization";
  auditLog: IOrganizationAuditEntryConnection;
  createdAt: unknown;
  databaseId: number;
  description: string;
  descriptionHTML: string;
  interactionAbility: IRepositoryInteractionAbility;
  ipAllowListEnabledSetting: IpAllowListEnabledSettingValue;
  ipAllowListEntries: IIpAllowListEntryConnection;
  isVerified: boolean;
  membersWithRole: IOrganizationMemberConnection;
  newTeamResourcePath: unknown;
  newTeamUrl: unknown;
  organizationBillingEmail: string;
  pendingMembers: IUserConnection;
  requiresTwoFactorAuthentication: boolean;
  samlIdentityProvider: IOrganizationIdentityProvider;
  team: ITeam;
  teams: ITeamConnection;
  teamsResourcePath: unknown;
  teamsUrl: unknown;
  twitterUsername: string;
  updatedAt: unknown;
  viewerCanAdminister: boolean;
  viewerCanCreateRepositories: boolean;
  viewerCanCreateTeams: boolean;
  viewerIsAMember: boolean;
}

interface OrganizationSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */

  anyPinnableItems: (variables: {
    type: unknown;
  }) => Field<"anyPinnableItems", [/* @todo */]>;

  /**
   * @description Audit log entries of the organization
   */

  auditLog: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | AuditLogOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: OrganizationAuditEntryConnectionSelector) => T
  ) => Field<
    "auditLog",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | AuditLogOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A URL pointing to the organization's public avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The organization's public profile description.
   */

  description: () => Field<"description">;

  /**
   * @description The organization's public profile description rendered to HTML.
   */

  descriptionHTML: () => Field<"descriptionHTML">;

  /**
   * @description The organization's public email.
   */

  email: () => Field<"email">;

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */

  hasSponsorsListing: () => Field<"hasSponsorsListing">;

  id: () => Field<"id">;

  /**
   * @description The interaction ability settings for this organization.
   */

  interactionAbility: <T extends Array<Selection>>(
    select: (t: RepositoryInteractionAbilitySelector) => T
  ) => Field<"interactionAbility", never, SelectionSet<T>>;

  /**
   * @description The setting value for whether the organization has an IP allow list enabled.
   */

  ipAllowListEnabledSetting: () => Field<"ipAllowListEnabledSetting">;

  /**
   * @description The IP addresses that are allowed to access resources owned by the organization.
   */

  ipAllowListEntries: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IpAllowListEntryOrder;
    },
    select: (t: IpAllowListEntryConnectionSelector) => T
  ) => Field<
    "ipAllowListEntries",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IpAllowListEntryOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */

  isSponsoringViewer: () => Field<"isSponsoringViewer">;

  /**
   * @description Whether the organization has verified its profile email and website, always false on Enterprise.
   */

  isVerified: () => Field<"isVerified">;

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  itemShowcase: <T extends Array<Selection>>(
    select: (t: ProfileItemShowcaseSelector) => T
  ) => Field<"itemShowcase", never, SelectionSet<T>>;

  /**
   * @description The organization's public profile location.
   */

  location: () => Field<"location">;

  /**
   * @description The organization's login name.
   */

  login: () => Field<"login">;

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  memberStatuses: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | UserStatusOrder;
    },
    select: (t: UserStatusConnectionSelector) => T
  ) => Field<
    "memberStatuses",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | UserStatusOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users who are members of this organization.
   */

  membersWithRole: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: OrganizationMemberConnectionSelector) => T
  ) => Field<
    "membersWithRole",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The organization's public profile name.
   */

  name: () => Field<"name">;

  /**
   * @description The HTTP path creating a new team
   */

  newTeamResourcePath: () => Field<"newTeamResourcePath">;

  /**
   * @description The HTTP URL creating a new team
   */

  newTeamUrl: () => Field<"newTeamUrl">;

  /**
   * @description The billing email for the organization.
   */

  organizationBillingEmail: () => Field<"organizationBillingEmail">;

  /**
   * @description A list of packages under the owner.
   */

  packages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      names?: Variable<"names"> | string;
      orderBy?: Variable<"orderBy"> | PackageOrder;
      packageType?: Variable<"packageType"> | PackageType;
      repositoryId?: Variable<"repositoryId"> | string;
    },
    select: (t: PackageConnectionSelector) => T
  ) => Field<
    "packages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"names", Variable<"names"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | PackageOrder>,
      Argument<"packageType", Variable<"packageType"> | PackageType>,
      Argument<"repositoryId", Variable<"repositoryId"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users who have been invited to join this organization.
   */

  pendingMembers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "pendingMembers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  pinnableItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnableItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  pinnedItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnedItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */

  pinnedItemsRemaining: () => Field<"pinnedItemsRemaining">;

  /**
   * @description Find project by number.
   */

  project: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: ProjectSelector) => T
  ) => Field<
    "project",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of projects under the owner.
   */

  projects: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ProjectOrder;
      search?: Variable<"search"> | string;
      states?: Variable<"states"> | ProjectState;
    },
    select: (t: ProjectConnectionSelector) => T
  ) => Field<
    "projects",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ProjectOrder>,
      Argument<"search", Variable<"search"> | string>,
      Argument<"states", Variable<"states"> | ProjectState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing organization's projects
   */

  projectsResourcePath: () => Field<"projectsResourcePath">;

  /**
   * @description The HTTP URL listing organization's projects
   */

  projectsUrl: () => Field<"projectsUrl">;

  /**
   * @description A list of repositories that the user owns.
   */

  repositories: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isFork?: Variable<"isFork"> | boolean;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isFork", Variable<"isFork"> | boolean>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find Repository.
   */

  repository: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: RepositorySelector) => T
  ) => Field<
    "repository",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
     * @description When true the organization requires all members, billing managers, and outside
collaborators to enable two-factor authentication.
     */

  requiresTwoFactorAuthentication: () => Field<"requiresTwoFactorAuthentication">;

  /**
   * @description The HTTP path for this organization.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The Organization's SAML identity providers
   */

  samlIdentityProvider: <T extends Array<Selection>>(
    select: (t: OrganizationIdentityProviderSelector) => T
  ) => Field<"samlIdentityProvider", never, SelectionSet<T>>;

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  sponsorsListing: <T extends Array<Selection>>(
    select: (t: SponsorsListingSelector) => T
  ) => Field<"sponsorsListing", never, SelectionSet<T>>;

  /**
   * @description This object's sponsorships as the maintainer.
   */

  sponsorshipsAsMaintainer: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      includePrivate?: Variable<"includePrivate"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsMaintainer",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"includePrivate", Variable<"includePrivate"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description This object's sponsorships as the sponsor.
   */

  sponsorshipsAsSponsor: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsSponsor",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find an organization's team by its slug.
   */

  team: <T extends Array<Selection>>(
    variables: { slug?: Variable<"slug"> | string },
    select: (t: TeamSelector) => T
  ) => Field<
    "team",
    [Argument<"slug", Variable<"slug"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description A list of teams in this organization.
   */

  teams: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      ldapMapped?: Variable<"ldapMapped"> | boolean;
      orderBy?: Variable<"orderBy"> | TeamOrder;
      privacy?: Variable<"privacy"> | TeamPrivacy;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | TeamRole;
      rootTeamsOnly?: Variable<"rootTeamsOnly"> | boolean;
      userLogins?: Variable<"userLogins"> | string;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "teams",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"ldapMapped", Variable<"ldapMapped"> | boolean>,
      Argument<"orderBy", Variable<"orderBy"> | TeamOrder>,
      Argument<"privacy", Variable<"privacy"> | TeamPrivacy>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | TeamRole>,
      Argument<"rootTeamsOnly", Variable<"rootTeamsOnly"> | boolean>,
      Argument<"userLogins", Variable<"userLogins"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing organization's teams
   */

  teamsResourcePath: () => Field<"teamsResourcePath">;

  /**
   * @description The HTTP URL listing organization's teams
   */

  teamsUrl: () => Field<"teamsUrl">;

  /**
   * @description The organization's Twitter username.
   */

  twitterUsername: () => Field<"twitterUsername">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this organization.
   */

  url: () => Field<"url">;

  /**
   * @description Organization is adminable by the viewer.
   */

  viewerCanAdminister: () => Field<"viewerCanAdminister">;

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */

  viewerCanChangePinnedItems: () => Field<"viewerCanChangePinnedItems">;

  /**
   * @description Can the current viewer create new projects on this owner.
   */

  viewerCanCreateProjects: () => Field<"viewerCanCreateProjects">;

  /**
   * @description Viewer can create repositories on this organization
   */

  viewerCanCreateRepositories: () => Field<"viewerCanCreateRepositories">;

  /**
   * @description Viewer can create teams on this organization.
   */

  viewerCanCreateTeams: () => Field<"viewerCanCreateTeams">;

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */

  viewerCanSponsor: () => Field<"viewerCanSponsor">;

  /**
   * @description Viewer is an active member of this organization.
   */

  viewerIsAMember: () => Field<"viewerIsAMember">;

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */

  viewerIsSponsoring: () => Field<"viewerIsSponsoring">;

  /**
   * @description The organization's public profile URL.
   */

  websiteUrl: () => Field<"websiteUrl">;
}

export const isOrganization = (
  object: Record<string, any>
): object is Partial<IOrganization> => {
  return object.__typename === "Organization";
};

export const Organization: OrganizationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */
  anyPinnableItems: (variables) => new Field("anyPinnableItems"),

  /**
   * @description Audit log entries of the organization
   */

  auditLog: (variables, select) =>
    new Field(
      "auditLog",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(OrganizationAuditEntryConnection))
    ),

  /**
   * @description A URL pointing to the organization's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The organization's public profile description.
   */
  description: () => new Field("description"),

  /**
   * @description The organization's public profile description rendered to HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),

  /**
   * @description The organization's public email.
   */
  email: () => new Field("email"),

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */
  hasSponsorsListing: () => new Field("hasSponsorsListing"),
  id: () => new Field("id"),

  /**
   * @description The interaction ability settings for this organization.
   */

  interactionAbility: (select) =>
    new Field(
      "interactionAbility",
      undefined as never,
      new SelectionSet(select(RepositoryInteractionAbility))
    ),

  /**
   * @description The setting value for whether the organization has an IP allow list enabled.
   */
  ipAllowListEnabledSetting: () => new Field("ipAllowListEnabledSetting"),

  /**
   * @description The IP addresses that are allowed to access resources owned by the organization.
   */

  ipAllowListEntries: (variables, select) =>
    new Field(
      "ipAllowListEntries",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IpAllowListEntryConnection))
    ),

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */
  isSponsoringViewer: () => new Field("isSponsoringViewer"),

  /**
   * @description Whether the organization has verified its profile email and website, always false on Enterprise.
   */
  isVerified: () => new Field("isVerified"),

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  itemShowcase: (select) =>
    new Field(
      "itemShowcase",
      undefined as never,
      new SelectionSet(select(ProfileItemShowcase))
    ),

  /**
   * @description The organization's public profile location.
   */
  location: () => new Field("location"),

  /**
   * @description The organization's login name.
   */
  login: () => new Field("login"),

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  memberStatuses: (variables, select) =>
    new Field(
      "memberStatuses",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(UserStatusConnection))
    ),

  /**
   * @description A list of users who are members of this organization.
   */

  membersWithRole: (variables, select) =>
    new Field(
      "membersWithRole",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(OrganizationMemberConnection))
    ),

  /**
   * @description The organization's public profile name.
   */
  name: () => new Field("name"),

  /**
   * @description The HTTP path creating a new team
   */
  newTeamResourcePath: () => new Field("newTeamResourcePath"),

  /**
   * @description The HTTP URL creating a new team
   */
  newTeamUrl: () => new Field("newTeamUrl"),

  /**
   * @description The billing email for the organization.
   */
  organizationBillingEmail: () => new Field("organizationBillingEmail"),

  /**
   * @description A list of packages under the owner.
   */

  packages: (variables, select) =>
    new Field(
      "packages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("names", variables.names),
        new Argument("orderBy", variables.orderBy),
        new Argument("packageType", variables.packageType, PackageType),
        new Argument("repositoryId", variables.repositoryId),
      ],
      new SelectionSet(select(PackageConnection))
    ),

  /**
   * @description A list of users who have been invited to join this organization.
   */

  pendingMembers: (variables, select) =>
    new Field(
      "pendingMembers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  pinnableItems: (variables, select) =>
    new Field(
      "pinnableItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  pinnedItems: (variables, select) =>
    new Field(
      "pinnedItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */
  pinnedItemsRemaining: () => new Field("pinnedItemsRemaining"),

  /**
   * @description Find project by number.
   */

  project: (variables, select) =>
    new Field(
      "project",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Project))
    ),

  /**
   * @description A list of projects under the owner.
   */

  projects: (variables, select) =>
    new Field(
      "projects",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("search", variables.search),
        new Argument("states", variables.states, ProjectState),
      ],
      new SelectionSet(select(ProjectConnection))
    ),

  /**
   * @description The HTTP path listing organization's projects
   */
  projectsResourcePath: () => new Field("projectsResourcePath"),

  /**
   * @description The HTTP URL listing organization's projects
   */
  projectsUrl: () => new Field("projectsUrl"),

  /**
   * @description A list of repositories that the user owns.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isFork", variables.isFork),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description Find Repository.
   */

  repository: (variables, select) =>
    new Field(
      "repository",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Repository))
    ),

  /**
     * @description When true the organization requires all members, billing managers, and outside
collaborators to enable two-factor authentication.
     */
  requiresTwoFactorAuthentication: () =>
    new Field("requiresTwoFactorAuthentication"),

  /**
   * @description The HTTP path for this organization.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The Organization's SAML identity providers
   */

  samlIdentityProvider: (select) =>
    new Field(
      "samlIdentityProvider",
      undefined as never,
      new SelectionSet(select(OrganizationIdentityProvider))
    ),

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  sponsorsListing: (select) =>
    new Field(
      "sponsorsListing",
      undefined as never,
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description This object's sponsorships as the maintainer.
   */

  sponsorshipsAsMaintainer: (variables, select) =>
    new Field(
      "sponsorshipsAsMaintainer",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("includePrivate", variables.includePrivate),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description This object's sponsorships as the sponsor.
   */

  sponsorshipsAsSponsor: (variables, select) =>
    new Field(
      "sponsorshipsAsSponsor",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description Find an organization's team by its slug.
   */

  team: (variables, select) =>
    new Field(
      "team",
      [new Argument("slug", variables.slug)],
      new SelectionSet(select(Team))
    ),

  /**
   * @description A list of teams in this organization.
   */

  teams: (variables, select) =>
    new Field(
      "teams",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("ldapMapped", variables.ldapMapped),
        new Argument("orderBy", variables.orderBy),
        new Argument("privacy", variables.privacy, TeamPrivacy),
        new Argument("query", variables.query),
        new Argument("role", variables.role, TeamRole),
        new Argument("rootTeamsOnly", variables.rootTeamsOnly),
        new Argument("userLogins", variables.userLogins),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description The HTTP path listing organization's teams
   */
  teamsResourcePath: () => new Field("teamsResourcePath"),

  /**
   * @description The HTTP URL listing organization's teams
   */
  teamsUrl: () => new Field("teamsUrl"),

  /**
   * @description The organization's Twitter username.
   */
  twitterUsername: () => new Field("twitterUsername"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this organization.
   */
  url: () => new Field("url"),

  /**
   * @description Organization is adminable by the viewer.
   */
  viewerCanAdminister: () => new Field("viewerCanAdminister"),

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */
  viewerCanChangePinnedItems: () => new Field("viewerCanChangePinnedItems"),

  /**
   * @description Can the current viewer create new projects on this owner.
   */
  viewerCanCreateProjects: () => new Field("viewerCanCreateProjects"),

  /**
   * @description Viewer can create repositories on this organization
   */
  viewerCanCreateRepositories: () => new Field("viewerCanCreateRepositories"),

  /**
   * @description Viewer can create teams on this organization.
   */
  viewerCanCreateTeams: () => new Field("viewerCanCreateTeams"),

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */
  viewerCanSponsor: () => new Field("viewerCanSponsor"),

  /**
   * @description Viewer is an active member of this organization.
   */
  viewerIsAMember: () => new Field("viewerIsAMember"),

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */
  viewerIsSponsoring: () => new Field("viewerIsSponsoring"),

  /**
   * @description The organization's public profile URL.
   */
  websiteUrl: () => new Field("websiteUrl"),
};

export interface IOrganizationAuditEntryConnection {
  edges: IOrganizationAuditEntryEdge[];
  nodes: IOrganizationAuditEntry[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface OrganizationAuditEntryConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: OrganizationAuditEntryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: OrganizationAuditEntrySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const OrganizationAuditEntryConnection: OrganizationAuditEntryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(OrganizationAuditEntryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(OrganizationAuditEntry))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IOrganizationAuditEntryData {
  __typename: string;
  organization: IOrganization;
  organizationName: string;
  organizationResourcePath: unknown;
  organizationUrl: unknown;
}

interface OrganizationAuditEntryDataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  on: <
    T extends Array<Selection>,
    F extends
      | "MembersCanDeleteReposClearAuditEntry"
      | "MembersCanDeleteReposDisableAuditEntry"
      | "MembersCanDeleteReposEnableAuditEntry"
      | "OauthApplicationCreateAuditEntry"
      | "OrgAddBillingManagerAuditEntry"
      | "OrgAddMemberAuditEntry"
      | "OrgBlockUserAuditEntry"
      | "OrgConfigDisableCollaboratorsOnlyAuditEntry"
      | "OrgConfigEnableCollaboratorsOnlyAuditEntry"
      | "OrgCreateAuditEntry"
      | "OrgDisableOauthAppRestrictionsAuditEntry"
      | "OrgDisableSamlAuditEntry"
      | "OrgDisableTwoFactorRequirementAuditEntry"
      | "OrgEnableOauthAppRestrictionsAuditEntry"
      | "OrgEnableSamlAuditEntry"
      | "OrgEnableTwoFactorRequirementAuditEntry"
      | "OrgInviteMemberAuditEntry"
      | "OrgInviteToBusinessAuditEntry"
      | "OrgOauthAppAccessApprovedAuditEntry"
      | "OrgOauthAppAccessDeniedAuditEntry"
      | "OrgOauthAppAccessRequestedAuditEntry"
      | "OrgRemoveBillingManagerAuditEntry"
      | "OrgRemoveMemberAuditEntry"
      | "OrgRemoveOutsideCollaboratorAuditEntry"
      | "OrgRestoreMemberAuditEntry"
      | "OrgRestoreMemberMembershipOrganizationAuditEntryData"
      | "OrgUnblockUserAuditEntry"
      | "OrgUpdateDefaultRepositoryPermissionAuditEntry"
      | "OrgUpdateMemberAuditEntry"
      | "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
      | "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "RepositoryVisibilityChangeDisableAuditEntry"
      | "RepositoryVisibilityChangeEnableAuditEntry"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "MembersCanDeleteReposClearAuditEntry"
        ? MembersCanDeleteReposClearAuditEntrySelector
        : F extends "MembersCanDeleteReposDisableAuditEntry"
        ? MembersCanDeleteReposDisableAuditEntrySelector
        : F extends "MembersCanDeleteReposEnableAuditEntry"
        ? MembersCanDeleteReposEnableAuditEntrySelector
        : F extends "OauthApplicationCreateAuditEntry"
        ? OauthApplicationCreateAuditEntrySelector
        : F extends "OrgAddBillingManagerAuditEntry"
        ? OrgAddBillingManagerAuditEntrySelector
        : F extends "OrgAddMemberAuditEntry"
        ? OrgAddMemberAuditEntrySelector
        : F extends "OrgBlockUserAuditEntry"
        ? OrgBlockUserAuditEntrySelector
        : F extends "OrgConfigDisableCollaboratorsOnlyAuditEntry"
        ? OrgConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgConfigEnableCollaboratorsOnlyAuditEntry"
        ? OrgConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "OrgCreateAuditEntry"
        ? OrgCreateAuditEntrySelector
        : F extends "OrgDisableOauthAppRestrictionsAuditEntry"
        ? OrgDisableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgDisableSamlAuditEntry"
        ? OrgDisableSamlAuditEntrySelector
        : F extends "OrgDisableTwoFactorRequirementAuditEntry"
        ? OrgDisableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgEnableOauthAppRestrictionsAuditEntry"
        ? OrgEnableOauthAppRestrictionsAuditEntrySelector
        : F extends "OrgEnableSamlAuditEntry"
        ? OrgEnableSamlAuditEntrySelector
        : F extends "OrgEnableTwoFactorRequirementAuditEntry"
        ? OrgEnableTwoFactorRequirementAuditEntrySelector
        : F extends "OrgInviteMemberAuditEntry"
        ? OrgInviteMemberAuditEntrySelector
        : F extends "OrgInviteToBusinessAuditEntry"
        ? OrgInviteToBusinessAuditEntrySelector
        : F extends "OrgOauthAppAccessApprovedAuditEntry"
        ? OrgOauthAppAccessApprovedAuditEntrySelector
        : F extends "OrgOauthAppAccessDeniedAuditEntry"
        ? OrgOauthAppAccessDeniedAuditEntrySelector
        : F extends "OrgOauthAppAccessRequestedAuditEntry"
        ? OrgOauthAppAccessRequestedAuditEntrySelector
        : F extends "OrgRemoveBillingManagerAuditEntry"
        ? OrgRemoveBillingManagerAuditEntrySelector
        : F extends "OrgRemoveMemberAuditEntry"
        ? OrgRemoveMemberAuditEntrySelector
        : F extends "OrgRemoveOutsideCollaboratorAuditEntry"
        ? OrgRemoveOutsideCollaboratorAuditEntrySelector
        : F extends "OrgRestoreMemberAuditEntry"
        ? OrgRestoreMemberAuditEntrySelector
        : F extends "OrgRestoreMemberMembershipOrganizationAuditEntryData"
        ? OrgRestoreMemberMembershipOrganizationAuditEntryDataSelector
        : F extends "OrgUnblockUserAuditEntry"
        ? OrgUnblockUserAuditEntrySelector
        : F extends "OrgUpdateDefaultRepositoryPermissionAuditEntry"
        ? OrgUpdateDefaultRepositoryPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberAuditEntry"
        ? OrgUpdateMemberAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryCreationPermissionAuditEntrySelector
        : F extends "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
        ? OrgUpdateMemberRepositoryInvitationPermissionAuditEntrySelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "RepositoryVisibilityChangeDisableAuditEntry"
        ? RepositoryVisibilityChangeDisableAuditEntrySelector
        : F extends "RepositoryVisibilityChangeEnableAuditEntry"
        ? RepositoryVisibilityChangeEnableAuditEntrySelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const OrganizationAuditEntryData: OrganizationAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  on: (type, select) => {
    switch (type) {
      case "MembersCanDeleteReposClearAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposClearAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposClearAuditEntry as any))
        );
      }

      case "MembersCanDeleteReposDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposDisableAuditEntry") as any,
          new SelectionSet(
            select(MembersCanDeleteReposDisableAuditEntry as any)
          )
        );
      }

      case "MembersCanDeleteReposEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("MembersCanDeleteReposEnableAuditEntry") as any,
          new SelectionSet(select(MembersCanDeleteReposEnableAuditEntry as any))
        );
      }

      case "OauthApplicationCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OauthApplicationCreateAuditEntry") as any,
          new SelectionSet(select(OauthApplicationCreateAuditEntry as any))
        );
      }

      case "OrgAddBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgAddBillingManagerAuditEntry as any))
        );
      }

      case "OrgAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgAddMemberAuditEntry") as any,
          new SelectionSet(select(OrgAddMemberAuditEntry as any))
        );
      }

      case "OrgBlockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgBlockUserAuditEntry") as any,
          new SelectionSet(select(OrgBlockUserAuditEntry as any))
        );
      }

      case "OrgConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(OrgConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "OrgCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgCreateAuditEntry") as any,
          new SelectionSet(select(OrgCreateAuditEntry as any))
        );
      }

      case "OrgDisableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgDisableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableSamlAuditEntry") as any,
          new SelectionSet(select(OrgDisableSamlAuditEntry as any))
        );
      }

      case "OrgDisableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgDisableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgDisableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgEnableOauthAppRestrictionsAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableOauthAppRestrictionsAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableOauthAppRestrictionsAuditEntry as any)
          )
        );
      }

      case "OrgEnableSamlAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableSamlAuditEntry") as any,
          new SelectionSet(select(OrgEnableSamlAuditEntry as any))
        );
      }

      case "OrgEnableTwoFactorRequirementAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgEnableTwoFactorRequirementAuditEntry") as any,
          new SelectionSet(
            select(OrgEnableTwoFactorRequirementAuditEntry as any)
          )
        );
      }

      case "OrgInviteMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteMemberAuditEntry") as any,
          new SelectionSet(select(OrgInviteMemberAuditEntry as any))
        );
      }

      case "OrgInviteToBusinessAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgInviteToBusinessAuditEntry") as any,
          new SelectionSet(select(OrgInviteToBusinessAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessApprovedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessApprovedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessApprovedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessDeniedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessDeniedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessDeniedAuditEntry as any))
        );
      }

      case "OrgOauthAppAccessRequestedAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgOauthAppAccessRequestedAuditEntry") as any,
          new SelectionSet(select(OrgOauthAppAccessRequestedAuditEntry as any))
        );
      }

      case "OrgRemoveBillingManagerAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveBillingManagerAuditEntry") as any,
          new SelectionSet(select(OrgRemoveBillingManagerAuditEntry as any))
        );
      }

      case "OrgRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveMemberAuditEntry") as any,
          new SelectionSet(select(OrgRemoveMemberAuditEntry as any))
        );
      }

      case "OrgRemoveOutsideCollaboratorAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRemoveOutsideCollaboratorAuditEntry") as any,
          new SelectionSet(
            select(OrgRemoveOutsideCollaboratorAuditEntry as any)
          )
        );
      }

      case "OrgRestoreMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberAuditEntry") as any,
          new SelectionSet(select(OrgRestoreMemberAuditEntry as any))
        );
      }

      case "OrgRestoreMemberMembershipOrganizationAuditEntryData": {
        return new InlineFragment(
          new NamedType(
            "OrgRestoreMemberMembershipOrganizationAuditEntryData"
          ) as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipOrganizationAuditEntryData as any)
          )
        );
      }

      case "OrgUnblockUserAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUnblockUserAuditEntry") as any,
          new SelectionSet(select(OrgUnblockUserAuditEntry as any))
        );
      }

      case "OrgUpdateDefaultRepositoryPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateDefaultRepositoryPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateDefaultRepositoryPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("OrgUpdateMemberAuditEntry") as any,
          new SelectionSet(select(OrgUpdateMemberAuditEntry as any))
        );
      }

      case "OrgUpdateMemberRepositoryCreationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryCreationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(OrgUpdateMemberRepositoryCreationPermissionAuditEntry as any)
          )
        );
      }

      case "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "OrgUpdateMemberRepositoryInvitationPermissionAuditEntry"
          ) as any,
          new SelectionSet(
            select(
              OrgUpdateMemberRepositoryInvitationPermissionAuditEntry as any
            )
          )
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "RepositoryVisibilityChangeDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeDisableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeDisableAuditEntry as any)
          )
        );
      }

      case "RepositoryVisibilityChangeEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("RepositoryVisibilityChangeEnableAuditEntry") as any,
          new SelectionSet(
            select(RepositoryVisibilityChangeEnableAuditEntry as any)
          )
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IOrganizationAuditEntryEdge {
  cursor: string;
  node: IOrganizationAuditEntry;
}

interface OrganizationAuditEntryEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: OrganizationAuditEntrySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const OrganizationAuditEntryEdge: OrganizationAuditEntryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(OrganizationAuditEntry))
    ),
};

export interface IOrganizationConnection {
  edges: IOrganizationEdge[];
  nodes: IOrganization[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface OrganizationConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: OrganizationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const OrganizationConnection: OrganizationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(OrganizationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IOrganizationEdge {
  cursor: string;
  node: IOrganization;
}

interface OrganizationEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const OrganizationEdge: OrganizationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(Organization))
    ),
};

export interface IOrganizationIdentityProvider extends INode {
  __typename: "OrganizationIdentityProvider";
  digestMethod: unknown;
  externalIdentities: IExternalIdentityConnection;
  idpCertificate: unknown;
  issuer: string;
  organization: IOrganization;
  signatureMethod: unknown;
  ssoUrl: unknown;
}

interface OrganizationIdentityProviderSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The digest algorithm used to sign SAML requests for the Identity Provider.
   */

  digestMethod: () => Field<"digestMethod">;

  /**
   * @description External Identities provisioned by this Identity Provider
   */

  externalIdentities: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ExternalIdentityConnectionSelector) => T
  ) => Field<
    "externalIdentities",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  id: () => Field<"id">;

  /**
   * @description The x509 certificate used by the Identity Provder to sign assertions and responses.
   */

  idpCertificate: () => Field<"idpCertificate">;

  /**
   * @description The Issuer Entity ID for the SAML Identity Provider
   */

  issuer: () => Field<"issuer">;

  /**
   * @description Organization this Identity Provider belongs to
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The signature algorithm used to sign SAML requests for the Identity Provider.
   */

  signatureMethod: () => Field<"signatureMethod">;

  /**
   * @description The URL endpoint for the Identity Provider's SAML SSO.
   */

  ssoUrl: () => Field<"ssoUrl">;
}

export const isOrganizationIdentityProvider = (
  object: Record<string, any>
): object is Partial<IOrganizationIdentityProvider> => {
  return object.__typename === "OrganizationIdentityProvider";
};

export const OrganizationIdentityProvider: OrganizationIdentityProviderSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The digest algorithm used to sign SAML requests for the Identity Provider.
   */
  digestMethod: () => new Field("digestMethod"),

  /**
   * @description External Identities provisioned by this Identity Provider
   */

  externalIdentities: (variables, select) =>
    new Field(
      "externalIdentities",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ExternalIdentityConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The x509 certificate used by the Identity Provder to sign assertions and responses.
   */
  idpCertificate: () => new Field("idpCertificate"),

  /**
   * @description The Issuer Entity ID for the SAML Identity Provider
   */
  issuer: () => new Field("issuer"),

  /**
   * @description Organization this Identity Provider belongs to
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The signature algorithm used to sign SAML requests for the Identity Provider.
   */
  signatureMethod: () => new Field("signatureMethod"),

  /**
   * @description The URL endpoint for the Identity Provider's SAML SSO.
   */
  ssoUrl: () => new Field("ssoUrl"),
};

export interface IOrganizationInvitation extends INode {
  __typename: "OrganizationInvitation";
  createdAt: unknown;
  email: string;
  invitationType: OrganizationInvitationType;
  invitee: IUser;
  inviter: IUser;
  organization: IOrganization;
  role: OrganizationInvitationRole;
}

interface OrganizationInvitationSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The email address of the user invited to the organization.
   */

  email: () => Field<"email">;

  id: () => Field<"id">;

  /**
   * @description The type of invitation that was sent (e.g. email, user).
   */

  invitationType: () => Field<"invitationType">;

  /**
   * @description The user who was invited to the organization.
   */

  invitee: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"invitee", never, SelectionSet<T>>;

  /**
   * @description The user who created the invitation.
   */

  inviter: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"inviter", never, SelectionSet<T>>;

  /**
   * @description The organization the invite is for
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The user's pending role in the organization (e.g. member, owner).
   */

  role: () => Field<"role">;
}

export const isOrganizationInvitation = (
  object: Record<string, any>
): object is Partial<IOrganizationInvitation> => {
  return object.__typename === "OrganizationInvitation";
};

export const OrganizationInvitation: OrganizationInvitationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The email address of the user invited to the organization.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description The type of invitation that was sent (e.g. email, user).
   */
  invitationType: () => new Field("invitationType"),

  /**
   * @description The user who was invited to the organization.
   */

  invitee: (select) =>
    new Field("invitee", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The user who created the invitation.
   */

  inviter: (select) =>
    new Field("inviter", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The organization the invite is for
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The user's pending role in the organization (e.g. member, owner).
   */
  role: () => new Field("role"),
};

export interface IOrganizationInvitationConnection {
  edges: IOrganizationInvitationEdge[];
  nodes: IOrganizationInvitation[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface OrganizationInvitationConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const OrganizationInvitationConnection: OrganizationInvitationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(OrganizationInvitationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IOrganizationInvitationEdge {
  cursor: string;
  node: IOrganizationInvitation;
}

interface OrganizationInvitationEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: OrganizationInvitationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const OrganizationInvitationEdge: OrganizationInvitationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(OrganizationInvitation))
    ),
};

export interface IOrganizationMemberConnection {
  edges: IOrganizationMemberEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface OrganizationMemberConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: OrganizationMemberEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const OrganizationMemberConnection: OrganizationMemberConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(OrganizationMemberEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IOrganizationMemberEdge {
  cursor: string;
  hasTwoFactorEnabled: boolean;
  node: IUser;
  role: OrganizationMemberRole;
}

interface OrganizationMemberEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer.
   */

  hasTwoFactorEnabled: () => Field<"hasTwoFactorEnabled">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The role this user has in the organization.
   */

  role: () => Field<"role">;
}

export const OrganizationMemberEdge: OrganizationMemberEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description Whether the organization member has two factor enabled or not. Returns null if information is not available to viewer.
   */
  hasTwoFactorEnabled: () => new Field("hasTwoFactorEnabled"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The role this user has in the organization.
   */
  role: () => new Field("role"),
};

export interface IOrganizationTeamsHovercardContext extends IHovercardContext {
  __typename: "OrganizationTeamsHovercardContext";
  relevantTeams: ITeamConnection;
  teamsResourcePath: unknown;
  teamsUrl: unknown;
  totalTeamCount: number;
}

interface OrganizationTeamsHovercardContextSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  octicon: () => Field<"octicon">;

  /**
   * @description Teams in this organization the user is a member of that are relevant
   */

  relevantTeams: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "relevantTeams",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The path for the full team list for this user
   */

  teamsResourcePath: () => Field<"teamsResourcePath">;

  /**
   * @description The URL for the full team list for this user
   */

  teamsUrl: () => Field<"teamsUrl">;

  /**
   * @description The total number of teams the user is on in the organization
   */

  totalTeamCount: () => Field<"totalTeamCount">;
}

export const isOrganizationTeamsHovercardContext = (
  object: Record<string, any>
): object is Partial<IOrganizationTeamsHovercardContext> => {
  return object.__typename === "OrganizationTeamsHovercardContext";
};

export const OrganizationTeamsHovercardContext: OrganizationTeamsHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  /**
   * @description Teams in this organization the user is a member of that are relevant
   */

  relevantTeams: (variables, select) =>
    new Field(
      "relevantTeams",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description The path for the full team list for this user
   */
  teamsResourcePath: () => new Field("teamsResourcePath"),

  /**
   * @description The URL for the full team list for this user
   */
  teamsUrl: () => new Field("teamsUrl"),

  /**
   * @description The total number of teams the user is on in the organization
   */
  totalTeamCount: () => new Field("totalTeamCount"),
};

export interface IOrganizationsHovercardContext extends IHovercardContext {
  __typename: "OrganizationsHovercardContext";
  relevantOrganizations: IOrganizationConnection;
  totalOrganizationCount: number;
}

interface OrganizationsHovercardContextSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  octicon: () => Field<"octicon">;

  /**
   * @description Organizations this user is a member of that are relevant
   */

  relevantOrganizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "relevantOrganizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The total number of organizations this user is in
   */

  totalOrganizationCount: () => Field<"totalOrganizationCount">;
}

export const isOrganizationsHovercardContext = (
  object: Record<string, any>
): object is Partial<IOrganizationsHovercardContext> => {
  return object.__typename === "OrganizationsHovercardContext";
};

export const OrganizationsHovercardContext: OrganizationsHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  /**
   * @description Organizations this user is a member of that are relevant
   */

  relevantOrganizations: (variables, select) =>
    new Field(
      "relevantOrganizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description The total number of organizations this user is in
   */
  totalOrganizationCount: () => new Field("totalOrganizationCount"),
};

export interface IPackage extends INode {
  __typename: "Package";
  latestVersion: IPackageVersion;
  name: string;
  packageType: PackageType;
  repository: IRepository;
  statistics: IPackageStatistics;
  version: IPackageVersion;
  versions: IPackageVersionConnection;
}

interface PackageSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description Find the latest version for the package.
   */

  latestVersion: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"latestVersion", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the package.
   */

  name: () => Field<"name">;

  /**
   * @description Identifies the type of the package.
   */

  packageType: () => Field<"packageType">;

  /**
   * @description The repository this package belongs to.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description Statistics about package activity.
   */

  statistics: <T extends Array<Selection>>(
    select: (t: PackageStatisticsSelector) => T
  ) => Field<"statistics", never, SelectionSet<T>>;

  /**
   * @description Find package version by version string.
   */

  version: <T extends Array<Selection>>(
    variables: { version?: Variable<"version"> | string },
    select: (t: PackageVersionSelector) => T
  ) => Field<
    "version",
    [Argument<"version", Variable<"version"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description list of versions for this package
   */

  versions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | PackageVersionOrder;
    },
    select: (t: PackageVersionConnectionSelector) => T
  ) => Field<
    "versions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | PackageVersionOrder>
    ],
    SelectionSet<T>
  >;
}

export const isPackage = (
  object: Record<string, any>
): object is Partial<IPackage> => {
  return object.__typename === "Package";
};

export const Package: PackageSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Find the latest version for the package.
   */

  latestVersion: (select) =>
    new Field(
      "latestVersion",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),

  /**
   * @description Identifies the name of the package.
   */
  name: () => new Field("name"),

  /**
   * @description Identifies the type of the package.
   */
  packageType: () => new Field("packageType"),

  /**
   * @description The repository this package belongs to.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Statistics about package activity.
   */

  statistics: (select) =>
    new Field(
      "statistics",
      undefined as never,
      new SelectionSet(select(PackageStatistics))
    ),

  /**
   * @description Find package version by version string.
   */

  version: (variables, select) =>
    new Field(
      "version",
      [new Argument("version", variables.version)],
      new SelectionSet(select(PackageVersion))
    ),

  /**
   * @description list of versions for this package
   */

  versions: (variables, select) =>
    new Field(
      "versions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(PackageVersionConnection))
    ),
};

export interface IPackageConnection {
  edges: IPackageEdge[];
  nodes: IPackage[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PackageConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PackageEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PackageSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PackageConnection: PackageConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PackageEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Package))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPackageEdge {
  cursor: string;
  node: IPackage;
}

interface PackageEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PackageSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PackageEdge: PackageEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Package))),
};

export interface IPackageFile extends INode {
  __typename: "PackageFile";
  md5: string;
  name: string;
  packageVersion: IPackageVersion;
  sha1: string;
  sha256: string;
  size: number;
  updatedAt: unknown;
  url: unknown;
}

interface PackageFileSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description MD5 hash of the file.
   */

  md5: () => Field<"md5">;

  /**
   * @description Name of the file.
   */

  name: () => Field<"name">;

  /**
   * @description The package version this file belongs to.
   */

  packageVersion: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"packageVersion", never, SelectionSet<T>>;

  /**
   * @description SHA1 hash of the file.
   */

  sha1: () => Field<"sha1">;

  /**
   * @description SHA256 hash of the file.
   */

  sha256: () => Field<"sha256">;

  /**
   * @description Size of the file in bytes.
   */

  size: () => Field<"size">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description URL to download the asset.
   */

  url: () => Field<"url">;
}

export const isPackageFile = (
  object: Record<string, any>
): object is Partial<IPackageFile> => {
  return object.__typename === "PackageFile";
};

export const PackageFile: PackageFileSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description MD5 hash of the file.
   */
  md5: () => new Field("md5"),

  /**
   * @description Name of the file.
   */
  name: () => new Field("name"),

  /**
   * @description The package version this file belongs to.
   */

  packageVersion: (select) =>
    new Field(
      "packageVersion",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),

  /**
   * @description SHA1 hash of the file.
   */
  sha1: () => new Field("sha1"),

  /**
   * @description SHA256 hash of the file.
   */
  sha256: () => new Field("sha256"),

  /**
   * @description Size of the file in bytes.
   */
  size: () => new Field("size"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description URL to download the asset.
   */
  url: () => new Field("url"),
};

export interface IPackageFileConnection {
  edges: IPackageFileEdge[];
  nodes: IPackageFile[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PackageFileConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PackageFileEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PackageFileSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PackageFileConnection: PackageFileConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PackageFileEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PackageFile))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPackageFileEdge {
  cursor: string;
  node: IPackageFile;
}

interface PackageFileEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PackageFileSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PackageFileEdge: PackageFileEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PackageFile))
    ),
};

export interface IPackageOwner {
  __typename: string;
  id: string;
  packages: IPackageConnection;
}

interface PackageOwnerSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description A list of packages under the owner.
   */

  packages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      names?: Variable<"names"> | string;
      orderBy?: Variable<"orderBy"> | PackageOrder;
      packageType?: Variable<"packageType"> | PackageType;
      repositoryId?: Variable<"repositoryId"> | string;
    },
    select: (t: PackageConnectionSelector) => T
  ) => Field<
    "packages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"names", Variable<"names"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | PackageOrder>,
      Argument<"packageType", Variable<"packageType"> | PackageType>,
      Argument<"repositoryId", Variable<"repositoryId"> | string>
    ],
    SelectionSet<T>
  >;

  on: <
    T extends Array<Selection>,
    F extends "Organization" | "Repository" | "User"
  >(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const PackageOwner: PackageOwnerSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description A list of packages under the owner.
   */

  packages: (variables, select) =>
    new Field(
      "packages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("names", variables.names),
        new Argument("orderBy", variables.orderBy),
        new Argument("packageType", variables.packageType, PackageType),
        new Argument("repositoryId", variables.repositoryId),
      ],
      new SelectionSet(select(PackageConnection))
    ),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IPackageStatistics {
  downloadsTotalCount: number;
}

interface PackageStatisticsSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Number of times the package was downloaded since it was created.
   */

  downloadsTotalCount: () => Field<"downloadsTotalCount">;
}

export const PackageStatistics: PackageStatisticsSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Number of times the package was downloaded since it was created.
   */
  downloadsTotalCount: () => new Field("downloadsTotalCount"),
};

export interface IPackageTag extends INode {
  __typename: "PackageTag";
  name: string;
  version: IPackageVersion;
}

interface PackageTagSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description Identifies the tag name of the version.
   */

  name: () => Field<"name">;

  /**
   * @description Version that the tag is associated with.
   */

  version: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"version", never, SelectionSet<T>>;
}

export const isPackageTag = (
  object: Record<string, any>
): object is Partial<IPackageTag> => {
  return object.__typename === "PackageTag";
};

export const PackageTag: PackageTagSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Identifies the tag name of the version.
   */
  name: () => new Field("name"),

  /**
   * @description Version that the tag is associated with.
   */

  version: (select) =>
    new Field(
      "version",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),
};

export interface IPackageVersion extends INode {
  __typename: "PackageVersion";
  files: IPackageFileConnection;
  package: IPackage;
  platform: string;
  preRelease: boolean;
  readme: string;
  release: IRelease;
  statistics: IPackageVersionStatistics;
  summary: string;
  version: string;
}

interface PackageVersionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description List of files associated with this package version
   */

  files: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | PackageFileOrder;
    },
    select: (t: PackageFileConnectionSelector) => T
  ) => Field<
    "files",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | PackageFileOrder>
    ],
    SelectionSet<T>
  >;

  id: () => Field<"id">;

  /**
   * @description The package associated with this version.
   */

  package: <T extends Array<Selection>>(
    select: (t: PackageSelector) => T
  ) => Field<"package", never, SelectionSet<T>>;

  /**
   * @description The platform this version was built for.
   */

  platform: () => Field<"platform">;

  /**
   * @description Whether or not this version is a pre-release.
   */

  preRelease: () => Field<"preRelease">;

  /**
   * @description The README of this package version.
   */

  readme: () => Field<"readme">;

  /**
   * @description The release associated with this package version.
   */

  release: <T extends Array<Selection>>(
    select: (t: ReleaseSelector) => T
  ) => Field<"release", never, SelectionSet<T>>;

  /**
   * @description Statistics about package activity.
   */

  statistics: <T extends Array<Selection>>(
    select: (t: PackageVersionStatisticsSelector) => T
  ) => Field<"statistics", never, SelectionSet<T>>;

  /**
   * @description The package version summary.
   */

  summary: () => Field<"summary">;

  /**
   * @description The version string.
   */

  version: () => Field<"version">;
}

export const isPackageVersion = (
  object: Record<string, any>
): object is Partial<IPackageVersion> => {
  return object.__typename === "PackageVersion";
};

export const PackageVersion: PackageVersionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description List of files associated with this package version
   */

  files: (variables, select) =>
    new Field(
      "files",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(PackageFileConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The package associated with this version.
   */

  package: (select) =>
    new Field("package", undefined as never, new SelectionSet(select(Package))),

  /**
   * @description The platform this version was built for.
   */
  platform: () => new Field("platform"),

  /**
   * @description Whether or not this version is a pre-release.
   */
  preRelease: () => new Field("preRelease"),

  /**
   * @description The README of this package version.
   */
  readme: () => new Field("readme"),

  /**
   * @description The release associated with this package version.
   */

  release: (select) =>
    new Field("release", undefined as never, new SelectionSet(select(Release))),

  /**
   * @description Statistics about package activity.
   */

  statistics: (select) =>
    new Field(
      "statistics",
      undefined as never,
      new SelectionSet(select(PackageVersionStatistics))
    ),

  /**
   * @description The package version summary.
   */
  summary: () => new Field("summary"),

  /**
   * @description The version string.
   */
  version: () => new Field("version"),
};

export interface IPackageVersionConnection {
  edges: IPackageVersionEdge[];
  nodes: IPackageVersion[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PackageVersionConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PackageVersionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PackageVersionConnection: PackageVersionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PackageVersionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPackageVersionEdge {
  cursor: string;
  node: IPackageVersion;
}

interface PackageVersionEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PackageVersionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PackageVersionEdge: PackageVersionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PackageVersion))
    ),
};

export interface IPackageVersionStatistics {
  downloadsTotalCount: number;
}

interface PackageVersionStatisticsSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Number of times the package was downloaded since it was created.
   */

  downloadsTotalCount: () => Field<"downloadsTotalCount">;
}

export const PackageVersionStatistics: PackageVersionStatisticsSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Number of times the package was downloaded since it was created.
   */
  downloadsTotalCount: () => new Field("downloadsTotalCount"),
};

export interface IPageInfo {
  endCursor: string;
  hasNextPage: boolean;
  hasPreviousPage: boolean;
  startCursor: string;
}

interface PageInfoSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description When paginating forwards, the cursor to continue.
   */

  endCursor: () => Field<"endCursor">;

  /**
   * @description When paginating forwards, are there more items?
   */

  hasNextPage: () => Field<"hasNextPage">;

  /**
   * @description When paginating backwards, are there more items?
   */

  hasPreviousPage: () => Field<"hasPreviousPage">;

  /**
   * @description When paginating backwards, the cursor to continue.
   */

  startCursor: () => Field<"startCursor">;
}

export const PageInfo: PageInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description When paginating forwards, the cursor to continue.
   */
  endCursor: () => new Field("endCursor"),

  /**
   * @description When paginating forwards, are there more items?
   */
  hasNextPage: () => new Field("hasNextPage"),

  /**
   * @description When paginating backwards, are there more items?
   */
  hasPreviousPage: () => new Field("hasPreviousPage"),

  /**
   * @description When paginating backwards, the cursor to continue.
   */
  startCursor: () => new Field("startCursor"),
};

export interface IPermissionSource {
  organization: IOrganization;
  permission: DefaultRepositoryPermissionField;
  source: IPermissionGranter;
}

interface PermissionSourceSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The organization the repository belongs to.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The level of access this source has granted to the user.
   */

  permission: () => Field<"permission">;

  /**
   * @description The source of this permission.
   */

  source: <T extends Array<Selection>>(
    select: (t: PermissionGranterSelector) => T
  ) => Field<"source", never, SelectionSet<T>>;
}

export const PermissionSource: PermissionSourceSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The organization the repository belongs to.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The level of access this source has granted to the user.
   */
  permission: () => new Field("permission"),

  /**
   * @description The source of this permission.
   */

  source: (select) =>
    new Field(
      "source",
      undefined as never,
      new SelectionSet(select(PermissionGranter))
    ),
};

export interface IPinnableItemConnection {
  edges: IPinnableItemEdge[];
  nodes: IPinnableItem[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PinnableItemConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PinnableItemEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PinnableItemSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PinnableItemConnection: PinnableItemConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PinnableItemEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PinnableItem))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPinnableItemEdge {
  cursor: string;
  node: IPinnableItem;
}

interface PinnableItemEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PinnableItemSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PinnableItemEdge: PinnableItemEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PinnableItem))
    ),
};

export interface IPinnedEvent extends INode {
  __typename: "PinnedEvent";
  actor: IActor;
  createdAt: unknown;
  issue: IIssue;
}

interface PinnedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Identifies the issue associated with the event.
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const isPinnedEvent = (
  object: Record<string, any>
): object is Partial<IPinnedEvent> => {
  return object.__typename === "PinnedEvent";
};

export const PinnedEvent: PinnedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the issue associated with the event.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IPrivateRepositoryForkingDisableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "PrivateRepositoryForkingDisableAuditEntry";
}

interface PrivateRepositoryForkingDisableAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  enterpriseUrl: () => Field<"enterpriseUrl">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isPrivateRepositoryForkingDisableAuditEntry = (
  object: Record<string, any>
): object is Partial<IPrivateRepositoryForkingDisableAuditEntry> => {
  return object.__typename === "PrivateRepositoryForkingDisableAuditEntry";
};

export const PrivateRepositoryForkingDisableAuditEntry: PrivateRepositoryForkingDisableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IPrivateRepositoryForkingEnableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "PrivateRepositoryForkingEnableAuditEntry";
}

interface PrivateRepositoryForkingEnableAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  enterpriseUrl: () => Field<"enterpriseUrl">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isPrivateRepositoryForkingEnableAuditEntry = (
  object: Record<string, any>
): object is Partial<IPrivateRepositoryForkingEnableAuditEntry> => {
  return object.__typename === "PrivateRepositoryForkingEnableAuditEntry";
};

export const PrivateRepositoryForkingEnableAuditEntry: PrivateRepositoryForkingEnableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IProfileItemShowcase {
  hasPinnedItems: boolean;
  items: IPinnableItemConnection;
}

interface ProfileItemShowcaseSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Whether or not the owner has pinned any repositories or gists.
   */

  hasPinnedItems: () => Field<"hasPinnedItems">;

  /**
     * @description The repositories and gists in the showcase. If the profile owner has any
pinned items, those will be returned. Otherwise, the profile owner's popular
repositories will be returned.
     */

  items: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "items",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;
}

export const ProfileItemShowcase: ProfileItemShowcaseSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Whether or not the owner has pinned any repositories or gists.
   */
  hasPinnedItems: () => new Field("hasPinnedItems"),

  /**
     * @description The repositories and gists in the showcase. If the profile owner has any
pinned items, those will be returned. Otherwise, the profile owner's popular
repositories will be returned.
     */

  items: (variables, select) =>
    new Field(
      "items",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),
};

export interface IProfileOwner {
  __typename: string;
  anyPinnableItems: boolean;
  email: string;
  id: string;
  itemShowcase: IProfileItemShowcase;
  location: string;
  login: string;
  name: string;
  pinnableItems: IPinnableItemConnection;
  pinnedItems: IPinnableItemConnection;
  pinnedItemsRemaining: number;
  viewerCanChangePinnedItems: boolean;
  websiteUrl: unknown;
}

interface ProfileOwnerSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */

  anyPinnableItems: (variables: {
    type: unknown;
  }) => Field<"anyPinnableItems", [/* @todo */]>;

  /**
   * @description The public profile email.
   */

  email: () => Field<"email">;

  id: () => Field<"id">;

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  itemShowcase: <T extends Array<Selection>>(
    select: (t: ProfileItemShowcaseSelector) => T
  ) => Field<"itemShowcase", never, SelectionSet<T>>;

  /**
   * @description The public profile location.
   */

  location: () => Field<"location">;

  /**
   * @description The username used to login.
   */

  login: () => Field<"login">;

  /**
   * @description The public profile name.
   */

  name: () => Field<"name">;

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  pinnableItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnableItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  pinnedItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnedItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */

  pinnedItemsRemaining: () => Field<"pinnedItemsRemaining">;

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */

  viewerCanChangePinnedItems: () => Field<"viewerCanChangePinnedItems">;

  /**
   * @description The public profile website URL.
   */

  websiteUrl: () => Field<"websiteUrl">;

  on: <T extends Array<Selection>, F extends "Organization" | "User">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const ProfileOwner: ProfileOwnerSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */
  anyPinnableItems: (variables) => new Field("anyPinnableItems"),

  /**
   * @description The public profile email.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  itemShowcase: (select) =>
    new Field(
      "itemShowcase",
      undefined as never,
      new SelectionSet(select(ProfileItemShowcase))
    ),

  /**
   * @description The public profile location.
   */
  location: () => new Field("location"),

  /**
   * @description The username used to login.
   */
  login: () => new Field("login"),

  /**
   * @description The public profile name.
   */
  name: () => new Field("name"),

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  pinnableItems: (variables, select) =>
    new Field(
      "pinnableItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  pinnedItems: (variables, select) =>
    new Field(
      "pinnedItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */
  pinnedItemsRemaining: () => new Field("pinnedItemsRemaining"),

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */
  viewerCanChangePinnedItems: () => new Field("viewerCanChangePinnedItems"),

  /**
   * @description The public profile website URL.
   */
  websiteUrl: () => new Field("websiteUrl"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IProject extends IClosable, INode, IUpdatable {
  __typename: "Project";
  body: string;
  bodyHTML: unknown;
  columns: IProjectColumnConnection;
  createdAt: unknown;
  creator: IActor;
  databaseId: number;
  name: string;
  number: number;
  owner: IProjectOwner;
  pendingCards: IProjectCardConnection;
  progress: IProjectProgress;
  resourcePath: unknown;
  state: ProjectState;
  updatedAt: unknown;
  url: unknown;
}

interface ProjectSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The project's description body.
   */

  body: () => Field<"body">;

  /**
   * @description The projects description body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */

  closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  closedAt: () => Field<"closedAt">;

  /**
   * @description List of columns in the project
   */

  columns: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectColumnConnectionSelector) => T
  ) => Field<
    "columns",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The actor who originally created the project.
   */

  creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description The project's name.
   */

  name: () => Field<"name">;

  /**
   * @description The project's number.
   */

  number: () => Field<"number">;

  /**
   * @description The project's owner. Currently limited to repositories, organizations, and users.
   */

  owner: <T extends Array<Selection>>(
    select: (t: ProjectOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description List of pending cards in this project
   */

  pendingCards: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      archivedStates?: Variable<"archivedStates"> | ProjectCardArchivedState;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectCardConnectionSelector) => T
  ) => Field<
    "pendingCards",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<
        "archivedStates",
        Variable<"archivedStates"> | ProjectCardArchivedState
      >,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Project progress details.
   */

  progress: <T extends Array<Selection>>(
    select: (t: ProjectProgressSelector) => T
  ) => Field<"progress", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this project
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Whether the project is open or closed.
   */

  state: () => Field<"state">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this project
   */

  url: () => Field<"url">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;
}

export const isProject = (
  object: Record<string, any>
): object is Partial<IProject> => {
  return object.__typename === "Project";
};

export const Project: ProjectSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The project's description body.
   */
  body: () => new Field("body"),

  /**
   * @description The projects description body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description `true` if the object is closed (definition of closed may depend on type)
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  /**
   * @description List of columns in the project
   */

  columns: (variables, select) =>
    new Field(
      "columns",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectColumnConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The actor who originally created the project.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The project's name.
   */
  name: () => new Field("name"),

  /**
   * @description The project's number.
   */
  number: () => new Field("number"),

  /**
   * @description The project's owner. Currently limited to repositories, organizations, and users.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(ProjectOwner))
    ),

  /**
   * @description List of pending cards in this project
   */

  pendingCards: (variables, select) =>
    new Field(
      "pendingCards",
      [
        new Argument("after", variables.after),
        new Argument(
          "archivedStates",
          variables.archivedStates,
          ProjectCardArchivedState
        ),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectCardConnection))
    ),

  /**
   * @description Project progress details.
   */

  progress: (select) =>
    new Field(
      "progress",
      undefined as never,
      new SelectionSet(select(ProjectProgress))
    ),

  /**
   * @description The HTTP path for this project
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Whether the project is open or closed.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this project
   */
  url: () => new Field("url"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),
};

export interface IProjectCard extends INode {
  __typename: "ProjectCard";
  column: IProjectColumn;
  content: IProjectCardItem;
  createdAt: unknown;
  creator: IActor;
  databaseId: number;
  isArchived: boolean;
  note: string;
  project: IProject;
  resourcePath: unknown;
  state: ProjectCardState;
  updatedAt: unknown;
  url: unknown;
}

interface ProjectCardSelector {
  __typename: () => Field<"__typename">;

  /**
     * @description The project column this card is associated under. A card may only belong to one
project column at a time. The column field will be null if the card is created
in a pending state and has yet to be associated with a column. Once cards are
associated with a column, they will not become pending in the future.
     */

  column: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"column", never, SelectionSet<T>>;

  /**
   * @description The card content item
   */

  content: <T extends Array<Selection>>(
    select: (t: ProjectCardItemSelector) => T
  ) => Field<"content", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The actor who created this card
   */

  creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description Whether the card is archived
   */

  isArchived: () => Field<"isArchived">;

  /**
   * @description The card note
   */

  note: () => Field<"note">;

  /**
   * @description The project that contains this card.
   */

  project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this card
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The state of ProjectCard
   */

  state: () => Field<"state">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this card
   */

  url: () => Field<"url">;
}

export const isProjectCard = (
  object: Record<string, any>
): object is Partial<IProjectCard> => {
  return object.__typename === "ProjectCard";
};

export const ProjectCard: ProjectCardSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description The project column this card is associated under. A card may only belong to one
project column at a time. The column field will be null if the card is created
in a pending state and has yet to be associated with a column. Once cards are
associated with a column, they will not become pending in the future.
     */

  column: (select) =>
    new Field(
      "column",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),

  /**
   * @description The card content item
   */

  content: (select) =>
    new Field(
      "content",
      undefined as never,
      new SelectionSet(select(ProjectCardItem))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The actor who created this card
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description Whether the card is archived
   */
  isArchived: () => new Field("isArchived"),

  /**
   * @description The card note
   */
  note: () => new Field("note"),

  /**
   * @description The project that contains this card.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description The HTTP path for this card
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The state of ProjectCard
   */
  state: () => new Field("state"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this card
   */
  url: () => new Field("url"),
};

export interface IProjectCardConnection {
  edges: IProjectCardEdge[];
  nodes: IProjectCard[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface ProjectCardConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ProjectCardEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: ProjectCardSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const ProjectCardConnection: ProjectCardConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ProjectCardEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ProjectCard))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IProjectCardEdge {
  cursor: string;
  node: IProjectCard;
}

interface ProjectCardEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: ProjectCardSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ProjectCardEdge: ProjectCardEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ProjectCard))
    ),
};

export interface IProjectColumn extends INode {
  __typename: "ProjectColumn";
  cards: IProjectCardConnection;
  createdAt: unknown;
  databaseId: number;
  name: string;
  project: IProject;
  purpose: ProjectColumnPurpose;
  resourcePath: unknown;
  updatedAt: unknown;
  url: unknown;
}

interface ProjectColumnSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description List of cards in the column
   */

  cards: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      archivedStates?: Variable<"archivedStates"> | ProjectCardArchivedState;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectCardConnectionSelector) => T
  ) => Field<
    "cards",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<
        "archivedStates",
        Variable<"archivedStates"> | ProjectCardArchivedState
      >,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description The project column's name.
   */

  name: () => Field<"name">;

  /**
   * @description The project that contains this column.
   */

  project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;

  /**
   * @description The semantic purpose of the column
   */

  purpose: () => Field<"purpose">;

  /**
   * @description The HTTP path for this project column
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this project column
   */

  url: () => Field<"url">;
}

export const isProjectColumn = (
  object: Record<string, any>
): object is Partial<IProjectColumn> => {
  return object.__typename === "ProjectColumn";
};

export const ProjectColumn: ProjectColumnSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description List of cards in the column
   */

  cards: (variables, select) =>
    new Field(
      "cards",
      [
        new Argument("after", variables.after),
        new Argument(
          "archivedStates",
          variables.archivedStates,
          ProjectCardArchivedState
        ),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectCardConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The project column's name.
   */
  name: () => new Field("name"),

  /**
   * @description The project that contains this column.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description The semantic purpose of the column
   */
  purpose: () => new Field("purpose"),

  /**
   * @description The HTTP path for this project column
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this project column
   */
  url: () => new Field("url"),
};

export interface IProjectColumnConnection {
  edges: IProjectColumnEdge[];
  nodes: IProjectColumn[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface ProjectColumnConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ProjectColumnEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const ProjectColumnConnection: ProjectColumnConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ProjectColumnEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IProjectColumnEdge {
  cursor: string;
  node: IProjectColumn;
}

interface ProjectColumnEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ProjectColumnEdge: ProjectColumnEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),
};

export interface IProjectConnection {
  edges: IProjectEdge[];
  nodes: IProject[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface ProjectConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ProjectEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const ProjectConnection: ProjectConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ProjectEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IProjectEdge {
  cursor: string;
  node: IProject;
}

interface ProjectEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ProjectEdge: ProjectEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Project))),
};

export interface IProjectOwner {
  __typename: string;
  id: string;
  project: IProject;
  projects: IProjectConnection;
  projectsResourcePath: unknown;
  projectsUrl: unknown;
  viewerCanCreateProjects: boolean;
}

interface ProjectOwnerSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description Find project by number.
   */

  project: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: ProjectSelector) => T
  ) => Field<
    "project",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of projects under the owner.
   */

  projects: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ProjectOrder;
      search?: Variable<"search"> | string;
      states?: Variable<"states"> | ProjectState;
    },
    select: (t: ProjectConnectionSelector) => T
  ) => Field<
    "projects",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ProjectOrder>,
      Argument<"search", Variable<"search"> | string>,
      Argument<"states", Variable<"states"> | ProjectState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing owners projects
   */

  projectsResourcePath: () => Field<"projectsResourcePath">;

  /**
   * @description The HTTP URL listing owners projects
   */

  projectsUrl: () => Field<"projectsUrl">;

  /**
   * @description Can the current viewer create new projects on this owner.
   */

  viewerCanCreateProjects: () => Field<"viewerCanCreateProjects">;

  on: <
    T extends Array<Selection>,
    F extends "Organization" | "Repository" | "User"
  >(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const ProjectOwner: ProjectOwnerSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Find project by number.
   */

  project: (variables, select) =>
    new Field(
      "project",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Project))
    ),

  /**
   * @description A list of projects under the owner.
   */

  projects: (variables, select) =>
    new Field(
      "projects",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("search", variables.search),
        new Argument("states", variables.states, ProjectState),
      ],
      new SelectionSet(select(ProjectConnection))
    ),

  /**
   * @description The HTTP path listing owners projects
   */
  projectsResourcePath: () => new Field("projectsResourcePath"),

  /**
   * @description The HTTP URL listing owners projects
   */
  projectsUrl: () => new Field("projectsUrl"),

  /**
   * @description Can the current viewer create new projects on this owner.
   */
  viewerCanCreateProjects: () => new Field("viewerCanCreateProjects"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IProjectProgress {
  doneCount: number;
  donePercentage: number;
  enabled: boolean;
  inProgressCount: number;
  inProgressPercentage: number;
  todoCount: number;
  todoPercentage: number;
}

interface ProjectProgressSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The number of done cards.
   */

  doneCount: () => Field<"doneCount">;

  /**
   * @description The percentage of done cards.
   */

  donePercentage: () => Field<"donePercentage">;

  /**
   * @description Whether progress tracking is enabled and cards with purpose exist for this project
   */

  enabled: () => Field<"enabled">;

  /**
   * @description The number of in-progress cards.
   */

  inProgressCount: () => Field<"inProgressCount">;

  /**
   * @description The percentage of in-progress cards.
   */

  inProgressPercentage: () => Field<"inProgressPercentage">;

  /**
   * @description The number of to do cards.
   */

  todoCount: () => Field<"todoCount">;

  /**
   * @description The percentage of to do cards.
   */

  todoPercentage: () => Field<"todoPercentage">;
}

export const ProjectProgress: ProjectProgressSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The number of done cards.
   */
  doneCount: () => new Field("doneCount"),

  /**
   * @description The percentage of done cards.
   */
  donePercentage: () => new Field("donePercentage"),

  /**
   * @description Whether progress tracking is enabled and cards with purpose exist for this project
   */
  enabled: () => new Field("enabled"),

  /**
   * @description The number of in-progress cards.
   */
  inProgressCount: () => new Field("inProgressCount"),

  /**
   * @description The percentage of in-progress cards.
   */
  inProgressPercentage: () => new Field("inProgressPercentage"),

  /**
   * @description The number of to do cards.
   */
  todoCount: () => new Field("todoCount"),

  /**
   * @description The percentage of to do cards.
   */
  todoPercentage: () => new Field("todoPercentage"),
};

export interface IPublicKey extends INode {
  __typename: "PublicKey";
  accessedAt: unknown;
  createdAt: unknown;
  fingerprint: string;
  isReadOnly: boolean;
  key: string;
  updatedAt: unknown;
}

interface PublicKeySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The last time this authorization was used to perform an action. Values will be null for keys not owned by the user.
   */

  accessedAt: () => Field<"accessedAt">;

  /**
     * @description Identifies the date and time when the key was created. Keys created before
March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
     */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The fingerprint for this PublicKey.
   */

  fingerprint: () => Field<"fingerprint">;

  id: () => Field<"id">;

  /**
   * @description Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user.
   */

  isReadOnly: () => Field<"isReadOnly">;

  /**
   * @description The public key string.
   */

  key: () => Field<"key">;

  /**
     * @description Identifies the date and time when the key was updated. Keys created before
March 5th, 2014 may have inaccurate values. Values will be null for keys not
owned by the user.
     */

  updatedAt: () => Field<"updatedAt">;
}

export const isPublicKey = (
  object: Record<string, any>
): object is Partial<IPublicKey> => {
  return object.__typename === "PublicKey";
};

export const PublicKey: PublicKeySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The last time this authorization was used to perform an action. Values will be null for keys not owned by the user.
   */
  accessedAt: () => new Field("accessedAt"),

  /**
     * @description Identifies the date and time when the key was created. Keys created before
March 5th, 2014 have inaccurate values. Values will be null for keys not owned by the user.
     */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The fingerprint for this PublicKey.
   */
  fingerprint: () => new Field("fingerprint"),
  id: () => new Field("id"),

  /**
   * @description Whether this PublicKey is read-only or not. Values will be null for keys not owned by the user.
   */
  isReadOnly: () => new Field("isReadOnly"),

  /**
   * @description The public key string.
   */
  key: () => new Field("key"),

  /**
     * @description Identifies the date and time when the key was updated. Keys created before
March 5th, 2014 may have inaccurate values. Values will be null for keys not
owned by the user.
     */
  updatedAt: () => new Field("updatedAt"),
};

export interface IPublicKeyConnection {
  edges: IPublicKeyEdge[];
  nodes: IPublicKey[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PublicKeyConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PublicKeyEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PublicKeySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PublicKeyConnection: PublicKeyConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PublicKeyEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(PublicKey))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPublicKeyEdge {
  cursor: string;
  node: IPublicKey;
}

interface PublicKeyEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PublicKeySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PublicKeyEdge: PublicKeyEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(PublicKey))),
};

export interface IPullRequest
  extends IAssignable,
    IClosable,
    IComment,
    ILabelable,
    ILockable,
    INode,
    IReactable,
    IRepositoryNode,
    ISubscribable,
    IUniformResourceLocatable,
    IUpdatable,
    IUpdatableComment {
  __typename: "PullRequest";
  additions: number;
  baseRef: IRef;
  baseRefName: string;
  baseRefOid: unknown;
  baseRepository: IRepository;
  changedFiles: number;
  checksResourcePath: unknown;
  checksUrl: unknown;
  comments: IIssueCommentConnection;
  commits: IPullRequestCommitConnection;
  deletions: number;
  files: IPullRequestChangedFileConnection;
  headRef: IRef;
  headRefName: string;
  headRefOid: unknown;
  headRepository: IRepository;
  headRepositoryOwner: IRepositoryOwner;
  hovercard: IHovercard;
  isCrossRepository: boolean;
  isDraft: boolean;
  isReadByViewer: boolean;
  latestOpinionatedReviews: IPullRequestReviewConnection;
  latestReviews: IPullRequestReviewConnection;
  maintainerCanModify: boolean;
  mergeCommit: ICommit;
  mergeable: MergeableState;
  merged: boolean;
  mergedAt: unknown;
  mergedBy: IActor;
  milestone: IMilestone;
  number: number;
  participants: IUserConnection;
  permalink: unknown;
  potentialMergeCommit: ICommit;
  projectCards: IProjectCardConnection;
  revertResourcePath: unknown;
  revertUrl: unknown;
  reviewDecision: PullRequestReviewDecision;
  reviewRequests: IReviewRequestConnection;
  reviewThreads: IPullRequestReviewThreadConnection;
  reviews: IPullRequestReviewConnection;
  state: PullRequestState;
  suggestedReviewers: ISuggestedReviewer[];
  timeline: IPullRequestTimelineConnection;
  timelineItems: IPullRequestTimelineItemsConnection;
  title: string;
  viewerCanApplySuggestion: boolean;
  viewerCanDeleteHeadRef: boolean;
  viewerMergeBodyText: string;
  viewerMergeHeadlineText: string;
}

interface PullRequestSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Reason that the conversation was locked.
   */

  activeLockReason: () => Field<"activeLockReason">;

  /**
   * @description The number of additions in this pull request.
   */

  additions: () => Field<"additions">;

  /**
   * @description A list of Users assigned to this object.
   */

  assignees: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "assignees",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Identifies the base Ref associated with the pull request.
   */

  baseRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"baseRef", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted.
   */

  baseRefName: () => Field<"baseRefName">;

  /**
   * @description Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted.
   */

  baseRefOid: () => Field<"baseRefOid">;

  /**
   * @description The repository associated with this pull request's base Ref.
   */

  baseRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"baseRepository", never, SelectionSet<T>>;

  /**
   * @description The body as Markdown.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description The number of changed files in this pull request.
   */

  changedFiles: () => Field<"changedFiles">;

  /**
   * @description The HTTP path for the checks of this pull request.
   */

  checksResourcePath: () => Field<"checksResourcePath">;

  /**
   * @description The HTTP URL for the checks of this pull request.
   */

  checksUrl: () => Field<"checksUrl">;

  /**
   * @description `true` if the pull request is closed
   */

  closed: () => Field<"closed">;

  /**
   * @description Identifies the date and time when the object was closed.
   */

  closedAt: () => Field<"closedAt">;

  /**
   * @description A list of comments associated with the pull request.
   */

  comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueCommentOrder;
    },
    select: (t: IssueCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueCommentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of commits present in this pull request's head branch not present in the base branch.
   */

  commits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestCommitConnectionSelector) => T
  ) => Field<
    "commits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The number of deletions in this pull request.
   */

  deletions: () => Field<"deletions">;

  /**
   * @description The actor who edited this pull request's body.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  /**
   * @description Lists the files changed within this pull request.
   */

  files: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestChangedFileConnectionSelector) => T
  ) => Field<
    "files",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the head Ref associated with the pull request.
   */

  headRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"headRef", never, SelectionSet<T>>;

  /**
   * @description Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted.
   */

  headRefName: () => Field<"headRefName">;

  /**
   * @description Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted.
   */

  headRefOid: () => Field<"headRefOid">;

  /**
   * @description The repository associated with this pull request's head Ref.
   */

  headRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"headRepository", never, SelectionSet<T>>;

  /**
   * @description The owner of the repository associated with this pull request's head Ref.
   */

  headRepositoryOwner: <T extends Array<Selection>>(
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<"headRepositoryOwner", never, SelectionSet<T>>;

  /**
   * @description The hovercard information for this issue
   */

  hovercard: <T extends Array<Selection>>(
    variables: {
      includeNotificationContexts?:
        | Variable<"includeNotificationContexts">
        | boolean;
    },
    select: (t: HovercardSelector) => T
  ) => Field<
    "hovercard",
    [
      Argument<
        "includeNotificationContexts",
        Variable<"includeNotificationContexts"> | boolean
      >
    ],
    SelectionSet<T>
  >;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description The head and base repositories are different.
   */

  isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Identifies if the pull request is a draft.
   */

  isDraft: () => Field<"isDraft">;

  /**
   * @description Is this pull request read by the viewer
   */

  isReadByViewer: () => Field<"isReadByViewer">;

  /**
   * @description A list of labels associated with the object.
   */

  labels: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LabelOrder;
    },
    select: (t: LabelConnectionSelector) => T
  ) => Field<
    "labels",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LabelOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description A list of latest reviews per user associated with the pull request.
   */

  latestOpinionatedReviews: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      writersOnly?: Variable<"writersOnly"> | boolean;
    },
    select: (t: PullRequestReviewConnectionSelector) => T
  ) => Field<
    "latestOpinionatedReviews",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"writersOnly", Variable<"writersOnly"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of latest reviews per user associated with the pull request that are not also pending review.
   */

  latestReviews: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestReviewConnectionSelector) => T
  ) => Field<
    "latestReviews",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description `true` if the pull request is locked
   */

  locked: () => Field<"locked">;

  /**
   * @description Indicates whether maintainers can modify the pull request.
   */

  maintainerCanModify: () => Field<"maintainerCanModify">;

  /**
   * @description The commit that was created when this pull request was merged.
   */

  mergeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"mergeCommit", never, SelectionSet<T>>;

  /**
   * @description Whether or not the pull request can be merged based on the existence of merge conflicts.
   */

  mergeable: () => Field<"mergeable">;

  /**
   * @description Whether or not the pull request was merged.
   */

  merged: () => Field<"merged">;

  /**
   * @description The date and time that the pull request was merged.
   */

  mergedAt: () => Field<"mergedAt">;

  /**
   * @description The actor who merged the pull request.
   */

  mergedBy: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"mergedBy", never, SelectionSet<T>>;

  /**
   * @description Identifies the milestone associated with the pull request.
   */

  milestone: <T extends Array<Selection>>(
    select: (t: MilestoneSelector) => T
  ) => Field<"milestone", never, SelectionSet<T>>;

  /**
   * @description Identifies the pull request number.
   */

  number: () => Field<"number">;

  /**
   * @description A list of Users that are participating in the Pull Request conversation.
   */

  participants: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "participants",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The permalink to the pull request.
   */

  permalink: () => Field<"permalink">;

  /**
     * @description The commit that GitHub automatically generated to test if this pull request
could be merged. This field will not return a value if the pull request is
merged, or if the test merge commit is still being generated. See the
`mergeable` field for more details on the mergeability of the pull request.
     */

  potentialMergeCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"potentialMergeCommit", never, SelectionSet<T>>;

  /**
   * @description List of project cards associated with this pull request.
   */

  projectCards: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      archivedStates?: Variable<"archivedStates"> | ProjectCardArchivedState;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ProjectCardConnectionSelector) => T
  ) => Field<
    "projectCards",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<
        "archivedStates",
        Variable<"archivedStates"> | ProjectCardArchivedState
      >,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this pull request.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP path for reverting this pull request.
   */

  revertResourcePath: () => Field<"revertResourcePath">;

  /**
   * @description The HTTP URL for reverting this pull request.
   */

  revertUrl: () => Field<"revertUrl">;

  /**
   * @description The current status of this pull request with respect to code review.
   */

  reviewDecision: () => Field<"reviewDecision">;

  /**
   * @description A list of review requests associated with the pull request.
   */

  reviewRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ReviewRequestConnectionSelector) => T
  ) => Field<
    "reviewRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The list of all review threads for this pull request.
   */

  reviewThreads: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestReviewThreadConnectionSelector) => T
  ) => Field<
    "reviewThreads",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of reviews associated with the pull request.
   */

  reviews: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      author?: Variable<"author"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      states?: Variable<"states"> | PullRequestReviewState;
    },
    select: (t: PullRequestReviewConnectionSelector) => T
  ) => Field<
    "reviews",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"author", Variable<"author"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"states", Variable<"states"> | PullRequestReviewState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the state of the pull request.
   */

  state: () => Field<"state">;

  /**
   * @description A list of reviewer suggestions based on commit history and past review comments.
   */

  suggestedReviewers: <T extends Array<Selection>>(
    select: (t: SuggestedReviewerSelector) => T
  ) => Field<"suggestedReviewers", never, SelectionSet<T>>;

  /**
   * @description A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */

  timeline: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      since?: Variable<"since"> | unknown;
    },
    select: (t: PullRequestTimelineConnectionSelector) => T
  ) => Field<
    "timeline",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"since", Variable<"since"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of events, comments, commits, etc. associated with the pull request.
   */

  timelineItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      itemTypes?: Variable<"itemTypes"> | PullRequestTimelineItemsItemType;
      last?: Variable<"last"> | number;
      since?: Variable<"since"> | unknown;
      skip?: Variable<"skip"> | number;
    },
    select: (t: PullRequestTimelineItemsConnectionSelector) => T
  ) => Field<
    "timelineItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<
        "itemTypes",
        Variable<"itemTypes"> | PullRequestTimelineItemsItemType
      >,
      Argument<"last", Variable<"last"> | number>,
      Argument<"since", Variable<"since"> | unknown>,
      Argument<"skip", Variable<"skip"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the pull request title.
   */

  title: () => Field<"title">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this pull request.
   */

  url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not the viewer can apply suggestion.
   */

  viewerCanApplySuggestion: () => Field<"viewerCanApplySuggestion">;

  /**
   * @description Check if the viewer can restore the deleted head ref.
   */

  viewerCanDeleteHeadRef: () => Field<"viewerCanDeleteHeadRef">;

  /**
   * @description Can user react to this subject
   */

  viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;

  /**
   * @description The merge body text for the viewer and method.
   */

  viewerMergeBodyText: (variables: {
    mergeType: unknown;
  }) => Field<"viewerMergeBodyText", [/* @todo */]>;

  /**
   * @description The merge headline text for the viewer and method.
   */

  viewerMergeHeadlineText: (variables: {
    mergeType: unknown;
  }) => Field<"viewerMergeHeadlineText", [/* @todo */]>;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  viewerSubscription: () => Field<"viewerSubscription">;
}

export const isPullRequest = (
  object: Record<string, any>
): object is Partial<IPullRequest> => {
  return object.__typename === "PullRequest";
};

export const PullRequest: PullRequestSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Reason that the conversation was locked.
   */
  activeLockReason: () => new Field("activeLockReason"),

  /**
   * @description The number of additions in this pull request.
   */
  additions: () => new Field("additions"),

  /**
   * @description A list of Users assigned to this object.
   */

  assignees: (variables, select) =>
    new Field(
      "assignees",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Identifies the base Ref associated with the pull request.
   */

  baseRef: (select) =>
    new Field("baseRef", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the name of the base Ref associated with the pull request, even if the ref has been deleted.
   */
  baseRefName: () => new Field("baseRefName"),

  /**
   * @description Identifies the oid of the base ref associated with the pull request, even if the ref has been deleted.
   */
  baseRefOid: () => new Field("baseRefOid"),

  /**
   * @description The repository associated with this pull request's base Ref.
   */

  baseRepository: (select) =>
    new Field(
      "baseRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description The number of changed files in this pull request.
   */
  changedFiles: () => new Field("changedFiles"),

  /**
   * @description The HTTP path for the checks of this pull request.
   */
  checksResourcePath: () => new Field("checksResourcePath"),

  /**
   * @description The HTTP URL for the checks of this pull request.
   */
  checksUrl: () => new Field("checksUrl"),

  /**
   * @description `true` if the pull request is closed
   */
  closed: () => new Field("closed"),

  /**
   * @description Identifies the date and time when the object was closed.
   */
  closedAt: () => new Field("closedAt"),

  /**
   * @description A list of comments associated with the pull request.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IssueCommentConnection))
    ),

  /**
   * @description A list of commits present in this pull request's head branch not present in the base branch.
   */

  commits: (variables, select) =>
    new Field(
      "commits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestCommitConnection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The number of deletions in this pull request.
   */
  deletions: () => new Field("deletions"),

  /**
   * @description The actor who edited this pull request's body.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Lists the files changed within this pull request.
   */

  files: (variables, select) =>
    new Field(
      "files",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestChangedFileConnection))
    ),

  /**
   * @description Identifies the head Ref associated with the pull request.
   */

  headRef: (select) =>
    new Field("headRef", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Identifies the name of the head Ref associated with the pull request, even if the ref has been deleted.
   */
  headRefName: () => new Field("headRefName"),

  /**
   * @description Identifies the oid of the head ref associated with the pull request, even if the ref has been deleted.
   */
  headRefOid: () => new Field("headRefOid"),

  /**
   * @description The repository associated with this pull request's head Ref.
   */

  headRepository: (select) =>
    new Field(
      "headRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The owner of the repository associated with this pull request's head Ref.
   */

  headRepositoryOwner: (select) =>
    new Field(
      "headRepositoryOwner",
      undefined as never,
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description The hovercard information for this issue
   */

  hovercard: (variables, select) =>
    new Field(
      "hovercard",
      [
        new Argument(
          "includeNotificationContexts",
          variables.includeNotificationContexts
        ),
      ],
      new SelectionSet(select(Hovercard))
    ),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description The head and base repositories are different.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Identifies if the pull request is a draft.
   */
  isDraft: () => new Field("isDraft"),

  /**
   * @description Is this pull request read by the viewer
   */
  isReadByViewer: () => new Field("isReadByViewer"),

  /**
   * @description A list of labels associated with the object.
   */

  labels: (variables, select) =>
    new Field(
      "labels",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(LabelConnection))
    ),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description A list of latest reviews per user associated with the pull request.
   */

  latestOpinionatedReviews: (variables, select) =>
    new Field(
      "latestOpinionatedReviews",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("writersOnly", variables.writersOnly),
      ],
      new SelectionSet(select(PullRequestReviewConnection))
    ),

  /**
   * @description A list of latest reviews per user associated with the pull request that are not also pending review.
   */

  latestReviews: (variables, select) =>
    new Field(
      "latestReviews",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestReviewConnection))
    ),

  /**
   * @description `true` if the pull request is locked
   */
  locked: () => new Field("locked"),

  /**
   * @description Indicates whether maintainers can modify the pull request.
   */
  maintainerCanModify: () => new Field("maintainerCanModify"),

  /**
   * @description The commit that was created when this pull request was merged.
   */

  mergeCommit: (select) =>
    new Field(
      "mergeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description Whether or not the pull request can be merged based on the existence of merge conflicts.
   */
  mergeable: () => new Field("mergeable"),

  /**
   * @description Whether or not the pull request was merged.
   */
  merged: () => new Field("merged"),

  /**
   * @description The date and time that the pull request was merged.
   */
  mergedAt: () => new Field("mergedAt"),

  /**
   * @description The actor who merged the pull request.
   */

  mergedBy: (select) =>
    new Field("mergedBy", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the milestone associated with the pull request.
   */

  milestone: (select) =>
    new Field(
      "milestone",
      undefined as never,
      new SelectionSet(select(Milestone))
    ),

  /**
   * @description Identifies the pull request number.
   */
  number: () => new Field("number"),

  /**
   * @description A list of Users that are participating in the Pull Request conversation.
   */

  participants: (variables, select) =>
    new Field(
      "participants",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description The permalink to the pull request.
   */
  permalink: () => new Field("permalink"),

  /**
     * @description The commit that GitHub automatically generated to test if this pull request
could be merged. This field will not return a value if the pull request is
merged, or if the test merge commit is still being generated. See the
`mergeable` field for more details on the mergeability of the pull request.
     */

  potentialMergeCommit: (select) =>
    new Field(
      "potentialMergeCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description List of project cards associated with this pull request.
   */

  projectCards: (variables, select) =>
    new Field(
      "projectCards",
      [
        new Argument("after", variables.after),
        new Argument(
          "archivedStates",
          variables.archivedStates,
          ProjectCardArchivedState
        ),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ProjectCardConnection))
    ),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this pull request.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP path for reverting this pull request.
   */
  revertResourcePath: () => new Field("revertResourcePath"),

  /**
   * @description The HTTP URL for reverting this pull request.
   */
  revertUrl: () => new Field("revertUrl"),

  /**
   * @description The current status of this pull request with respect to code review.
   */
  reviewDecision: () => new Field("reviewDecision"),

  /**
   * @description A list of review requests associated with the pull request.
   */

  reviewRequests: (variables, select) =>
    new Field(
      "reviewRequests",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ReviewRequestConnection))
    ),

  /**
   * @description The list of all review threads for this pull request.
   */

  reviewThreads: (variables, select) =>
    new Field(
      "reviewThreads",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestReviewThreadConnection))
    ),

  /**
   * @description A list of reviews associated with the pull request.
   */

  reviews: (variables, select) =>
    new Field(
      "reviews",
      [
        new Argument("after", variables.after),
        new Argument("author", variables.author),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("states", variables.states, PullRequestReviewState),
      ],
      new SelectionSet(select(PullRequestReviewConnection))
    ),

  /**
   * @description Identifies the state of the pull request.
   */
  state: () => new Field("state"),

  /**
   * @description A list of reviewer suggestions based on commit history and past review comments.
   */

  suggestedReviewers: (select) =>
    new Field(
      "suggestedReviewers",
      undefined as never,
      new SelectionSet(select(SuggestedReviewer))
    ),

  /**
   * @description A list of events, comments, commits, etc. associated with the pull request.
   * @deprecated `timeline` will be removed Use PullRequest.timelineItems instead. Removal on 2020-10-01 UTC.
   */

  timeline: (variables, select) =>
    new Field(
      "timeline",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("since", variables.since),
      ],
      new SelectionSet(select(PullRequestTimelineConnection))
    ),

  /**
   * @description A list of events, comments, commits, etc. associated with the pull request.
   */

  timelineItems: (variables, select) =>
    new Field(
      "timelineItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument(
          "itemTypes",
          variables.itemTypes,
          PullRequestTimelineItemsItemType
        ),
        new Argument("last", variables.last),
        new Argument("since", variables.since),
        new Argument("skip", variables.skip),
      ],
      new SelectionSet(select(PullRequestTimelineItemsConnection))
    ),

  /**
   * @description Identifies the pull request title.
   */
  title: () => new Field("title"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this pull request.
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Whether or not the viewer can apply suggestion.
   */
  viewerCanApplySuggestion: () => new Field("viewerCanApplySuggestion"),

  /**
   * @description Check if the viewer can restore the deleted head ref.
   */
  viewerCanDeleteHeadRef: () => new Field("viewerCanDeleteHeadRef"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),

  /**
   * @description The merge body text for the viewer and method.
   */
  viewerMergeBodyText: (variables) => new Field("viewerMergeBodyText"),

  /**
   * @description The merge headline text for the viewer and method.
   */
  viewerMergeHeadlineText: (variables) => new Field("viewerMergeHeadlineText"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),
};

export interface IPullRequestChangedFile {
  additions: number;
  deletions: number;
  path: string;
  viewerViewedState: FileViewedState;
}

interface PullRequestChangedFileSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The number of additions to the file.
   */

  additions: () => Field<"additions">;

  /**
   * @description The number of deletions to the file.
   */

  deletions: () => Field<"deletions">;

  /**
   * @description The path of the file.
   */

  path: () => Field<"path">;

  /**
   * @description The state of the file for the viewer.
   */

  viewerViewedState: () => Field<"viewerViewedState">;
}

export const PullRequestChangedFile: PullRequestChangedFileSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The number of additions to the file.
   */
  additions: () => new Field("additions"),

  /**
   * @description The number of deletions to the file.
   */
  deletions: () => new Field("deletions"),

  /**
   * @description The path of the file.
   */
  path: () => new Field("path"),

  /**
   * @description The state of the file for the viewer.
   */
  viewerViewedState: () => new Field("viewerViewedState"),
};

export interface IPullRequestChangedFileConnection {
  edges: IPullRequestChangedFileEdge[];
  nodes: IPullRequestChangedFile[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PullRequestChangedFileConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PullRequestChangedFileEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PullRequestChangedFileSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PullRequestChangedFileConnection: PullRequestChangedFileConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestChangedFileEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestChangedFile))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestChangedFileEdge {
  cursor: string;
  node: IPullRequestChangedFile;
}

interface PullRequestChangedFileEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PullRequestChangedFileSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestChangedFileEdge: PullRequestChangedFileEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestChangedFile))
    ),
};

export interface IPullRequestCommit extends INode, IUniformResourceLocatable {
  __typename: "PullRequestCommit";
  commit: ICommit;
  pullRequest: IPullRequest;
}

interface PullRequestCommitSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The Git commit object
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description The pull request this commit belongs to
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this pull request commit
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this pull request commit
   */

  url: () => Field<"url">;
}

export const isPullRequestCommit = (
  object: Record<string, any>
): object is Partial<IPullRequestCommit> => {
  return object.__typename === "PullRequestCommit";
};

export const PullRequestCommit: PullRequestCommitSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The Git commit object
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  id: () => new Field("id"),

  /**
   * @description The pull request this commit belongs to
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this pull request commit
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this pull request commit
   */
  url: () => new Field("url"),
};

export interface IPullRequestCommitCommentThread
  extends INode,
    IRepositoryNode {
  __typename: "PullRequestCommitCommentThread";
  comments: ICommitCommentConnection;
  commit: ICommit;
  path: string;
  position: number;
  pullRequest: IPullRequest;
}

interface PullRequestCommitCommentThreadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The comments that exist in this thread.
   */

  comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The commit the comments were made on.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description The file the comments were made on.
   */

  path: () => Field<"path">;

  /**
   * @description The position in the diff for the commit that the comment was made on.
   */

  position: () => Field<"position">;

  /**
   * @description The pull request this commit comment thread belongs to
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The repository associated with this node.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isPullRequestCommitCommentThread = (
  object: Record<string, any>
): object is Partial<IPullRequestCommitCommentThread> => {
  return object.__typename === "PullRequestCommitCommentThread";
};

export const PullRequestCommitCommentThread: PullRequestCommitCommentThreadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The comments that exist in this thread.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description The commit the comments were made on.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  id: () => new Field("id"),

  /**
   * @description The file the comments were made on.
   */
  path: () => new Field("path"),

  /**
   * @description The position in the diff for the commit that the comment was made on.
   */
  position: () => new Field("position"),

  /**
   * @description The pull request this commit comment thread belongs to
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IPullRequestCommitConnection {
  edges: IPullRequestCommitEdge[];
  nodes: IPullRequestCommit[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PullRequestCommitConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PullRequestCommitEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PullRequestCommitSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PullRequestCommitConnection: PullRequestCommitConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestCommitEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestCommit))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestCommitEdge {
  cursor: string;
  node: IPullRequestCommit;
}

interface PullRequestCommitEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PullRequestCommitSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestCommitEdge: PullRequestCommitEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestCommit))
    ),
};

export interface IPullRequestConnection {
  edges: IPullRequestEdge[];
  nodes: IPullRequest[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PullRequestConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PullRequestEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PullRequestConnection: PullRequestConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestContributionsByRepository {
  contributions: ICreatedPullRequestContributionConnection;
  repository: IRepository;
}

interface PullRequestContributionsByRepositorySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The pull request contributions.
   */

  contributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedPullRequestContributionConnectionSelector) => T
  ) => Field<
    "contributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository in which the pull requests were opened.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const PullRequestContributionsByRepository: PullRequestContributionsByRepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The pull request contributions.
   */

  contributions: (variables, select) =>
    new Field(
      "contributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedPullRequestContributionConnection))
    ),

  /**
   * @description The repository in which the pull requests were opened.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IPullRequestEdge {
  cursor: string;
  node: IPullRequest;
}

interface PullRequestEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestEdge: PullRequestEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IPullRequestReview
  extends IComment,
    IDeletable,
    INode,
    IReactable,
    IRepositoryNode,
    IUpdatable,
    IUpdatableComment {
  __typename: "PullRequestReview";
  authorCanPushToRepository: boolean;
  comments: IPullRequestReviewCommentConnection;
  commit: ICommit;
  onBehalfOf: ITeamConnection;
  pullRequest: IPullRequest;
  resourcePath: unknown;
  state: PullRequestReviewState;
  submittedAt: unknown;
  url: unknown;
}

interface PullRequestReviewSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description Indicates whether the author of this review has push access to the repository.
   */

  authorCanPushToRepository: () => Field<"authorCanPushToRepository">;

  /**
   * @description Identifies the pull request review body.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body of this review rendered as plain text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description A list of review comments for the current pull request review.
   */

  comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PullRequestReviewCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the commit associated with this pull request review.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description A list of teams that this review was made on behalf of.
   */

  onBehalfOf: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "onBehalfOf",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description Identifies the pull request associated with this pull request review.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository associated with this node.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path permalink for this PullRequestReview.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the current state of the pull request review.
   */

  state: () => Field<"state">;

  /**
   * @description Identifies when the Pull Request Review was submitted
   */

  submittedAt: () => Field<"submittedAt">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL permalink for this PullRequestReview.
   */

  url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Can user react to this subject
   */

  viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isPullRequestReview = (
  object: Record<string, any>
): object is Partial<IPullRequestReview> => {
  return object.__typename === "PullRequestReview";
};

export const PullRequestReview: PullRequestReviewSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description Indicates whether the author of this review has push access to the repository.
   */
  authorCanPushToRepository: () => new Field("authorCanPushToRepository"),

  /**
   * @description Identifies the pull request review body.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body of this review rendered as plain text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description A list of review comments for the current pull request review.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PullRequestReviewCommentConnection))
    ),

  /**
   * @description Identifies the commit associated with this pull request review.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description A list of teams that this review was made on behalf of.
   */

  onBehalfOf: (variables, select) =>
    new Field(
      "onBehalfOf",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description Identifies the pull request associated with this pull request review.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path permalink for this PullRequestReview.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the current state of the pull request review.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies when the Pull Request Review was submitted
   */
  submittedAt: () => new Field("submittedAt"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL permalink for this PullRequestReview.
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface IPullRequestReviewComment
  extends IComment,
    IDeletable,
    IMinimizable,
    INode,
    IReactable,
    IRepositoryNode,
    IUpdatable,
    IUpdatableComment {
  __typename: "PullRequestReviewComment";
  commit: ICommit;
  diffHunk: string;
  draftedAt: unknown;
  originalCommit: ICommit;
  originalPosition: number;
  outdated: boolean;
  path: string;
  position: number;
  pullRequest: IPullRequest;
  pullRequestReview: IPullRequestReview;
  replyTo: IPullRequestReviewComment;
  resourcePath: unknown;
  state: PullRequestReviewCommentState;
  url: unknown;
}

interface PullRequestReviewCommentSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the subject of the comment.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The comment body of this review comment.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The comment body of this review comment rendered as plain text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the commit associated with the comment.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies when the comment was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The diff hunk to which the comment applies.
   */

  diffHunk: () => Field<"diffHunk">;

  /**
   * @description Identifies when the comment was created in a draft state.
   */

  draftedAt: () => Field<"draftedAt">;

  /**
   * @description The actor who edited the comment.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Returns whether or not a comment has been minimized.
   */

  isMinimized: () => Field<"isMinimized">;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Returns why the comment was minimized.
   */

  minimizedReason: () => Field<"minimizedReason">;

  /**
   * @description Identifies the original commit associated with the comment.
   */

  originalCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"originalCommit", never, SelectionSet<T>>;

  /**
   * @description The original line index in the diff to which the comment applies.
   */

  originalPosition: () => Field<"originalPosition">;

  /**
   * @description Identifies when the comment body is outdated
   */

  outdated: () => Field<"outdated">;

  /**
   * @description The path to which the comment applies.
   */

  path: () => Field<"path">;

  /**
   * @description The line index in the diff to which the comment applies.
   */

  position: () => Field<"position">;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description The pull request associated with this review comment.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The pull request review associated with this review comment.
   */

  pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The comment this is a reply to.
   */

  replyTo: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"replyTo", never, SelectionSet<T>>;

  /**
   * @description The repository associated with this node.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The HTTP path permalink for this review comment.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the state of the comment.
   */

  state: () => Field<"state">;

  /**
   * @description Identifies when the comment was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL permalink for this review comment.
   */

  url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Check if the current viewer can minimize this object.
   */

  viewerCanMinimize: () => Field<"viewerCanMinimize">;

  /**
   * @description Can user react to this subject
   */

  viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isPullRequestReviewComment = (
  object: Record<string, any>
): object is Partial<IPullRequestReviewComment> => {
  return object.__typename === "PullRequestReviewComment";
};

export const PullRequestReviewComment: PullRequestReviewCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the subject of the comment.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The comment body of this review comment.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The comment body of this review comment rendered as plain text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the commit associated with the comment.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies when the comment was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The diff hunk to which the comment applies.
   */
  diffHunk: () => new Field("diffHunk"),

  /**
   * @description Identifies when the comment was created in a draft state.
   */
  draftedAt: () => new Field("draftedAt"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Returns whether or not a comment has been minimized.
   */
  isMinimized: () => new Field("isMinimized"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Returns why the comment was minimized.
   */
  minimizedReason: () => new Field("minimizedReason"),

  /**
   * @description Identifies the original commit associated with the comment.
   */

  originalCommit: (select) =>
    new Field(
      "originalCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description The original line index in the diff to which the comment applies.
   */
  originalPosition: () => new Field("originalPosition"),

  /**
   * @description Identifies when the comment body is outdated
   */
  outdated: () => new Field("outdated"),

  /**
   * @description The path to which the comment applies.
   */
  path: () => new Field("path"),

  /**
   * @description The line index in the diff to which the comment applies.
   */
  position: () => new Field("position"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description The pull request associated with this review comment.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The pull request review associated with this review comment.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The comment this is a reply to.
   */

  replyTo: (select) =>
    new Field(
      "replyTo",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path permalink for this review comment.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the state of the comment.
   */
  state: () => new Field("state"),

  /**
   * @description Identifies when the comment was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL permalink for this review comment.
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Check if the current viewer can minimize this object.
   */
  viewerCanMinimize: () => new Field("viewerCanMinimize"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface IPullRequestReviewCommentConnection {
  edges: IPullRequestReviewCommentEdge[];
  nodes: IPullRequestReviewComment[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PullRequestReviewCommentConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PullRequestReviewCommentConnection: PullRequestReviewCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestReviewCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestReviewCommentEdge {
  cursor: string;
  node: IPullRequestReviewComment;
}

interface PullRequestReviewCommentEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestReviewCommentEdge: PullRequestReviewCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),
};

export interface IPullRequestReviewConnection {
  edges: IPullRequestReviewEdge[];
  nodes: IPullRequestReview[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PullRequestReviewConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PullRequestReviewEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PullRequestReviewConnection: PullRequestReviewConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestReviewEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestReviewContributionsByRepository {
  contributions: ICreatedPullRequestReviewContributionConnection;
  repository: IRepository;
}

interface PullRequestReviewContributionsByRepositorySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The pull request review contributions.
   */

  contributions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ContributionOrder;
    },
    select: (t: CreatedPullRequestReviewContributionConnectionSelector) => T
  ) => Field<
    "contributions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ContributionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository in which the pull request reviews were made.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const PullRequestReviewContributionsByRepository: PullRequestReviewContributionsByRepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The pull request review contributions.
   */

  contributions: (variables, select) =>
    new Field(
      "contributions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(CreatedPullRequestReviewContributionConnection))
    ),

  /**
   * @description The repository in which the pull request reviews were made.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IPullRequestReviewEdge {
  cursor: string;
  node: IPullRequestReview;
}

interface PullRequestReviewEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestReviewEdge: PullRequestReviewEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IPullRequestReviewThread extends INode {
  __typename: "PullRequestReviewThread";
  comments: IPullRequestReviewCommentConnection;
  diffSide: DiffSide;
  isCollapsed: boolean;
  isOutdated: boolean;
  isResolved: boolean;
  line: number;
  originalLine: number;
  originalStartLine: number;
  path: string;
  pullRequest: IPullRequest;
  repository: IRepository;
  resolvedBy: IUser;
  startDiffSide: DiffSide;
  startLine: number;
  viewerCanReply: boolean;
  viewerCanResolve: boolean;
  viewerCanUnresolve: boolean;
}

interface PullRequestReviewThreadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of pull request comments associated with the thread.
   */

  comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      skip?: Variable<"skip"> | number;
    },
    select: (t: PullRequestReviewCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"skip", Variable<"skip"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The side of the diff on which this thread was placed.
   */

  diffSide: () => Field<"diffSide">;

  id: () => Field<"id">;

  /**
   * @description Whether or not the thread has been collapsed (outdated or resolved)
   */

  isCollapsed: () => Field<"isCollapsed">;

  /**
   * @description Indicates whether this thread was outdated by newer changes.
   */

  isOutdated: () => Field<"isOutdated">;

  /**
   * @description Whether this thread has been resolved
   */

  isResolved: () => Field<"isResolved">;

  /**
   * @description The line in the file to which this thread refers
   */

  line: () => Field<"line">;

  /**
   * @description The original line in the file to which this thread refers.
   */

  originalLine: () => Field<"originalLine">;

  /**
   * @description The original start line in the file to which this thread refers (multi-line only).
   */

  originalStartLine: () => Field<"originalStartLine">;

  /**
   * @description Identifies the file path of this thread.
   */

  path: () => Field<"path">;

  /**
   * @description Identifies the pull request associated with this thread.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the repository associated with this thread.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The user who resolved this thread
   */

  resolvedBy: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"resolvedBy", never, SelectionSet<T>>;

  /**
   * @description The side of the diff that the first line of the thread starts on (multi-line only)
   */

  startDiffSide: () => Field<"startDiffSide">;

  /**
   * @description The start line in the file to which this thread refers (multi-line only)
   */

  startLine: () => Field<"startLine">;

  /**
   * @description Indicates whether the current viewer can reply to this thread.
   */

  viewerCanReply: () => Field<"viewerCanReply">;

  /**
   * @description Whether or not the viewer can resolve this thread
   */

  viewerCanResolve: () => Field<"viewerCanResolve">;

  /**
   * @description Whether or not the viewer can unresolve this thread
   */

  viewerCanUnresolve: () => Field<"viewerCanUnresolve">;
}

export const isPullRequestReviewThread = (
  object: Record<string, any>
): object is Partial<IPullRequestReviewThread> => {
  return object.__typename === "PullRequestReviewThread";
};

export const PullRequestReviewThread: PullRequestReviewThreadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of pull request comments associated with the thread.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("skip", variables.skip),
      ],
      new SelectionSet(select(PullRequestReviewCommentConnection))
    ),

  /**
   * @description The side of the diff on which this thread was placed.
   */
  diffSide: () => new Field("diffSide"),
  id: () => new Field("id"),

  /**
   * @description Whether or not the thread has been collapsed (outdated or resolved)
   */
  isCollapsed: () => new Field("isCollapsed"),

  /**
   * @description Indicates whether this thread was outdated by newer changes.
   */
  isOutdated: () => new Field("isOutdated"),

  /**
   * @description Whether this thread has been resolved
   */
  isResolved: () => new Field("isResolved"),

  /**
   * @description The line in the file to which this thread refers
   */
  line: () => new Field("line"),

  /**
   * @description The original line in the file to which this thread refers.
   */
  originalLine: () => new Field("originalLine"),

  /**
   * @description The original start line in the file to which this thread refers (multi-line only).
   */
  originalStartLine: () => new Field("originalStartLine"),

  /**
   * @description Identifies the file path of this thread.
   */
  path: () => new Field("path"),

  /**
   * @description Identifies the pull request associated with this thread.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the repository associated with this thread.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The user who resolved this thread
   */

  resolvedBy: (select) =>
    new Field("resolvedBy", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The side of the diff that the first line of the thread starts on (multi-line only)
   */
  startDiffSide: () => new Field("startDiffSide"),

  /**
   * @description The start line in the file to which this thread refers (multi-line only)
   */
  startLine: () => new Field("startLine"),

  /**
   * @description Indicates whether the current viewer can reply to this thread.
   */
  viewerCanReply: () => new Field("viewerCanReply"),

  /**
   * @description Whether or not the viewer can resolve this thread
   */
  viewerCanResolve: () => new Field("viewerCanResolve"),

  /**
   * @description Whether or not the viewer can unresolve this thread
   */
  viewerCanUnresolve: () => new Field("viewerCanUnresolve"),
};

export interface IPullRequestReviewThreadConnection {
  edges: IPullRequestReviewThreadEdge[];
  nodes: IPullRequestReviewThread[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PullRequestReviewThreadConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PullRequestReviewThreadConnection: PullRequestReviewThreadConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThreadEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestReviewThreadEdge {
  cursor: string;
  node: IPullRequestReviewThread;
}

interface PullRequestReviewThreadEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestReviewThreadEdge: PullRequestReviewThreadEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),
};

export interface IPullRequestRevisionMarker {
  createdAt: unknown;
  lastSeenCommit: ICommit;
  pullRequest: IPullRequest;
}

interface PullRequestRevisionMarkerSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The last commit the viewer has seen.
   */

  lastSeenCommit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"lastSeenCommit", never, SelectionSet<T>>;

  /**
   * @description The pull request to which the marker belongs.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const PullRequestRevisionMarker: PullRequestRevisionMarkerSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The last commit the viewer has seen.
   */

  lastSeenCommit: (select) =>
    new Field(
      "lastSeenCommit",
      undefined as never,
      new SelectionSet(select(Commit))
    ),

  /**
   * @description The pull request to which the marker belongs.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IPullRequestTimelineConnection {
  edges: IPullRequestTimelineItemEdge[];
  nodes: IPullRequestTimelineItem[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PullRequestTimelineConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PullRequestTimelineConnection: PullRequestTimelineConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItemEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItem))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPullRequestTimelineItemEdge {
  cursor: string;
  node: IPullRequestTimelineItem;
}

interface PullRequestTimelineItemEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestTimelineItemEdge: PullRequestTimelineItemEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItem))
    ),
};

export interface IPullRequestTimelineItemsConnection {
  edges: IPullRequestTimelineItemsEdge[];
  filteredCount: number;
  nodes: IPullRequestTimelineItems[];
  pageCount: number;
  pageInfo: IPageInfo;
  totalCount: number;
  updatedAt: unknown;
}

interface PullRequestTimelineItemsConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemsEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description Identifies the count of items after applying `before` and `after` filters.
   */

  filteredCount: () => Field<"filteredCount">;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemsSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
   */

  pageCount: () => Field<"pageCount">;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;

  /**
   * @description Identifies the date and time when the timeline was last updated.
   */

  updatedAt: () => Field<"updatedAt">;
}

export const PullRequestTimelineItemsConnection: PullRequestTimelineItemsConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItemsEdge))
    ),

  /**
   * @description Identifies the count of items after applying `before` and `after` filters.
   */
  filteredCount: () => new Field("filteredCount"),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItems))
    ),

  /**
   * @description Identifies the count of items after applying `before`/`after` filters and `first`/`last`/`skip` slicing.
   */
  pageCount: () => new Field("pageCount"),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description Identifies the date and time when the timeline was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IPullRequestTimelineItemsEdge {
  cursor: string;
  node: IPullRequestTimelineItems;
}

interface PullRequestTimelineItemsEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PullRequestTimelineItemsSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PullRequestTimelineItemsEdge: PullRequestTimelineItemsEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PullRequestTimelineItems))
    ),
};

export interface IPush extends INode {
  __typename: "Push";
  nextSha: unknown;
  permalink: unknown;
  previousSha: unknown;
  pusher: IUser;
  repository: IRepository;
}

interface PushSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description The SHA after the push
   */

  nextSha: () => Field<"nextSha">;

  /**
   * @description The permalink for this push.
   */

  permalink: () => Field<"permalink">;

  /**
   * @description The SHA before the push
   */

  previousSha: () => Field<"previousSha">;

  /**
   * @description The user who pushed
   */

  pusher: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"pusher", never, SelectionSet<T>>;

  /**
   * @description The repository that was pushed to
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isPush = (
  object: Record<string, any>
): object is Partial<IPush> => {
  return object.__typename === "Push";
};

export const Push: PushSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description The SHA after the push
   */
  nextSha: () => new Field("nextSha"),

  /**
   * @description The permalink for this push.
   */
  permalink: () => new Field("permalink"),

  /**
   * @description The SHA before the push
   */
  previousSha: () => new Field("previousSha"),

  /**
   * @description The user who pushed
   */

  pusher: (select) =>
    new Field("pusher", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The repository that was pushed to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IPushAllowance extends INode {
  __typename: "PushAllowance";
  actor: IPushAllowanceActor;
  branchProtectionRule: IBranchProtectionRule;
}

interface PushAllowanceSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor that can push.
   */

  actor: <T extends Array<Selection>>(
    select: (t: PushAllowanceActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the branch protection rule associated with the allowed user or team.
   */

  branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  id: () => Field<"id">;
}

export const isPushAllowance = (
  object: Record<string, any>
): object is Partial<IPushAllowance> => {
  return object.__typename === "PushAllowance";
};

export const PushAllowance: PushAllowanceSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor that can push.
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(PushAllowanceActor))
    ),

  /**
   * @description Identifies the branch protection rule associated with the allowed user or team.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  id: () => new Field("id"),
};

export interface IPushAllowanceConnection {
  edges: IPushAllowanceEdge[];
  nodes: IPushAllowance[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface PushAllowanceConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: PushAllowanceEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: PushAllowanceSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const PushAllowanceConnection: PushAllowanceConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(PushAllowanceEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(PushAllowance))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IPushAllowanceEdge {
  cursor: string;
  node: IPushAllowance;
}

interface PushAllowanceEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: PushAllowanceSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const PushAllowanceEdge: PushAllowanceEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(PushAllowance))
    ),
};

export interface IQuery {
  codeOfConduct: ICodeOfConduct;
  codesOfConduct: ICodeOfConduct[];
  enterprise: IEnterprise;
  enterpriseAdministratorInvitation: IEnterpriseAdministratorInvitation;
  enterpriseAdministratorInvitationByToken: IEnterpriseAdministratorInvitation;
  license: ILicense;
  licenses: ILicense[];
  marketplaceCategories: IMarketplaceCategory[];
  marketplaceCategory: IMarketplaceCategory;
  marketplaceListing: IMarketplaceListing;
  marketplaceListings: IMarketplaceListingConnection;
  meta: IGitHubMetadata;
  node: INode;
  nodes: INode[];
  organization: IOrganization;
  rateLimit: IRateLimit;
  relay: IQuery;
  repository: IRepository;
  repositoryOwner: IRepositoryOwner;
  resource: IUniformResourceLocatable;
  search: ISearchResultItemConnection;
  securityAdvisories: ISecurityAdvisoryConnection;
  securityAdvisory: ISecurityAdvisory;
  securityVulnerabilities: ISecurityVulnerabilityConnection;
  sponsorsListing: ISponsorsListing;
  topic: ITopic;
  user: IUser;
  viewer: IUser;
}

interface QuerySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Look up a code of conduct by its key
   */

  codeOfConduct: <T extends Array<Selection>>(
    variables: { key?: Variable<"key"> | string },
    select: (t: CodeOfConductSelector) => T
  ) => Field<
    "codeOfConduct",
    [Argument<"key", Variable<"key"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Look up a code of conduct by its key
   */

  codesOfConduct: <T extends Array<Selection>>(
    select: (t: CodeOfConductSelector) => T
  ) => Field<"codesOfConduct", never, SelectionSet<T>>;

  /**
   * @description Look up an enterprise by URL slug.
   */

  enterprise: <T extends Array<Selection>>(
    variables: {
      invitationToken?: Variable<"invitationToken"> | string;
      slug?: Variable<"slug"> | string;
    },
    select: (t: EnterpriseSelector) => T
  ) => Field<
    "enterprise",
    [
      Argument<"invitationToken", Variable<"invitationToken"> | string>,
      Argument<"slug", Variable<"slug"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a pending enterprise administrator invitation by invitee, enterprise and role.
   */

  enterpriseAdministratorInvitation: <T extends Array<Selection>>(
    variables: {
      enterpriseSlug?: Variable<"enterpriseSlug"> | string;
      role?: Variable<"role"> | EnterpriseAdministratorRole;
      userLogin?: Variable<"userLogin"> | string;
    },
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<
    "enterpriseAdministratorInvitation",
    [
      Argument<"enterpriseSlug", Variable<"enterpriseSlug"> | string>,
      Argument<"role", Variable<"role"> | EnterpriseAdministratorRole>,
      Argument<"userLogin", Variable<"userLogin"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a pending enterprise administrator invitation by invitation token.
   */

  enterpriseAdministratorInvitationByToken: <T extends Array<Selection>>(
    variables: { invitationToken?: Variable<"invitationToken"> | string },
    select: (t: EnterpriseAdministratorInvitationSelector) => T
  ) => Field<
    "enterpriseAdministratorInvitationByToken",
    [Argument<"invitationToken", Variable<"invitationToken"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Look up an open source license by its key
   */

  license: <T extends Array<Selection>>(
    variables: { key?: Variable<"key"> | string },
    select: (t: LicenseSelector) => T
  ) => Field<
    "license",
    [Argument<"key", Variable<"key"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Return a list of known open source licenses
   */

  licenses: <T extends Array<Selection>>(
    select: (t: LicenseSelector) => T
  ) => Field<"licenses", never, SelectionSet<T>>;

  /**
   * @description Get alphabetically sorted list of Marketplace categories
   */

  marketplaceCategories: <T extends Array<Selection>>(
    variables: {
      excludeEmpty?: Variable<"excludeEmpty"> | boolean;
      excludeSubcategories?: Variable<"excludeSubcategories"> | boolean;
      includeCategories?: Variable<"includeCategories"> | string;
    },
    select: (t: MarketplaceCategorySelector) => T
  ) => Field<
    "marketplaceCategories",
    [
      Argument<"excludeEmpty", Variable<"excludeEmpty"> | boolean>,
      Argument<
        "excludeSubcategories",
        Variable<"excludeSubcategories"> | boolean
      >,
      Argument<"includeCategories", Variable<"includeCategories"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a Marketplace category by its slug.
   */

  marketplaceCategory: <T extends Array<Selection>>(
    variables: {
      slug?: Variable<"slug"> | string;
      useTopicAliases?: Variable<"useTopicAliases"> | boolean;
    },
    select: (t: MarketplaceCategorySelector) => T
  ) => Field<
    "marketplaceCategory",
    [
      Argument<"slug", Variable<"slug"> | string>,
      Argument<"useTopicAliases", Variable<"useTopicAliases"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a single Marketplace listing
   */

  marketplaceListing: <T extends Array<Selection>>(
    variables: { slug?: Variable<"slug"> | string },
    select: (t: MarketplaceListingSelector) => T
  ) => Field<
    "marketplaceListing",
    [Argument<"slug", Variable<"slug"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Look up Marketplace listings
   */

  marketplaceListings: <T extends Array<Selection>>(
    variables: {
      adminId?: Variable<"adminId"> | string;
      after?: Variable<"after"> | string;
      allStates?: Variable<"allStates"> | boolean;
      before?: Variable<"before"> | string;
      categorySlug?: Variable<"categorySlug"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      organizationId?: Variable<"organizationId"> | string;
      primaryCategoryOnly?: Variable<"primaryCategoryOnly"> | boolean;
      slugs?: Variable<"slugs"> | string;
      useTopicAliases?: Variable<"useTopicAliases"> | boolean;
      viewerCanAdmin?: Variable<"viewerCanAdmin"> | boolean;
      withFreeTrialsOnly?: Variable<"withFreeTrialsOnly"> | boolean;
    },
    select: (t: MarketplaceListingConnectionSelector) => T
  ) => Field<
    "marketplaceListings",
    [
      Argument<"adminId", Variable<"adminId"> | string>,
      Argument<"after", Variable<"after"> | string>,
      Argument<"allStates", Variable<"allStates"> | boolean>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"categorySlug", Variable<"categorySlug"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"organizationId", Variable<"organizationId"> | string>,
      Argument<
        "primaryCategoryOnly",
        Variable<"primaryCategoryOnly"> | boolean
      >,
      Argument<"slugs", Variable<"slugs"> | string>,
      Argument<"useTopicAliases", Variable<"useTopicAliases"> | boolean>,
      Argument<"viewerCanAdmin", Variable<"viewerCanAdmin"> | boolean>,
      Argument<"withFreeTrialsOnly", Variable<"withFreeTrialsOnly"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Return information about the GitHub instance
   */

  meta: <T extends Array<Selection>>(
    select: (t: GitHubMetadataSelector) => T
  ) => Field<"meta", never, SelectionSet<T>>;

  /**
   * @description Fetches an object given its ID.
   */

  node: <T extends Array<Selection>>(
    variables: { id?: Variable<"id"> | string },
    select: (t: NodeSelector) => T
  ) => Field<
    "node",
    [Argument<"id", Variable<"id"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Lookup nodes by a list of IDs.
   */

  nodes: <T extends Array<Selection>>(
    variables: { ids?: Variable<"ids"> | string },
    select: (t: NodeSelector) => T
  ) => Field<
    "nodes",
    [Argument<"ids", Variable<"ids"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Lookup a organization by login.
   */

  organization: <T extends Array<Selection>>(
    variables: { login?: Variable<"login"> | string },
    select: (t: OrganizationSelector) => T
  ) => Field<
    "organization",
    [Argument<"login", Variable<"login"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The client's rate limit information.
   */

  rateLimit: <T extends Array<Selection>>(
    variables: { dryRun?: Variable<"dryRun"> | boolean },
    select: (t: RateLimitSelector) => T
  ) => Field<
    "rateLimit",
    [Argument<"dryRun", Variable<"dryRun"> | boolean>],
    SelectionSet<T>
  >;

  /**
   * @description Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object
   */

  relay: <T extends Array<Selection>>(
    select: (t: QuerySelector) => T
  ) => Field<"relay", never, SelectionSet<T>>;

  /**
   * @description Lookup a given repository by the owner and repository name.
   */

  repository: <T extends Array<Selection>>(
    variables: {
      name?: Variable<"name"> | string;
      owner?: Variable<"owner"> | string;
    },
    select: (t: RepositorySelector) => T
  ) => Field<
    "repository",
    [
      Argument<"name", Variable<"name"> | string>,
      Argument<"owner", Variable<"owner"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Lookup a repository owner (ie. either a User or an Organization) by login.
   */

  repositoryOwner: <T extends Array<Selection>>(
    variables: { login?: Variable<"login"> | string },
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<
    "repositoryOwner",
    [Argument<"login", Variable<"login"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Lookup resource by a URL.
   */

  resource: <T extends Array<Selection>>(
    variables: { url?: Variable<"url"> | unknown },
    select: (t: UniformResourceLocatableSelector) => T
  ) => Field<
    "resource",
    [Argument<"url", Variable<"url"> | unknown>],
    SelectionSet<T>
  >;

  /**
   * @description Perform a search across resources.
   */

  search: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
      type?: Variable<"type"> | SearchType;
    },
    select: (t: SearchResultItemConnectionSelector) => T
  ) => Field<
    "search",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"type", Variable<"type"> | SearchType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description GitHub Security Advisories
   */

  securityAdvisories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      identifier?: Variable<"identifier"> | SecurityAdvisoryIdentifierFilter;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SecurityAdvisoryOrder;
      publishedSince?: Variable<"publishedSince"> | unknown;
      updatedSince?: Variable<"updatedSince"> | unknown;
    },
    select: (t: SecurityAdvisoryConnectionSelector) => T
  ) => Field<
    "securityAdvisories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<
        "identifier",
        Variable<"identifier"> | SecurityAdvisoryIdentifierFilter
      >,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SecurityAdvisoryOrder>,
      Argument<"publishedSince", Variable<"publishedSince"> | unknown>,
      Argument<"updatedSince", Variable<"updatedSince"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Fetch a Security Advisory by its GHSA ID
   */

  securityAdvisory: <T extends Array<Selection>>(
    variables: { ghsaId?: Variable<"ghsaId"> | string },
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<
    "securityAdvisory",
    [Argument<"ghsaId", Variable<"ghsaId"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Software Vulnerabilities documented by GitHub Security Advisories
   */

  securityVulnerabilities: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      ecosystem?: Variable<"ecosystem"> | SecurityAdvisoryEcosystem;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SecurityVulnerabilityOrder;
      package?: Variable<"package"> | string;
      severities?: Variable<"severities"> | SecurityAdvisorySeverity;
    },
    select: (t: SecurityVulnerabilityConnectionSelector) => T
  ) => Field<
    "securityVulnerabilities",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"ecosystem", Variable<"ecosystem"> | SecurityAdvisoryEcosystem>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SecurityVulnerabilityOrder>,
      Argument<"package", Variable<"package"> | string>,
      Argument<"severities", Variable<"severities"> | SecurityAdvisorySeverity>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Look up a single Sponsors Listing
   * @deprecated `Query.sponsorsListing` will be removed. Use `Sponsorable.sponsorsListing` instead. Removal on 2020-04-01 UTC.
   */

  sponsorsListing: <T extends Array<Selection>>(
    variables: { slug?: Variable<"slug"> | string },
    select: (t: SponsorsListingSelector) => T
  ) => Field<
    "sponsorsListing",
    [Argument<"slug", Variable<"slug"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Look up a topic by name.
   */

  topic: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: TopicSelector) => T
  ) => Field<
    "topic",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Lookup a user by login.
   */

  user: <T extends Array<Selection>>(
    variables: { login?: Variable<"login"> | string },
    select: (t: UserSelector) => T
  ) => Field<
    "user",
    [Argument<"login", Variable<"login"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The currently authenticated user.
   */

  viewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"viewer", never, SelectionSet<T>>;
}

export const Query: QuerySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Look up a code of conduct by its key
   */

  codeOfConduct: (variables, select) =>
    new Field(
      "codeOfConduct",
      [new Argument("key", variables.key)],
      new SelectionSet(select(CodeOfConduct))
    ),

  /**
   * @description Look up a code of conduct by its key
   */

  codesOfConduct: (select) =>
    new Field(
      "codesOfConduct",
      undefined as never,
      new SelectionSet(select(CodeOfConduct))
    ),

  /**
   * @description Look up an enterprise by URL slug.
   */

  enterprise: (variables, select) =>
    new Field(
      "enterprise",
      [
        new Argument("invitationToken", variables.invitationToken),
        new Argument("slug", variables.slug),
      ],
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description Look up a pending enterprise administrator invitation by invitee, enterprise and role.
   */

  enterpriseAdministratorInvitation: (variables, select) =>
    new Field(
      "enterpriseAdministratorInvitation",
      [
        new Argument("enterpriseSlug", variables.enterpriseSlug),
        new Argument("role", variables.role, EnterpriseAdministratorRole),
        new Argument("userLogin", variables.userLogin),
      ],
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description Look up a pending enterprise administrator invitation by invitation token.
   */

  enterpriseAdministratorInvitationByToken: (variables, select) =>
    new Field(
      "enterpriseAdministratorInvitationByToken",
      [new Argument("invitationToken", variables.invitationToken)],
      new SelectionSet(select(EnterpriseAdministratorInvitation))
    ),

  /**
   * @description Look up an open source license by its key
   */

  license: (variables, select) =>
    new Field(
      "license",
      [new Argument("key", variables.key)],
      new SelectionSet(select(License))
    ),

  /**
   * @description Return a list of known open source licenses
   */

  licenses: (select) =>
    new Field(
      "licenses",
      undefined as never,
      new SelectionSet(select(License))
    ),

  /**
   * @description Get alphabetically sorted list of Marketplace categories
   */

  marketplaceCategories: (variables, select) =>
    new Field(
      "marketplaceCategories",
      [
        new Argument("excludeEmpty", variables.excludeEmpty),
        new Argument("excludeSubcategories", variables.excludeSubcategories),
        new Argument("includeCategories", variables.includeCategories),
      ],
      new SelectionSet(select(MarketplaceCategory))
    ),

  /**
   * @description Look up a Marketplace category by its slug.
   */

  marketplaceCategory: (variables, select) =>
    new Field(
      "marketplaceCategory",
      [
        new Argument("slug", variables.slug),
        new Argument("useTopicAliases", variables.useTopicAliases),
      ],
      new SelectionSet(select(MarketplaceCategory))
    ),

  /**
   * @description Look up a single Marketplace listing
   */

  marketplaceListing: (variables, select) =>
    new Field(
      "marketplaceListing",
      [new Argument("slug", variables.slug)],
      new SelectionSet(select(MarketplaceListing))
    ),

  /**
   * @description Look up Marketplace listings
   */

  marketplaceListings: (variables, select) =>
    new Field(
      "marketplaceListings",
      [
        new Argument("adminId", variables.adminId),
        new Argument("after", variables.after),
        new Argument("allStates", variables.allStates),
        new Argument("before", variables.before),
        new Argument("categorySlug", variables.categorySlug),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("organizationId", variables.organizationId),
        new Argument("primaryCategoryOnly", variables.primaryCategoryOnly),
        new Argument("slugs", variables.slugs),
        new Argument("useTopicAliases", variables.useTopicAliases),
        new Argument("viewerCanAdmin", variables.viewerCanAdmin),
        new Argument("withFreeTrialsOnly", variables.withFreeTrialsOnly),
      ],
      new SelectionSet(select(MarketplaceListingConnection))
    ),

  /**
   * @description Return information about the GitHub instance
   */

  meta: (select) =>
    new Field(
      "meta",
      undefined as never,
      new SelectionSet(select(GitHubMetadata))
    ),

  /**
   * @description Fetches an object given its ID.
   */

  node: (variables, select) =>
    new Field(
      "node",
      [new Argument("id", variables.id)],
      new SelectionSet(select(Node))
    ),

  /**
   * @description Lookup nodes by a list of IDs.
   */

  nodes: (variables, select) =>
    new Field(
      "nodes",
      [new Argument("ids", variables.ids)],
      new SelectionSet(select(Node))
    ),

  /**
   * @description Lookup a organization by login.
   */

  organization: (variables, select) =>
    new Field(
      "organization",
      [new Argument("login", variables.login)],
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The client's rate limit information.
   */

  rateLimit: (variables, select) =>
    new Field(
      "rateLimit",
      [new Argument("dryRun", variables.dryRun)],
      new SelectionSet(select(RateLimit))
    ),

  /**
   * @description Hack to workaround https://github.com/facebook/relay/issues/112 re-exposing the root query object
   */

  relay: (select) =>
    new Field("relay", undefined as never, new SelectionSet(select(Query))),

  /**
   * @description Lookup a given repository by the owner and repository name.
   */

  repository: (variables, select) =>
    new Field(
      "repository",
      [
        new Argument("name", variables.name),
        new Argument("owner", variables.owner),
      ],
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Lookup a repository owner (ie. either a User or an Organization) by login.
   */

  repositoryOwner: (variables, select) =>
    new Field(
      "repositoryOwner",
      [new Argument("login", variables.login)],
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description Lookup resource by a URL.
   */

  resource: (variables, select) =>
    new Field(
      "resource",
      [new Argument("url", variables.url)],
      new SelectionSet(select(UniformResourceLocatable))
    ),

  /**
   * @description Perform a search across resources.
   */

  search: (variables, select) =>
    new Field(
      "search",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
        new Argument("type", variables.type, SearchType),
      ],
      new SelectionSet(select(SearchResultItemConnection))
    ),

  /**
   * @description GitHub Security Advisories
   */

  securityAdvisories: (variables, select) =>
    new Field(
      "securityAdvisories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("identifier", variables.identifier),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("publishedSince", variables.publishedSince),
        new Argument("updatedSince", variables.updatedSince),
      ],
      new SelectionSet(select(SecurityAdvisoryConnection))
    ),

  /**
   * @description Fetch a Security Advisory by its GHSA ID
   */

  securityAdvisory: (variables, select) =>
    new Field(
      "securityAdvisory",
      [new Argument("ghsaId", variables.ghsaId)],
      new SelectionSet(select(SecurityAdvisory))
    ),

  /**
   * @description Software Vulnerabilities documented by GitHub Security Advisories
   */

  securityVulnerabilities: (variables, select) =>
    new Field(
      "securityVulnerabilities",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument(
          "ecosystem",
          variables.ecosystem,
          SecurityAdvisoryEcosystem
        ),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("package", variables.package),
        new Argument(
          "severities",
          variables.severities,
          SecurityAdvisorySeverity
        ),
      ],
      new SelectionSet(select(SecurityVulnerabilityConnection))
    ),

  /**
   * @description Look up a single Sponsors Listing
   * @deprecated `Query.sponsorsListing` will be removed. Use `Sponsorable.sponsorsListing` instead. Removal on 2020-04-01 UTC.
   */

  sponsorsListing: (variables, select) =>
    new Field(
      "sponsorsListing",
      [new Argument("slug", variables.slug)],
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description Look up a topic by name.
   */

  topic: (variables, select) =>
    new Field(
      "topic",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Topic))
    ),

  /**
   * @description Lookup a user by login.
   */

  user: (variables, select) =>
    new Field(
      "user",
      [new Argument("login", variables.login)],
      new SelectionSet(select(User))
    ),

  /**
   * @description The currently authenticated user.
   */

  viewer: (select) =>
    new Field("viewer", undefined as never, new SelectionSet(select(User))),
};

export interface IRateLimit {
  cost: number;
  limit: number;
  nodeCount: number;
  remaining: number;
  resetAt: unknown;
  used: number;
}

interface RateLimitSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The point cost for the current query counting against the rate limit.
   */

  cost: () => Field<"cost">;

  /**
   * @description The maximum number of points the client is permitted to consume in a 60 minute window.
   */

  limit: () => Field<"limit">;

  /**
   * @description The maximum number of nodes this query may return
   */

  nodeCount: () => Field<"nodeCount">;

  /**
   * @description The number of points remaining in the current rate limit window.
   */

  remaining: () => Field<"remaining">;

  /**
   * @description The time at which the current rate limit window resets in UTC epoch seconds.
   */

  resetAt: () => Field<"resetAt">;

  /**
   * @description The number of points used in the current rate limit window.
   */

  used: () => Field<"used">;
}

export const RateLimit: RateLimitSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The point cost for the current query counting against the rate limit.
   */
  cost: () => new Field("cost"),

  /**
   * @description The maximum number of points the client is permitted to consume in a 60 minute window.
   */
  limit: () => new Field("limit"),

  /**
   * @description The maximum number of nodes this query may return
   */
  nodeCount: () => new Field("nodeCount"),

  /**
   * @description The number of points remaining in the current rate limit window.
   */
  remaining: () => new Field("remaining"),

  /**
   * @description The time at which the current rate limit window resets in UTC epoch seconds.
   */
  resetAt: () => new Field("resetAt"),

  /**
   * @description The number of points used in the current rate limit window.
   */
  used: () => new Field("used"),
};

export interface IReactable {
  __typename: string;
  databaseId: number;
  id: string;
  reactionGroups: IReactionGroup[];
  reactions: IReactionConnection;
  viewerCanReact: boolean;
}

interface ReactableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Can user react to this subject
   */

  viewerCanReact: () => Field<"viewerCanReact">;

  on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "Issue"
      | "IssueComment"
      | "PullRequest"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Reactable: ReactableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IReactingUserConnection {
  edges: IReactingUserEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface ReactingUserConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ReactingUserEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const ReactingUserConnection: ReactingUserConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReactingUserEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReactingUserEdge {
  cursor: string;
  node: IUser;
  reactedAt: unknown;
}

interface ReactingUserEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The moment when the user made the reaction.
   */

  reactedAt: () => Field<"reactedAt">;
}

export const ReactingUserEdge: ReactingUserEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The moment when the user made the reaction.
   */
  reactedAt: () => new Field("reactedAt"),
};

export interface IReaction extends INode {
  __typename: "Reaction";
  content: ReactionContent;
  createdAt: unknown;
  databaseId: number;
  reactable: IReactable;
  user: IUser;
}

interface ReactionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the emoji reaction.
   */

  content: () => Field<"content">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description The reactable piece of content
   */

  reactable: <T extends Array<Selection>>(
    select: (t: ReactableSelector) => T
  ) => Field<"reactable", never, SelectionSet<T>>;

  /**
   * @description Identifies the user who created this reaction.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isReaction = (
  object: Record<string, any>
): object is Partial<IReaction> => {
  return object.__typename === "Reaction";
};

export const Reaction: ReactionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the emoji reaction.
   */
  content: () => new Field("content"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The reactable piece of content
   */

  reactable: (select) =>
    new Field(
      "reactable",
      undefined as never,
      new SelectionSet(select(Reactable))
    ),

  /**
   * @description Identifies the user who created this reaction.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IReactionConnection {
  edges: IReactionEdge[];
  nodes: IReaction[];
  pageInfo: IPageInfo;
  totalCount: number;
  viewerHasReacted: boolean;
}

interface ReactionConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ReactionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: ReactionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;

  /**
   * @description Whether or not the authenticated user has left a reaction on the subject.
   */

  viewerHasReacted: () => Field<"viewerHasReacted">;
}

export const ReactionConnection: ReactionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReactionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Reaction))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description Whether or not the authenticated user has left a reaction on the subject.
   */
  viewerHasReacted: () => new Field("viewerHasReacted"),
};

export interface IReactionEdge {
  cursor: string;
  node: IReaction;
}

interface ReactionEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: ReactionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReactionEdge: ReactionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Reaction))),
};

export interface IReactionGroup {
  content: ReactionContent;
  createdAt: unknown;
  subject: IReactable;
  users: IReactingUserConnection;
  viewerHasReacted: boolean;
}

interface ReactionGroupSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the emoji reaction.
   */

  content: () => Field<"content">;

  /**
   * @description Identifies when the reaction was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The subject that was reacted to.
   */

  subject: <T extends Array<Selection>>(
    select: (t: ReactableSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;

  /**
   * @description Users who have reacted to the reaction subject with the emotion represented by this reaction group
   */

  users: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: ReactingUserConnectionSelector) => T
  ) => Field<
    "users",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not the authenticated user has left a reaction on the subject.
   */

  viewerHasReacted: () => Field<"viewerHasReacted">;
}

export const ReactionGroup: ReactionGroupSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the emoji reaction.
   */
  content: () => new Field("content"),

  /**
   * @description Identifies when the reaction was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The subject that was reacted to.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(Reactable))
    ),

  /**
   * @description Users who have reacted to the reaction subject with the emotion represented by this reaction group
   */

  users: (variables, select) =>
    new Field(
      "users",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(ReactingUserConnection))
    ),

  /**
   * @description Whether or not the authenticated user has left a reaction on the subject.
   */
  viewerHasReacted: () => new Field("viewerHasReacted"),
};

export interface IReadyForReviewEvent extends INode, IUniformResourceLocatable {
  __typename: "ReadyForReviewEvent";
  actor: IActor;
  createdAt: unknown;
  pullRequest: IPullRequest;
}

interface ReadyForReviewEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this ready for review event.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this ready for review event.
   */

  url: () => Field<"url">;
}

export const isReadyForReviewEvent = (
  object: Record<string, any>
): object is Partial<IReadyForReviewEvent> => {
  return object.__typename === "ReadyForReviewEvent";
};

export const ReadyForReviewEvent: ReadyForReviewEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The HTTP path for this ready for review event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this ready for review event.
   */
  url: () => new Field("url"),
};

export interface IRef extends INode {
  __typename: "Ref";
  associatedPullRequests: IPullRequestConnection;
  branchProtectionRule: IBranchProtectionRule;
  name: string;
  prefix: string;
  refUpdateRule: IRefUpdateRule;
  repository: IRepository;
  target: IGitObject;
}

interface RefSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of pull requests with this ref as the head ref.
   */

  associatedPullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "associatedPullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Branch protection rules for this ref
   */

  branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description The ref name.
   */

  name: () => Field<"name">;

  /**
   * @description The ref's prefix, such as `refs/heads/` or `refs/tags/`.
   */

  prefix: () => Field<"prefix">;

  /**
   * @description Branch protection rules that are viewable by non-admins
   */

  refUpdateRule: <T extends Array<Selection>>(
    select: (t: RefUpdateRuleSelector) => T
  ) => Field<"refUpdateRule", never, SelectionSet<T>>;

  /**
   * @description The repository the ref belongs to.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The object the ref points to. Returns null when object does not exist.
   */

  target: <T extends Array<Selection>>(
    select: (t: GitObjectSelector) => T
  ) => Field<"target", never, SelectionSet<T>>;
}

export const isRef = (object: Record<string, any>): object is Partial<IRef> => {
  return object.__typename === "Ref";
};

export const Ref: RefSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of pull requests with this ref as the head ref.
   */

  associatedPullRequests: (variables, select) =>
    new Field(
      "associatedPullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description Branch protection rules for this ref
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  id: () => new Field("id"),

  /**
   * @description The ref name.
   */
  name: () => new Field("name"),

  /**
   * @description The ref's prefix, such as `refs/heads/` or `refs/tags/`.
   */
  prefix: () => new Field("prefix"),

  /**
   * @description Branch protection rules that are viewable by non-admins
   */

  refUpdateRule: (select) =>
    new Field(
      "refUpdateRule",
      undefined as never,
      new SelectionSet(select(RefUpdateRule))
    ),

  /**
   * @description The repository the ref belongs to.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The object the ref points to. Returns null when object does not exist.
   */

  target: (select) =>
    new Field(
      "target",
      undefined as never,
      new SelectionSet(select(GitObject))
    ),
};

export interface IRefConnection {
  edges: IRefEdge[];
  nodes: IRef[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface RefConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: RefEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const RefConnection: RefConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(RefEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRefEdge {
  cursor: string;
  node: IRef;
}

interface RefEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RefEdge: RefEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Ref))),
};

export interface IRefUpdateRule {
  allowsDeletions: boolean;
  allowsForcePushes: boolean;
  pattern: string;
  requiredApprovingReviewCount: number;
  requiredStatusCheckContexts: string[];
  requiresLinearHistory: boolean;
  requiresSignatures: boolean;
  viewerCanPush: boolean;
}

interface RefUpdateRuleSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Can this branch be deleted.
   */

  allowsDeletions: () => Field<"allowsDeletions">;

  /**
   * @description Are force pushes allowed on this branch.
   */

  allowsForcePushes: () => Field<"allowsForcePushes">;

  /**
   * @description Identifies the protection rule pattern.
   */

  pattern: () => Field<"pattern">;

  /**
   * @description Number of approving reviews required to update matching branches.
   */

  requiredApprovingReviewCount: () => Field<"requiredApprovingReviewCount">;

  /**
   * @description List of required status check contexts that must pass for commits to be accepted to matching branches.
   */

  requiredStatusCheckContexts: () => Field<"requiredStatusCheckContexts">;

  /**
   * @description Are merge commits prohibited from being pushed to this branch.
   */

  requiresLinearHistory: () => Field<"requiresLinearHistory">;

  /**
   * @description Are commits required to be signed.
   */

  requiresSignatures: () => Field<"requiresSignatures">;

  /**
   * @description Can the viewer push to the branch
   */

  viewerCanPush: () => Field<"viewerCanPush">;
}

export const RefUpdateRule: RefUpdateRuleSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Can this branch be deleted.
   */
  allowsDeletions: () => new Field("allowsDeletions"),

  /**
   * @description Are force pushes allowed on this branch.
   */
  allowsForcePushes: () => new Field("allowsForcePushes"),

  /**
   * @description Identifies the protection rule pattern.
   */
  pattern: () => new Field("pattern"),

  /**
   * @description Number of approving reviews required to update matching branches.
   */
  requiredApprovingReviewCount: () => new Field("requiredApprovingReviewCount"),

  /**
   * @description List of required status check contexts that must pass for commits to be accepted to matching branches.
   */
  requiredStatusCheckContexts: () => new Field("requiredStatusCheckContexts"),

  /**
   * @description Are merge commits prohibited from being pushed to this branch.
   */
  requiresLinearHistory: () => new Field("requiresLinearHistory"),

  /**
   * @description Are commits required to be signed.
   */
  requiresSignatures: () => new Field("requiresSignatures"),

  /**
   * @description Can the viewer push to the branch
   */
  viewerCanPush: () => new Field("viewerCanPush"),
};

export interface IReferencedEvent extends INode {
  __typename: "ReferencedEvent";
  actor: IActor;
  commit: ICommit;
  commitRepository: IRepository;
  createdAt: unknown;
  isCrossRepository: boolean;
  isDirectReference: boolean;
  subject: IReferencedSubject;
}

interface ReferencedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the commit associated with the 'referenced' event.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Identifies the repository associated with the 'referenced' event.
   */

  commitRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"commitRepository", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Reference originated in a different repository.
   */

  isCrossRepository: () => Field<"isCrossRepository">;

  /**
   * @description Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference.
   */

  isDirectReference: () => Field<"isDirectReference">;

  /**
   * @description Object referenced by event.
   */

  subject: <T extends Array<Selection>>(
    select: (t: ReferencedSubjectSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isReferencedEvent = (
  object: Record<string, any>
): object is Partial<IReferencedEvent> => {
  return object.__typename === "ReferencedEvent";
};

export const ReferencedEvent: ReferencedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the commit associated with the 'referenced' event.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Identifies the repository associated with the 'referenced' event.
   */

  commitRepository: (select) =>
    new Field(
      "commitRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Reference originated in a different repository.
   */
  isCrossRepository: () => new Field("isCrossRepository"),

  /**
   * @description Checks if the commit message itself references the subject. Can be false in the case of a commit comment reference.
   */
  isDirectReference: () => new Field("isDirectReference"),

  /**
   * @description Object referenced by event.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(ReferencedSubject))
    ),
};

export interface IRegenerateEnterpriseIdentityProviderRecoveryCodesPayload {
  clientMutationId: string;
  identityProvider: IEnterpriseIdentityProvider;
}

interface RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The identity provider for the enterprise.
   */

  identityProvider: <T extends Array<Selection>>(
    select: (t: EnterpriseIdentityProviderSelector) => T
  ) => Field<"identityProvider", never, SelectionSet<T>>;
}

export const RegenerateEnterpriseIdentityProviderRecoveryCodesPayload: RegenerateEnterpriseIdentityProviderRecoveryCodesPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The identity provider for the enterprise.
   */

  identityProvider: (select) =>
    new Field(
      "identityProvider",
      undefined as never,
      new SelectionSet(select(EnterpriseIdentityProvider))
    ),
};

export interface IRelease extends INode, IUniformResourceLocatable {
  __typename: "Release";
  author: IUser;
  createdAt: unknown;
  description: string;
  descriptionHTML: unknown;
  isDraft: boolean;
  isPrerelease: boolean;
  name: string;
  publishedAt: unknown;
  releaseAssets: IReleaseAssetConnection;
  shortDescriptionHTML: unknown;
  tag: IRef;
  tagName: string;
  updatedAt: unknown;
}

interface ReleaseSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The author of the release
   */

  author: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The description of the release.
   */

  description: () => Field<"description">;

  /**
   * @description The description of this release rendered to HTML.
   */

  descriptionHTML: () => Field<"descriptionHTML">;

  id: () => Field<"id">;

  /**
   * @description Whether or not the release is a draft
   */

  isDraft: () => Field<"isDraft">;

  /**
   * @description Whether or not the release is a prerelease
   */

  isPrerelease: () => Field<"isPrerelease">;

  /**
   * @description The title of the release.
   */

  name: () => Field<"name">;

  /**
   * @description Identifies the date and time when the release was created.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description List of releases assets which are dependent on this release.
   */

  releaseAssets: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      name?: Variable<"name"> | string;
    },
    select: (t: ReleaseAssetConnectionSelector) => T
  ) => Field<
    "releaseAssets",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"name", Variable<"name"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this issue
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description A description of the release, rendered to HTML without any links in it.
   */

  shortDescriptionHTML: (variables: {
    limit: unknown;
  }) => Field<"shortDescriptionHTML", [/* @todo */]>;

  /**
   * @description The Git tag the release points to
   */

  tag: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"tag", never, SelectionSet<T>>;

  /**
   * @description The name of the release's Git tag
   */

  tagName: () => Field<"tagName">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this issue
   */

  url: () => Field<"url">;
}

export const isRelease = (
  object: Record<string, any>
): object is Partial<IRelease> => {
  return object.__typename === "Release";
};

export const Release: ReleaseSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The author of the release
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The description of the release.
   */
  description: () => new Field("description"),

  /**
   * @description The description of this release rendered to HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),
  id: () => new Field("id"),

  /**
   * @description Whether or not the release is a draft
   */
  isDraft: () => new Field("isDraft"),

  /**
   * @description Whether or not the release is a prerelease
   */
  isPrerelease: () => new Field("isPrerelease"),

  /**
   * @description The title of the release.
   */
  name: () => new Field("name"),

  /**
   * @description Identifies the date and time when the release was created.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description List of releases assets which are dependent on this release.
   */

  releaseAssets: (variables, select) =>
    new Field(
      "releaseAssets",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("name", variables.name),
      ],
      new SelectionSet(select(ReleaseAssetConnection))
    ),

  /**
   * @description The HTTP path for this issue
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description A description of the release, rendered to HTML without any links in it.
   */
  shortDescriptionHTML: (variables) => new Field("shortDescriptionHTML"),

  /**
   * @description The Git tag the release points to
   */

  tag: (select) =>
    new Field("tag", undefined as never, new SelectionSet(select(Ref))),

  /**
   * @description The name of the release's Git tag
   */
  tagName: () => new Field("tagName"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this issue
   */
  url: () => new Field("url"),
};

export interface IReleaseAsset extends INode {
  __typename: "ReleaseAsset";
  contentType: string;
  createdAt: unknown;
  downloadCount: number;
  downloadUrl: unknown;
  name: string;
  release: IRelease;
  size: number;
  updatedAt: unknown;
  uploadedBy: IUser;
  url: unknown;
}

interface ReleaseAssetSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The asset's content-type
   */

  contentType: () => Field<"contentType">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The number of times this asset was downloaded
   */

  downloadCount: () => Field<"downloadCount">;

  /**
   * @description Identifies the URL where you can download the release asset via the browser.
   */

  downloadUrl: () => Field<"downloadUrl">;

  id: () => Field<"id">;

  /**
   * @description Identifies the title of the release asset.
   */

  name: () => Field<"name">;

  /**
   * @description Release that the asset is associated with
   */

  release: <T extends Array<Selection>>(
    select: (t: ReleaseSelector) => T
  ) => Field<"release", never, SelectionSet<T>>;

  /**
   * @description The size (in bytes) of the asset
   */

  size: () => Field<"size">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The user that performed the upload
   */

  uploadedBy: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"uploadedBy", never, SelectionSet<T>>;

  /**
   * @description Identifies the URL of the release asset.
   */

  url: () => Field<"url">;
}

export const isReleaseAsset = (
  object: Record<string, any>
): object is Partial<IReleaseAsset> => {
  return object.__typename === "ReleaseAsset";
};

export const ReleaseAsset: ReleaseAssetSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The asset's content-type
   */
  contentType: () => new Field("contentType"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The number of times this asset was downloaded
   */
  downloadCount: () => new Field("downloadCount"),

  /**
   * @description Identifies the URL where you can download the release asset via the browser.
   */
  downloadUrl: () => new Field("downloadUrl"),
  id: () => new Field("id"),

  /**
   * @description Identifies the title of the release asset.
   */
  name: () => new Field("name"),

  /**
   * @description Release that the asset is associated with
   */

  release: (select) =>
    new Field("release", undefined as never, new SelectionSet(select(Release))),

  /**
   * @description The size (in bytes) of the asset
   */
  size: () => new Field("size"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The user that performed the upload
   */

  uploadedBy: (select) =>
    new Field("uploadedBy", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Identifies the URL of the release asset.
   */
  url: () => new Field("url"),
};

export interface IReleaseAssetConnection {
  edges: IReleaseAssetEdge[];
  nodes: IReleaseAsset[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface ReleaseAssetConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ReleaseAssetEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: ReleaseAssetSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const ReleaseAssetConnection: ReleaseAssetConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReleaseAssetEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ReleaseAsset))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReleaseAssetEdge {
  cursor: string;
  node: IReleaseAsset;
}

interface ReleaseAssetEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: ReleaseAssetSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReleaseAssetEdge: ReleaseAssetEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ReleaseAsset))
    ),
};

export interface IReleaseConnection {
  edges: IReleaseEdge[];
  nodes: IRelease[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface ReleaseConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ReleaseEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: ReleaseSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const ReleaseConnection: ReleaseConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReleaseEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Release))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReleaseEdge {
  cursor: string;
  node: IRelease;
}

interface ReleaseEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: ReleaseSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReleaseEdge: ReleaseEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Release))),
};

export interface IRemoveAssigneesFromAssignablePayload {
  assignable: IAssignable;
  clientMutationId: string;
}

interface RemoveAssigneesFromAssignablePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The item that was unassigned.
   */

  assignable: <T extends Array<Selection>>(
    select: (t: AssignableSelector) => T
  ) => Field<"assignable", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const RemoveAssigneesFromAssignablePayload: RemoveAssigneesFromAssignablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The item that was unassigned.
   */

  assignable: (select) =>
    new Field(
      "assignable",
      undefined as never,
      new SelectionSet(select(Assignable))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IRemoveEnterpriseAdminPayload {
  admin: IUser;
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
  viewer: IUser;
}

interface RemoveEnterpriseAdminPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The user who was removed as an administrator.
   */

  admin: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"admin", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated enterprise.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of removing an administrator.
   */

  message: () => Field<"message">;

  /**
   * @description The viewer performing the mutation.
   */

  viewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"viewer", never, SelectionSet<T>>;
}

export const RemoveEnterpriseAdminPayload: RemoveEnterpriseAdminPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The user who was removed as an administrator.
   */

  admin: (select) =>
    new Field("admin", undefined as never, new SelectionSet(select(User))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated enterprise.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of removing an administrator.
   */
  message: () => new Field("message"),

  /**
   * @description The viewer performing the mutation.
   */

  viewer: (select) =>
    new Field("viewer", undefined as never, new SelectionSet(select(User))),
};

export interface IRemoveEnterpriseIdentityProviderPayload {
  clientMutationId: string;
  identityProvider: IEnterpriseIdentityProvider;
}

interface RemoveEnterpriseIdentityProviderPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The identity provider that was removed from the enterprise.
   */

  identityProvider: <T extends Array<Selection>>(
    select: (t: EnterpriseIdentityProviderSelector) => T
  ) => Field<"identityProvider", never, SelectionSet<T>>;
}

export const RemoveEnterpriseIdentityProviderPayload: RemoveEnterpriseIdentityProviderPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The identity provider that was removed from the enterprise.
   */

  identityProvider: (select) =>
    new Field(
      "identityProvider",
      undefined as never,
      new SelectionSet(select(EnterpriseIdentityProvider))
    ),
};

export interface IRemoveEnterpriseOrganizationPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  organization: IOrganization;
  viewer: IUser;
}

interface RemoveEnterpriseOrganizationPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated enterprise.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description The organization that was removed from the enterprise.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The viewer performing the mutation.
   */

  viewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"viewer", never, SelectionSet<T>>;
}

export const RemoveEnterpriseOrganizationPayload: RemoveEnterpriseOrganizationPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated enterprise.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description The organization that was removed from the enterprise.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The viewer performing the mutation.
   */

  viewer: (select) =>
    new Field("viewer", undefined as never, new SelectionSet(select(User))),
};

export interface IRemoveLabelsFromLabelablePayload {
  clientMutationId: string;
  labelable: ILabelable;
}

interface RemoveLabelsFromLabelablePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The Labelable the labels were removed from.
   */

  labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const RemoveLabelsFromLabelablePayload: RemoveLabelsFromLabelablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The Labelable the labels were removed from.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface IRemoveOutsideCollaboratorPayload {
  clientMutationId: string;
  removedUser: IUser;
}

interface RemoveOutsideCollaboratorPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The user that was removed as an outside collaborator.
   */

  removedUser: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"removedUser", never, SelectionSet<T>>;
}

export const RemoveOutsideCollaboratorPayload: RemoveOutsideCollaboratorPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The user that was removed as an outside collaborator.
   */

  removedUser: (select) =>
    new Field(
      "removedUser",
      undefined as never,
      new SelectionSet(select(User))
    ),
};

export interface IRemoveReactionPayload {
  clientMutationId: string;
  reaction: IReaction;
  subject: IReactable;
}

interface RemoveReactionPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The reaction object.
   */

  reaction: <T extends Array<Selection>>(
    select: (t: ReactionSelector) => T
  ) => Field<"reaction", never, SelectionSet<T>>;

  /**
   * @description The reactable subject.
   */

  subject: <T extends Array<Selection>>(
    select: (t: ReactableSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const RemoveReactionPayload: RemoveReactionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The reaction object.
   */

  reaction: (select) =>
    new Field(
      "reaction",
      undefined as never,
      new SelectionSet(select(Reaction))
    ),

  /**
   * @description The reactable subject.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(Reactable))
    ),
};

export interface IRemoveStarPayload {
  clientMutationId: string;
  starrable: IStarrable;
}

interface RemoveStarPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The starrable.
   */

  starrable: <T extends Array<Selection>>(
    select: (t: StarrableSelector) => T
  ) => Field<"starrable", never, SelectionSet<T>>;
}

export const RemoveStarPayload: RemoveStarPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The starrable.
   */

  starrable: (select) =>
    new Field(
      "starrable",
      undefined as never,
      new SelectionSet(select(Starrable))
    ),
};

export interface IRemovedFromProjectEvent extends INode {
  __typename: "RemovedFromProjectEvent";
  actor: IActor;
  createdAt: unknown;
  databaseId: number;
}

interface RemovedFromProjectEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;
}

export const isRemovedFromProjectEvent = (
  object: Record<string, any>
): object is Partial<IRemovedFromProjectEvent> => {
  return object.__typename === "RemovedFromProjectEvent";
};

export const RemovedFromProjectEvent: RemovedFromProjectEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),
};

export interface IRenamedTitleEvent extends INode {
  __typename: "RenamedTitleEvent";
  actor: IActor;
  createdAt: unknown;
  currentTitle: string;
  previousTitle: string;
  subject: IRenamedTitleSubject;
}

interface RenamedTitleEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the current title of the issue or pull request.
   */

  currentTitle: () => Field<"currentTitle">;

  id: () => Field<"id">;

  /**
   * @description Identifies the previous title of the issue or pull request.
   */

  previousTitle: () => Field<"previousTitle">;

  /**
   * @description Subject that was renamed.
   */

  subject: <T extends Array<Selection>>(
    select: (t: RenamedTitleSubjectSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isRenamedTitleEvent = (
  object: Record<string, any>
): object is Partial<IRenamedTitleEvent> => {
  return object.__typename === "RenamedTitleEvent";
};

export const RenamedTitleEvent: RenamedTitleEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the current title of the issue or pull request.
   */
  currentTitle: () => new Field("currentTitle"),
  id: () => new Field("id"),

  /**
   * @description Identifies the previous title of the issue or pull request.
   */
  previousTitle: () => new Field("previousTitle"),

  /**
   * @description Subject that was renamed.
   */

  subject: (select) =>
    new Field(
      "subject",
      undefined as never,
      new SelectionSet(select(RenamedTitleSubject))
    ),
};

export interface IReopenIssuePayload {
  clientMutationId: string;
  issue: IIssue;
}

interface ReopenIssuePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue that was opened.
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const ReopenIssuePayload: ReopenIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue that was opened.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IReopenPullRequestPayload {
  clientMutationId: string;
  pullRequest: IPullRequest;
}

interface ReopenPullRequestPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that was reopened.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const ReopenPullRequestPayload: ReopenPullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that was reopened.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IReopenedEvent extends INode {
  __typename: "ReopenedEvent";
  actor: IActor;
  closable: IClosable;
  createdAt: unknown;
}

interface ReopenedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Object that was reopened.
   */

  closable: <T extends Array<Selection>>(
    select: (t: ClosableSelector) => T
  ) => Field<"closable", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;
}

export const isReopenedEvent = (
  object: Record<string, any>
): object is Partial<IReopenedEvent> => {
  return object.__typename === "ReopenedEvent";
};

export const ReopenedEvent: ReopenedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Object that was reopened.
   */

  closable: (select) =>
    new Field(
      "closable",
      undefined as never,
      new SelectionSet(select(Closable))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),
};

export interface IRepoAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoAccessAuditEntry";
  visibility: RepoAccessAuditEntryVisibility;
}

interface RepoAccessAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  visibility: () => Field<"visibility">;
}

export const isRepoAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoAccessAuditEntry> => {
  return object.__typename === "RepoAccessAuditEntry";
};

export const RepoAccessAuditEntry: RepoAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoAddMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoAddMemberAuditEntry";
  visibility: RepoAddMemberAuditEntryVisibility;
}

interface RepoAddMemberAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  visibility: () => Field<"visibility">;
}

export const isRepoAddMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoAddMemberAuditEntry> => {
  return object.__typename === "RepoAddMemberAuditEntry";
};

export const RepoAddMemberAuditEntry: RepoAddMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoAddTopicAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData,
    ITopicAuditEntryData {
  __typename: "RepoAddTopicAuditEntry";
}

interface RepoAddTopicAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The name of the topic added to the repository
   */

  topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;

  /**
   * @description The name of the topic added to the repository
   */

  topicName: () => Field<"topicName">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoAddTopicAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoAddTopicAuditEntry> => {
  return object.__typename === "RepoAddTopicAuditEntry";
};

export const RepoAddTopicAuditEntry: RepoAddTopicAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The name of the topic added to the repository
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),

  /**
   * @description The name of the topic added to the repository
   */
  topicName: () => new Field("topicName"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoArchivedAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoArchivedAuditEntry";
  visibility: RepoArchivedAuditEntryVisibility;
}

interface RepoArchivedAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  visibility: () => Field<"visibility">;
}

export const isRepoArchivedAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoArchivedAuditEntry> => {
  return object.__typename === "RepoArchivedAuditEntry";
};

export const RepoArchivedAuditEntry: RepoArchivedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoChangeMergeSettingAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoChangeMergeSettingAuditEntry";
  isEnabled: boolean;
  mergeType: RepoChangeMergeSettingAuditEntryMergeType;
}

interface RepoChangeMergeSettingAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Whether the change was to enable (true) or disable (false) the merge type
   */

  isEnabled: () => Field<"isEnabled">;

  /**
   * @description The merge method affected by the change
   */

  mergeType: () => Field<"mergeType">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoChangeMergeSettingAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoChangeMergeSettingAuditEntry> => {
  return object.__typename === "RepoChangeMergeSettingAuditEntry";
};

export const RepoChangeMergeSettingAuditEntry: RepoChangeMergeSettingAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the change was to enable (true) or disable (false) the merge type
   */
  isEnabled: () => new Field("isEnabled"),

  /**
   * @description The merge method affected by the change
   */
  mergeType: () => new Field("mergeType"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigDisableAnonymousGitAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigDisableAnonymousGitAccessAuditEntry";
}

interface RepoConfigDisableAnonymousGitAccessAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigDisableAnonymousGitAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigDisableAnonymousGitAccessAuditEntry> => {
  return object.__typename === "RepoConfigDisableAnonymousGitAccessAuditEntry";
};

export const RepoConfigDisableAnonymousGitAccessAuditEntry: RepoConfigDisableAnonymousGitAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigDisableCollaboratorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigDisableCollaboratorsOnlyAuditEntry";
}

interface RepoConfigDisableCollaboratorsOnlyAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigDisableCollaboratorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigDisableCollaboratorsOnlyAuditEntry> => {
  return object.__typename === "RepoConfigDisableCollaboratorsOnlyAuditEntry";
};

export const RepoConfigDisableCollaboratorsOnlyAuditEntry: RepoConfigDisableCollaboratorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigDisableContributorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigDisableContributorsOnlyAuditEntry";
}

interface RepoConfigDisableContributorsOnlyAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigDisableContributorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigDisableContributorsOnlyAuditEntry> => {
  return object.__typename === "RepoConfigDisableContributorsOnlyAuditEntry";
};

export const RepoConfigDisableContributorsOnlyAuditEntry: RepoConfigDisableContributorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigDisableSockpuppetDisallowedAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigDisableSockpuppetDisallowedAuditEntry";
}

interface RepoConfigDisableSockpuppetDisallowedAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigDisableSockpuppetDisallowedAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigDisableSockpuppetDisallowedAuditEntry> => {
  return (
    object.__typename === "RepoConfigDisableSockpuppetDisallowedAuditEntry"
  );
};

export const RepoConfigDisableSockpuppetDisallowedAuditEntry: RepoConfigDisableSockpuppetDisallowedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigEnableAnonymousGitAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigEnableAnonymousGitAccessAuditEntry";
}

interface RepoConfigEnableAnonymousGitAccessAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigEnableAnonymousGitAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigEnableAnonymousGitAccessAuditEntry> => {
  return object.__typename === "RepoConfigEnableAnonymousGitAccessAuditEntry";
};

export const RepoConfigEnableAnonymousGitAccessAuditEntry: RepoConfigEnableAnonymousGitAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigEnableCollaboratorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigEnableCollaboratorsOnlyAuditEntry";
}

interface RepoConfigEnableCollaboratorsOnlyAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigEnableCollaboratorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigEnableCollaboratorsOnlyAuditEntry> => {
  return object.__typename === "RepoConfigEnableCollaboratorsOnlyAuditEntry";
};

export const RepoConfigEnableCollaboratorsOnlyAuditEntry: RepoConfigEnableCollaboratorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigEnableContributorsOnlyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigEnableContributorsOnlyAuditEntry";
}

interface RepoConfigEnableContributorsOnlyAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigEnableContributorsOnlyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigEnableContributorsOnlyAuditEntry> => {
  return object.__typename === "RepoConfigEnableContributorsOnlyAuditEntry";
};

export const RepoConfigEnableContributorsOnlyAuditEntry: RepoConfigEnableContributorsOnlyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigEnableSockpuppetDisallowedAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigEnableSockpuppetDisallowedAuditEntry";
}

interface RepoConfigEnableSockpuppetDisallowedAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigEnableSockpuppetDisallowedAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigEnableSockpuppetDisallowedAuditEntry> => {
  return object.__typename === "RepoConfigEnableSockpuppetDisallowedAuditEntry";
};

export const RepoConfigEnableSockpuppetDisallowedAuditEntry: RepoConfigEnableSockpuppetDisallowedAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigLockAnonymousGitAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigLockAnonymousGitAccessAuditEntry";
}

interface RepoConfigLockAnonymousGitAccessAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigLockAnonymousGitAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigLockAnonymousGitAccessAuditEntry> => {
  return object.__typename === "RepoConfigLockAnonymousGitAccessAuditEntry";
};

export const RepoConfigLockAnonymousGitAccessAuditEntry: RepoConfigLockAnonymousGitAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoConfigUnlockAnonymousGitAccessAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoConfigUnlockAnonymousGitAccessAuditEntry";
}

interface RepoConfigUnlockAnonymousGitAccessAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoConfigUnlockAnonymousGitAccessAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoConfigUnlockAnonymousGitAccessAuditEntry> => {
  return object.__typename === "RepoConfigUnlockAnonymousGitAccessAuditEntry";
};

export const RepoConfigUnlockAnonymousGitAccessAuditEntry: RepoConfigUnlockAnonymousGitAccessAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepoCreateAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoCreateAuditEntry";
  forkParentName: string;
  forkSourceName: string;
  visibility: RepoCreateAuditEntryVisibility;
}

interface RepoCreateAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The name of the parent repository for this forked repository.
   */

  forkParentName: () => Field<"forkParentName">;

  /**
   * @description The name of the root repository for this netork.
   */

  forkSourceName: () => Field<"forkSourceName">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  visibility: () => Field<"visibility">;
}

export const isRepoCreateAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoCreateAuditEntry> => {
  return object.__typename === "RepoCreateAuditEntry";
};

export const RepoCreateAuditEntry: RepoCreateAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The name of the parent repository for this forked repository.
   */
  forkParentName: () => new Field("forkParentName"),

  /**
   * @description The name of the root repository for this netork.
   */
  forkSourceName: () => new Field("forkSourceName"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoDestroyAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoDestroyAuditEntry";
  visibility: RepoDestroyAuditEntryVisibility;
}

interface RepoDestroyAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  visibility: () => Field<"visibility">;
}

export const isRepoDestroyAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoDestroyAuditEntry> => {
  return object.__typename === "RepoDestroyAuditEntry";
};

export const RepoDestroyAuditEntry: RepoDestroyAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoRemoveMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData {
  __typename: "RepoRemoveMemberAuditEntry";
  visibility: RepoRemoveMemberAuditEntryVisibility;
}

interface RepoRemoveMemberAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;

  /**
   * @description The visibility of the repository
   */

  visibility: () => Field<"visibility">;
}

export const isRepoRemoveMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoRemoveMemberAuditEntry> => {
  return object.__typename === "RepoRemoveMemberAuditEntry";
};

export const RepoRemoveMemberAuditEntry: RepoRemoveMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),

  /**
   * @description The visibility of the repository
   */
  visibility: () => new Field("visibility"),
};

export interface IRepoRemoveTopicAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData,
    ITopicAuditEntryData {
  __typename: "RepoRemoveTopicAuditEntry";
}

interface RepoRemoveTopicAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The name of the topic added to the repository
   */

  topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;

  /**
   * @description The name of the topic added to the repository
   */

  topicName: () => Field<"topicName">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepoRemoveTopicAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepoRemoveTopicAuditEntry> => {
  return object.__typename === "RepoRemoveTopicAuditEntry";
};

export const RepoRemoveTopicAuditEntry: RepoRemoveTopicAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The name of the topic added to the repository
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),

  /**
   * @description The name of the topic added to the repository
   */
  topicName: () => new Field("topicName"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepository
  extends INode,
    IPackageOwner,
    IProjectOwner,
    IRepositoryInfo,
    IStarrable,
    ISubscribable,
    IUniformResourceLocatable {
  __typename: "Repository";
  assignableUsers: IUserConnection;
  branchProtectionRules: IBranchProtectionRuleConnection;
  codeOfConduct: ICodeOfConduct;
  collaborators: IRepositoryCollaboratorConnection;
  commitComments: ICommitCommentConnection;
  contactLinks: IRepositoryContactLink[];
  databaseId: number;
  defaultBranchRef: IRef;
  deleteBranchOnMerge: boolean;
  deployKeys: IDeployKeyConnection;
  deployments: IDeploymentConnection;
  diskUsage: number;
  forks: IRepositoryConnection;
  fundingLinks: IFundingLink[];
  interactionAbility: IRepositoryInteractionAbility;
  isBlankIssuesEnabled: boolean;
  isDisabled: boolean;
  isEmpty: boolean;
  isSecurityPolicyEnabled: boolean;
  isUserConfigurationRepository: boolean;
  issue: IIssue;
  issueOrPullRequest: IIssueOrPullRequest;
  issueTemplates: IIssueTemplate[];
  issues: IIssueConnection;
  label: ILabel;
  labels: ILabelConnection;
  languages: ILanguageConnection;
  mentionableUsers: IUserConnection;
  mergeCommitAllowed: boolean;
  milestone: IMilestone;
  milestones: IMilestoneConnection;
  object: IGitObject;
  parent: IRepository;
  primaryLanguage: ILanguage;
  pullRequest: IPullRequest;
  pullRequests: IPullRequestConnection;
  rebaseMergeAllowed: boolean;
  ref: IRef;
  refs: IRefConnection;
  release: IRelease;
  releases: IReleaseConnection;
  repositoryTopics: IRepositoryTopicConnection;
  securityPolicyUrl: unknown;
  squashMergeAllowed: boolean;
  sshUrl: unknown;
  submodules: ISubmoduleConnection;
  tempCloneToken: string;
  templateRepository: IRepository;
  viewerCanAdminister: boolean;
  viewerCanUpdateTopics: boolean;
  viewerDefaultCommitEmail: string;
  viewerDefaultMergeMethod: PullRequestMergeMethod;
  viewerPermission: RepositoryPermission;
  viewerPossibleCommitEmails: string[];
  vulnerabilityAlerts: IRepositoryVulnerabilityAlertConnection;
  watchers: IUserConnection;
}

interface RepositorySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of users that can be assigned to issues in this repository.
   */

  assignableUsers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "assignableUsers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of branch protection rules for this repository.
   */

  branchProtectionRules: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: BranchProtectionRuleConnectionSelector) => T
  ) => Field<
    "branchProtectionRules",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns the code of conduct for this repository
   */

  codeOfConduct: <T extends Array<Selection>>(
    select: (t: CodeOfConductSelector) => T
  ) => Field<"codeOfConduct", never, SelectionSet<T>>;

  /**
   * @description A list of collaborators associated with the repository.
   */

  collaborators: <T extends Array<Selection>>(
    variables: {
      affiliation?: Variable<"affiliation"> | CollaboratorAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: RepositoryCollaboratorConnectionSelector) => T
  ) => Field<
    "collaborators",
    [
      Argument<
        "affiliation",
        Variable<"affiliation"> | CollaboratorAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of commit comments associated with the repository.
   */

  commitComments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "commitComments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns a list of contact links associated to the repository
   */

  contactLinks: <T extends Array<Selection>>(
    select: (t: RepositoryContactLinkSelector) => T
  ) => Field<"contactLinks", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The Ref associated with the repository's default branch.
   */

  defaultBranchRef: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"defaultBranchRef", never, SelectionSet<T>>;

  /**
   * @description Whether or not branches are automatically deleted when merged in this repository.
   */

  deleteBranchOnMerge: () => Field<"deleteBranchOnMerge">;

  /**
   * @description A list of deploy keys that are on this repository.
   */

  deployKeys: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: DeployKeyConnectionSelector) => T
  ) => Field<
    "deployKeys",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Deployments associated with the repository
   */

  deployments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      environments?: Variable<"environments"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | DeploymentOrder;
    },
    select: (t: DeploymentConnectionSelector) => T
  ) => Field<
    "deployments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"environments", Variable<"environments"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | DeploymentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The description of the repository.
   */

  description: () => Field<"description">;

  /**
   * @description The description of the repository rendered to HTML.
   */

  descriptionHTML: () => Field<"descriptionHTML">;

  /**
   * @description The number of kilobytes this repository occupies on disk.
   */

  diskUsage: () => Field<"diskUsage">;

  /**
   * @description Returns how many forks there are of this repository in the whole network.
   */

  forkCount: () => Field<"forkCount">;

  /**
   * @description A list of direct forked repositories.
   */

  forks: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "forks",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The funding links for this repository
   */

  fundingLinks: <T extends Array<Selection>>(
    select: (t: FundingLinkSelector) => T
  ) => Field<"fundingLinks", never, SelectionSet<T>>;

  /**
   * @description Indicates if the repository has issues feature enabled.
   */

  hasIssuesEnabled: () => Field<"hasIssuesEnabled">;

  /**
   * @description Indicates if the repository has the Projects feature enabled.
   */

  hasProjectsEnabled: () => Field<"hasProjectsEnabled">;

  /**
   * @description Indicates if the repository has wiki feature enabled.
   */

  hasWikiEnabled: () => Field<"hasWikiEnabled">;

  /**
   * @description The repository's URL.
   */

  homepageUrl: () => Field<"homepageUrl">;

  id: () => Field<"id">;

  /**
   * @description The interaction ability settings for this repository.
   */

  interactionAbility: <T extends Array<Selection>>(
    select: (t: RepositoryInteractionAbilitySelector) => T
  ) => Field<"interactionAbility", never, SelectionSet<T>>;

  /**
   * @description Indicates if the repository is unmaintained.
   */

  isArchived: () => Field<"isArchived">;

  /**
   * @description Returns true if blank issue creation is allowed
   */

  isBlankIssuesEnabled: () => Field<"isBlankIssuesEnabled">;

  /**
   * @description Returns whether or not this repository disabled.
   */

  isDisabled: () => Field<"isDisabled">;

  /**
   * @description Returns whether or not this repository is empty.
   */

  isEmpty: () => Field<"isEmpty">;

  /**
   * @description Identifies if the repository is a fork.
   */

  isFork: () => Field<"isFork">;

  /**
   * @description Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
   */

  isInOrganization: () => Field<"isInOrganization">;

  /**
   * @description Indicates if the repository has been locked or not.
   */

  isLocked: () => Field<"isLocked">;

  /**
   * @description Identifies if the repository is a mirror.
   */

  isMirror: () => Field<"isMirror">;

  /**
   * @description Identifies if the repository is private.
   */

  isPrivate: () => Field<"isPrivate">;

  /**
   * @description Returns true if this repository has a security policy
   */

  isSecurityPolicyEnabled: () => Field<"isSecurityPolicyEnabled">;

  /**
   * @description Identifies if the repository is a template that can be used to generate new repositories.
   */

  isTemplate: () => Field<"isTemplate">;

  /**
   * @description Is this repository a user configuration repository?
   */

  isUserConfigurationRepository: () => Field<"isUserConfigurationRepository">;

  /**
   * @description Returns a single issue from the current repository by number.
   */

  issue: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: IssueSelector) => T
  ) => Field<
    "issue",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description Returns a single issue-like object from the current repository by number.
   */

  issueOrPullRequest: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<
    "issueOrPullRequest",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description Returns a list of issue templates associated to the repository
   */

  issueTemplates: <T extends Array<Selection>>(
    select: (t: IssueTemplateSelector) => T
  ) => Field<"issueTemplates", never, SelectionSet<T>>;

  /**
   * @description A list of issues that have been opened in the repository.
   */

  issues: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | IssueFilters;
      first?: Variable<"first"> | number;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | IssueState;
    },
    select: (t: IssueConnectionSelector) => T
  ) => Field<
    "issues",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | IssueFilters>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | IssueState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns a single label by name
   */

  label: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: LabelSelector) => T
  ) => Field<
    "label",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description A list of labels associated with the repository.
   */

  labels: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LabelOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: LabelConnectionSelector) => T
  ) => Field<
    "labels",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LabelOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list containing a breakdown of the language composition of the repository.
   */

  languages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | LanguageOrder;
    },
    select: (t: LanguageConnectionSelector) => T
  ) => Field<
    "languages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | LanguageOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The license associated with the repository
   */

  licenseInfo: <T extends Array<Selection>>(
    select: (t: LicenseSelector) => T
  ) => Field<"licenseInfo", never, SelectionSet<T>>;

  /**
   * @description The reason the repository has been locked.
   */

  lockReason: () => Field<"lockReason">;

  /**
   * @description A list of Users that can be mentioned in the context of the repository.
   */

  mentionableUsers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      query?: Variable<"query"> | string;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "mentionableUsers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not PRs are merged with a merge commit on this repository.
   */

  mergeCommitAllowed: () => Field<"mergeCommitAllowed">;

  /**
   * @description Returns a single milestone from the current repository by number.
   */

  milestone: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: MilestoneSelector) => T
  ) => Field<
    "milestone",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of milestones associated with the repository.
   */

  milestones: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | MilestoneOrder;
      query?: Variable<"query"> | string;
      states?: Variable<"states"> | MilestoneState;
    },
    select: (t: MilestoneConnectionSelector) => T
  ) => Field<
    "milestones",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | MilestoneOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"states", Variable<"states"> | MilestoneState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository's original mirror URL.
   */

  mirrorUrl: () => Field<"mirrorUrl">;

  /**
   * @description The name of the repository.
   */

  name: () => Field<"name">;

  /**
   * @description The repository's name with owner.
   */

  nameWithOwner: () => Field<"nameWithOwner">;

  /**
   * @description A Git object in the repository
   */

  object: <T extends Array<Selection>>(
    variables: {
      expression?: Variable<"expression"> | string;
      oid?: Variable<"oid"> | unknown;
    },
    select: (t: GitObjectSelector) => T
  ) => Field<
    "object",
    [
      Argument<"expression", Variable<"expression"> | string>,
      Argument<"oid", Variable<"oid"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The image used to represent this repository in Open Graph data.
   */

  openGraphImageUrl: () => Field<"openGraphImageUrl">;

  /**
   * @description The User owner of the repository.
   */

  owner: <T extends Array<Selection>>(
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description A list of packages under the owner.
   */

  packages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      names?: Variable<"names"> | string;
      orderBy?: Variable<"orderBy"> | PackageOrder;
      packageType?: Variable<"packageType"> | PackageType;
      repositoryId?: Variable<"repositoryId"> | string;
    },
    select: (t: PackageConnectionSelector) => T
  ) => Field<
    "packages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"names", Variable<"names"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | PackageOrder>,
      Argument<"packageType", Variable<"packageType"> | PackageType>,
      Argument<"repositoryId", Variable<"repositoryId"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The repository parent, if this is a fork.
   */

  parent: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"parent", never, SelectionSet<T>>;

  /**
   * @description The primary language of the repository's code.
   */

  primaryLanguage: <T extends Array<Selection>>(
    select: (t: LanguageSelector) => T
  ) => Field<"primaryLanguage", never, SelectionSet<T>>;

  /**
   * @description Find project by number.
   */

  project: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: ProjectSelector) => T
  ) => Field<
    "project",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of projects under the owner.
   */

  projects: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ProjectOrder;
      search?: Variable<"search"> | string;
      states?: Variable<"states"> | ProjectState;
    },
    select: (t: ProjectConnectionSelector) => T
  ) => Field<
    "projects",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ProjectOrder>,
      Argument<"search", Variable<"search"> | string>,
      Argument<"states", Variable<"states"> | ProjectState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing the repository's projects
   */

  projectsResourcePath: () => Field<"projectsResourcePath">;

  /**
   * @description The HTTP URL listing the repository's projects
   */

  projectsUrl: () => Field<"projectsUrl">;

  /**
   * @description Returns a single pull request from the current repository by number.
   */

  pullRequest: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: PullRequestSelector) => T
  ) => Field<
    "pullRequest",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of pull requests that have been opened in the repository.
   */

  pullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "pullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies when the repository was last pushed to.
   */

  pushedAt: () => Field<"pushedAt">;

  /**
   * @description Whether or not rebase-merging is enabled on this repository.
   */

  rebaseMergeAllowed: () => Field<"rebaseMergeAllowed">;

  /**
   * @description Fetch a given ref from the repository
   */

  ref: <T extends Array<Selection>>(
    variables: { qualifiedName?: Variable<"qualifiedName"> | string },
    select: (t: RefSelector) => T
  ) => Field<
    "ref",
    [Argument<"qualifiedName", Variable<"qualifiedName"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Fetch a list of refs from the repository
   */

  refs: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      direction?: Variable<"direction"> | OrderDirection;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RefOrder;
      query?: Variable<"query"> | string;
      refPrefix?: Variable<"refPrefix"> | string;
    },
    select: (t: RefConnectionSelector) => T
  ) => Field<
    "refs",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"direction", Variable<"direction"> | OrderDirection>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RefOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"refPrefix", Variable<"refPrefix"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Lookup a single release given various criteria.
   */

  release: <T extends Array<Selection>>(
    variables: { tagName?: Variable<"tagName"> | string },
    select: (t: ReleaseSelector) => T
  ) => Field<
    "release",
    [Argument<"tagName", Variable<"tagName"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description List of releases which are dependent on this repository.
   */

  releases: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReleaseOrder;
    },
    select: (t: ReleaseConnectionSelector) => T
  ) => Field<
    "releases",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReleaseOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of applied repository-topic associations for this repository.
   */

  repositoryTopics: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: RepositoryTopicConnectionSelector) => T
  ) => Field<
    "repositoryTopics",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this repository
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The security policy URL.
   */

  securityPolicyUrl: () => Field<"securityPolicyUrl">;

  /**
   * @description A description of the repository, rendered to HTML without any links in it.
   */

  shortDescriptionHTML: (variables: {
    limit: unknown;
  }) => Field<"shortDescriptionHTML", [/* @todo */]>;

  /**
   * @description Whether or not squash-merging is enabled on this repository.
   */

  squashMergeAllowed: () => Field<"squashMergeAllowed">;

  /**
   * @description The SSH URL to clone this repository
   */

  sshUrl: () => Field<"sshUrl">;

  /**
   * @description Returns a count of how many stargazers there are on this object
   */

  stargazerCount: () => Field<"stargazerCount">;

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
    },
    select: (t: StargazerConnectionSelector) => T
  ) => Field<
    "stargazers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>
    ],
    SelectionSet<T>
  >;

  /**
     * @description Returns a list of all submodules in this repository parsed from the
.gitmodules file as of the default branch's HEAD commit.
     */

  submodules: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: SubmoduleConnectionSelector) => T
  ) => Field<
    "submodules",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Temporary authentication token for cloning this repository.
   */

  tempCloneToken: () => Field<"tempCloneToken">;

  /**
   * @description The repository from which this repository was generated, if any.
   */

  templateRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"templateRepository", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this repository
   */

  url: () => Field<"url">;

  /**
   * @description Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
   */

  usesCustomOpenGraphImage: () => Field<"usesCustomOpenGraphImage">;

  /**
   * @description Indicates whether the viewer has admin permissions on this repository.
   */

  viewerCanAdminister: () => Field<"viewerCanAdminister">;

  /**
   * @description Can the current viewer create new projects on this owner.
   */

  viewerCanCreateProjects: () => Field<"viewerCanCreateProjects">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Indicates whether the viewer can update the topics of this repository.
   */

  viewerCanUpdateTopics: () => Field<"viewerCanUpdateTopics">;

  /**
   * @description The last commit email for the viewer.
   */

  viewerDefaultCommitEmail: () => Field<"viewerDefaultCommitEmail">;

  /**
   * @description The last used merge method by the viewer or the default for the repository.
   */

  viewerDefaultMergeMethod: () => Field<"viewerDefaultMergeMethod">;

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */

  viewerHasStarred: () => Field<"viewerHasStarred">;

  /**
   * @description The users permission level on the repository. Will return null if authenticated as an GitHub App.
   */

  viewerPermission: () => Field<"viewerPermission">;

  /**
   * @description A list of emails this viewer can commit with.
   */

  viewerPossibleCommitEmails: () => Field<"viewerPossibleCommitEmails">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  viewerSubscription: () => Field<"viewerSubscription">;

  /**
   * @description A list of vulnerability alerts that are on this repository.
   */

  vulnerabilityAlerts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: RepositoryVulnerabilityAlertConnectionSelector) => T
  ) => Field<
    "vulnerabilityAlerts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users watching the repository.
   */

  watchers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserConnectionSelector) => T
  ) => Field<
    "watchers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;
}

export const isRepository = (
  object: Record<string, any>
): object is Partial<IRepository> => {
  return object.__typename === "Repository";
};

export const Repository: RepositorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of users that can be assigned to issues in this repository.
   */

  assignableUsers: (variables, select) =>
    new Field(
      "assignableUsers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description A list of branch protection rules for this repository.
   */

  branchProtectionRules: (variables, select) =>
    new Field(
      "branchProtectionRules",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(BranchProtectionRuleConnection))
    ),

  /**
   * @description Returns the code of conduct for this repository
   */

  codeOfConduct: (select) =>
    new Field(
      "codeOfConduct",
      undefined as never,
      new SelectionSet(select(CodeOfConduct))
    ),

  /**
   * @description A list of collaborators associated with the repository.
   */

  collaborators: (variables, select) =>
    new Field(
      "collaborators",
      [
        new Argument(
          "affiliation",
          variables.affiliation,
          CollaboratorAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(RepositoryCollaboratorConnection))
    ),

  /**
   * @description A list of commit comments associated with the repository.
   */

  commitComments: (variables, select) =>
    new Field(
      "commitComments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description Returns a list of contact links associated to the repository
   */

  contactLinks: (select) =>
    new Field(
      "contactLinks",
      undefined as never,
      new SelectionSet(select(RepositoryContactLink))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The Ref associated with the repository's default branch.
   */

  defaultBranchRef: (select) =>
    new Field(
      "defaultBranchRef",
      undefined as never,
      new SelectionSet(select(Ref))
    ),

  /**
   * @description Whether or not branches are automatically deleted when merged in this repository.
   */
  deleteBranchOnMerge: () => new Field("deleteBranchOnMerge"),

  /**
   * @description A list of deploy keys that are on this repository.
   */

  deployKeys: (variables, select) =>
    new Field(
      "deployKeys",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(DeployKeyConnection))
    ),

  /**
   * @description Deployments associated with the repository
   */

  deployments: (variables, select) =>
    new Field(
      "deployments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("environments", variables.environments),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(DeploymentConnection))
    ),

  /**
   * @description The description of the repository.
   */
  description: () => new Field("description"),

  /**
   * @description The description of the repository rendered to HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),

  /**
   * @description The number of kilobytes this repository occupies on disk.
   */
  diskUsage: () => new Field("diskUsage"),

  /**
   * @description Returns how many forks there are of this repository in the whole network.
   */
  forkCount: () => new Field("forkCount"),

  /**
   * @description A list of direct forked repositories.
   */

  forks: (variables, select) =>
    new Field(
      "forks",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description The funding links for this repository
   */

  fundingLinks: (select) =>
    new Field(
      "fundingLinks",
      undefined as never,
      new SelectionSet(select(FundingLink))
    ),

  /**
   * @description Indicates if the repository has issues feature enabled.
   */
  hasIssuesEnabled: () => new Field("hasIssuesEnabled"),

  /**
   * @description Indicates if the repository has the Projects feature enabled.
   */
  hasProjectsEnabled: () => new Field("hasProjectsEnabled"),

  /**
   * @description Indicates if the repository has wiki feature enabled.
   */
  hasWikiEnabled: () => new Field("hasWikiEnabled"),

  /**
   * @description The repository's URL.
   */
  homepageUrl: () => new Field("homepageUrl"),
  id: () => new Field("id"),

  /**
   * @description The interaction ability settings for this repository.
   */

  interactionAbility: (select) =>
    new Field(
      "interactionAbility",
      undefined as never,
      new SelectionSet(select(RepositoryInteractionAbility))
    ),

  /**
   * @description Indicates if the repository is unmaintained.
   */
  isArchived: () => new Field("isArchived"),

  /**
   * @description Returns true if blank issue creation is allowed
   */
  isBlankIssuesEnabled: () => new Field("isBlankIssuesEnabled"),

  /**
   * @description Returns whether or not this repository disabled.
   */
  isDisabled: () => new Field("isDisabled"),

  /**
   * @description Returns whether or not this repository is empty.
   */
  isEmpty: () => new Field("isEmpty"),

  /**
   * @description Identifies if the repository is a fork.
   */
  isFork: () => new Field("isFork"),

  /**
   * @description Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
   */
  isInOrganization: () => new Field("isInOrganization"),

  /**
   * @description Indicates if the repository has been locked or not.
   */
  isLocked: () => new Field("isLocked"),

  /**
   * @description Identifies if the repository is a mirror.
   */
  isMirror: () => new Field("isMirror"),

  /**
   * @description Identifies if the repository is private.
   */
  isPrivate: () => new Field("isPrivate"),

  /**
   * @description Returns true if this repository has a security policy
   */
  isSecurityPolicyEnabled: () => new Field("isSecurityPolicyEnabled"),

  /**
   * @description Identifies if the repository is a template that can be used to generate new repositories.
   */
  isTemplate: () => new Field("isTemplate"),

  /**
   * @description Is this repository a user configuration repository?
   */
  isUserConfigurationRepository: () =>
    new Field("isUserConfigurationRepository"),

  /**
   * @description Returns a single issue from the current repository by number.
   */

  issue: (variables, select) =>
    new Field(
      "issue",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Issue))
    ),

  /**
   * @description Returns a single issue-like object from the current repository by number.
   */

  issueOrPullRequest: (variables, select) =>
    new Field(
      "issueOrPullRequest",
      [new Argument("number", variables.number)],
      new SelectionSet(select(IssueOrPullRequest))
    ),

  /**
   * @description Returns a list of issue templates associated to the repository
   */

  issueTemplates: (select) =>
    new Field(
      "issueTemplates",
      undefined as never,
      new SelectionSet(select(IssueTemplate))
    ),

  /**
   * @description A list of issues that have been opened in the repository.
   */

  issues: (variables, select) =>
    new Field(
      "issues",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, IssueState),
      ],
      new SelectionSet(select(IssueConnection))
    ),

  /**
   * @description Returns a single label by name
   */

  label: (variables, select) =>
    new Field(
      "label",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Label))
    ),

  /**
   * @description A list of labels associated with the repository.
   */

  labels: (variables, select) =>
    new Field(
      "labels",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(LabelConnection))
    ),

  /**
   * @description A list containing a breakdown of the language composition of the repository.
   */

  languages: (variables, select) =>
    new Field(
      "languages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(LanguageConnection))
    ),

  /**
   * @description The license associated with the repository
   */

  licenseInfo: (select) =>
    new Field(
      "licenseInfo",
      undefined as never,
      new SelectionSet(select(License))
    ),

  /**
   * @description The reason the repository has been locked.
   */
  lockReason: () => new Field("lockReason"),

  /**
   * @description A list of Users that can be mentioned in the context of the repository.
   */

  mentionableUsers: (variables, select) =>
    new Field(
      "mentionableUsers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(UserConnection))
    ),

  /**
   * @description Whether or not PRs are merged with a merge commit on this repository.
   */
  mergeCommitAllowed: () => new Field("mergeCommitAllowed"),

  /**
   * @description Returns a single milestone from the current repository by number.
   */

  milestone: (variables, select) =>
    new Field(
      "milestone",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Milestone))
    ),

  /**
   * @description A list of milestones associated with the repository.
   */

  milestones: (variables, select) =>
    new Field(
      "milestones",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("states", variables.states, MilestoneState),
      ],
      new SelectionSet(select(MilestoneConnection))
    ),

  /**
   * @description The repository's original mirror URL.
   */
  mirrorUrl: () => new Field("mirrorUrl"),

  /**
   * @description The name of the repository.
   */
  name: () => new Field("name"),

  /**
   * @description The repository's name with owner.
   */
  nameWithOwner: () => new Field("nameWithOwner"),

  /**
   * @description A Git object in the repository
   */

  object: (variables, select) =>
    new Field(
      "object",
      [
        new Argument("expression", variables.expression),
        new Argument("oid", variables.oid),
      ],
      new SelectionSet(select(GitObject))
    ),

  /**
   * @description The image used to represent this repository in Open Graph data.
   */
  openGraphImageUrl: () => new Field("openGraphImageUrl"),

  /**
   * @description The User owner of the repository.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description A list of packages under the owner.
   */

  packages: (variables, select) =>
    new Field(
      "packages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("names", variables.names),
        new Argument("orderBy", variables.orderBy),
        new Argument("packageType", variables.packageType, PackageType),
        new Argument("repositoryId", variables.repositoryId),
      ],
      new SelectionSet(select(PackageConnection))
    ),

  /**
   * @description The repository parent, if this is a fork.
   */

  parent: (select) =>
    new Field(
      "parent",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The primary language of the repository's code.
   */

  primaryLanguage: (select) =>
    new Field(
      "primaryLanguage",
      undefined as never,
      new SelectionSet(select(Language))
    ),

  /**
   * @description Find project by number.
   */

  project: (variables, select) =>
    new Field(
      "project",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Project))
    ),

  /**
   * @description A list of projects under the owner.
   */

  projects: (variables, select) =>
    new Field(
      "projects",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("search", variables.search),
        new Argument("states", variables.states, ProjectState),
      ],
      new SelectionSet(select(ProjectConnection))
    ),

  /**
   * @description The HTTP path listing the repository's projects
   */
  projectsResourcePath: () => new Field("projectsResourcePath"),

  /**
   * @description The HTTP URL listing the repository's projects
   */
  projectsUrl: () => new Field("projectsUrl"),

  /**
   * @description Returns a single pull request from the current repository by number.
   */

  pullRequest: (variables, select) =>
    new Field(
      "pullRequest",
      [new Argument("number", variables.number)],
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description A list of pull requests that have been opened in the repository.
   */

  pullRequests: (variables, select) =>
    new Field(
      "pullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description Identifies when the repository was last pushed to.
   */
  pushedAt: () => new Field("pushedAt"),

  /**
   * @description Whether or not rebase-merging is enabled on this repository.
   */
  rebaseMergeAllowed: () => new Field("rebaseMergeAllowed"),

  /**
   * @description Fetch a given ref from the repository
   */

  ref: (variables, select) =>
    new Field(
      "ref",
      [new Argument("qualifiedName", variables.qualifiedName)],
      new SelectionSet(select(Ref))
    ),

  /**
   * @description Fetch a list of refs from the repository
   */

  refs: (variables, select) =>
    new Field(
      "refs",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("direction", variables.direction, OrderDirection),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("refPrefix", variables.refPrefix),
      ],
      new SelectionSet(select(RefConnection))
    ),

  /**
   * @description Lookup a single release given various criteria.
   */

  release: (variables, select) =>
    new Field(
      "release",
      [new Argument("tagName", variables.tagName)],
      new SelectionSet(select(Release))
    ),

  /**
   * @description List of releases which are dependent on this repository.
   */

  releases: (variables, select) =>
    new Field(
      "releases",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReleaseConnection))
    ),

  /**
   * @description A list of applied repository-topic associations for this repository.
   */

  repositoryTopics: (variables, select) =>
    new Field(
      "repositoryTopics",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(RepositoryTopicConnection))
    ),

  /**
   * @description The HTTP path for this repository
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The security policy URL.
   */
  securityPolicyUrl: () => new Field("securityPolicyUrl"),

  /**
   * @description A description of the repository, rendered to HTML without any links in it.
   */
  shortDescriptionHTML: (variables) => new Field("shortDescriptionHTML"),

  /**
   * @description Whether or not squash-merging is enabled on this repository.
   */
  squashMergeAllowed: () => new Field("squashMergeAllowed"),

  /**
   * @description The SSH URL to clone this repository
   */
  sshUrl: () => new Field("sshUrl"),

  /**
   * @description Returns a count of how many stargazers there are on this object
   */
  stargazerCount: () => new Field("stargazerCount"),

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: (variables, select) =>
    new Field(
      "stargazers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(StargazerConnection))
    ),

  /**
     * @description Returns a list of all submodules in this repository parsed from the
.gitmodules file as of the default branch's HEAD commit.
     */

  submodules: (variables, select) =>
    new Field(
      "submodules",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(SubmoduleConnection))
    ),

  /**
   * @description Temporary authentication token for cloning this repository.
   */
  tempCloneToken: () => new Field("tempCloneToken"),

  /**
   * @description The repository from which this repository was generated, if any.
   */

  templateRepository: (select) =>
    new Field(
      "templateRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this repository
   */
  url: () => new Field("url"),

  /**
   * @description Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
   */
  usesCustomOpenGraphImage: () => new Field("usesCustomOpenGraphImage"),

  /**
   * @description Indicates whether the viewer has admin permissions on this repository.
   */
  viewerCanAdminister: () => new Field("viewerCanAdminister"),

  /**
   * @description Can the current viewer create new projects on this owner.
   */
  viewerCanCreateProjects: () => new Field("viewerCanCreateProjects"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Indicates whether the viewer can update the topics of this repository.
   */
  viewerCanUpdateTopics: () => new Field("viewerCanUpdateTopics"),

  /**
   * @description The last commit email for the viewer.
   */
  viewerDefaultCommitEmail: () => new Field("viewerDefaultCommitEmail"),

  /**
   * @description The last used merge method by the viewer or the default for the repository.
   */
  viewerDefaultMergeMethod: () => new Field("viewerDefaultMergeMethod"),

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */
  viewerHasStarred: () => new Field("viewerHasStarred"),

  /**
   * @description The users permission level on the repository. Will return null if authenticated as an GitHub App.
   */
  viewerPermission: () => new Field("viewerPermission"),

  /**
   * @description A list of emails this viewer can commit with.
   */
  viewerPossibleCommitEmails: () => new Field("viewerPossibleCommitEmails"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),

  /**
   * @description A list of vulnerability alerts that are on this repository.
   */

  vulnerabilityAlerts: (variables, select) =>
    new Field(
      "vulnerabilityAlerts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(RepositoryVulnerabilityAlertConnection))
    ),

  /**
   * @description A list of users watching the repository.
   */

  watchers: (variables, select) =>
    new Field(
      "watchers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserConnection))
    ),
};

export interface IRepositoryAuditEntryData {
  __typename: string;
  repository: IRepository;
  repositoryName: string;
  repositoryResourcePath: unknown;
  repositoryUrl: unknown;
}

interface RepositoryAuditEntryDataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  on: <
    T extends Array<Selection>,
    F extends
      | "OrgRestoreMemberMembershipRepositoryAuditEntryData"
      | "PrivateRepositoryForkingDisableAuditEntry"
      | "PrivateRepositoryForkingEnableAuditEntry"
      | "RepoAccessAuditEntry"
      | "RepoAddMemberAuditEntry"
      | "RepoAddTopicAuditEntry"
      | "RepoArchivedAuditEntry"
      | "RepoChangeMergeSettingAuditEntry"
      | "RepoConfigDisableAnonymousGitAccessAuditEntry"
      | "RepoConfigDisableCollaboratorsOnlyAuditEntry"
      | "RepoConfigDisableContributorsOnlyAuditEntry"
      | "RepoConfigDisableSockpuppetDisallowedAuditEntry"
      | "RepoConfigEnableAnonymousGitAccessAuditEntry"
      | "RepoConfigEnableCollaboratorsOnlyAuditEntry"
      | "RepoConfigEnableContributorsOnlyAuditEntry"
      | "RepoConfigEnableSockpuppetDisallowedAuditEntry"
      | "RepoConfigLockAnonymousGitAccessAuditEntry"
      | "RepoConfigUnlockAnonymousGitAccessAuditEntry"
      | "RepoCreateAuditEntry"
      | "RepoDestroyAuditEntry"
      | "RepoRemoveMemberAuditEntry"
      | "RepoRemoveTopicAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "OrgRestoreMemberMembershipRepositoryAuditEntryData"
        ? OrgRestoreMemberMembershipRepositoryAuditEntryDataSelector
        : F extends "PrivateRepositoryForkingDisableAuditEntry"
        ? PrivateRepositoryForkingDisableAuditEntrySelector
        : F extends "PrivateRepositoryForkingEnableAuditEntry"
        ? PrivateRepositoryForkingEnableAuditEntrySelector
        : F extends "RepoAccessAuditEntry"
        ? RepoAccessAuditEntrySelector
        : F extends "RepoAddMemberAuditEntry"
        ? RepoAddMemberAuditEntrySelector
        : F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoArchivedAuditEntry"
        ? RepoArchivedAuditEntrySelector
        : F extends "RepoChangeMergeSettingAuditEntry"
        ? RepoChangeMergeSettingAuditEntrySelector
        : F extends "RepoConfigDisableAnonymousGitAccessAuditEntry"
        ? RepoConfigDisableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigDisableCollaboratorsOnlyAuditEntry"
        ? RepoConfigDisableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableContributorsOnlyAuditEntry"
        ? RepoConfigDisableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigDisableSockpuppetDisallowedAuditEntry"
        ? RepoConfigDisableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigEnableAnonymousGitAccessAuditEntry"
        ? RepoConfigEnableAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigEnableCollaboratorsOnlyAuditEntry"
        ? RepoConfigEnableCollaboratorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableContributorsOnlyAuditEntry"
        ? RepoConfigEnableContributorsOnlyAuditEntrySelector
        : F extends "RepoConfigEnableSockpuppetDisallowedAuditEntry"
        ? RepoConfigEnableSockpuppetDisallowedAuditEntrySelector
        : F extends "RepoConfigLockAnonymousGitAccessAuditEntry"
        ? RepoConfigLockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoConfigUnlockAnonymousGitAccessAuditEntry"
        ? RepoConfigUnlockAnonymousGitAccessAuditEntrySelector
        : F extends "RepoCreateAuditEntry"
        ? RepoCreateAuditEntrySelector
        : F extends "RepoDestroyAuditEntry"
        ? RepoDestroyAuditEntrySelector
        : F extends "RepoRemoveMemberAuditEntry"
        ? RepoRemoveMemberAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RepositoryAuditEntryData: RepositoryAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  on: (type, select) => {
    switch (type) {
      case "OrgRestoreMemberMembershipRepositoryAuditEntryData": {
        return new InlineFragment(
          new NamedType(
            "OrgRestoreMemberMembershipRepositoryAuditEntryData"
          ) as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipRepositoryAuditEntryData as any)
          )
        );
      }

      case "PrivateRepositoryForkingDisableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingDisableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingDisableAuditEntry as any)
          )
        );
      }

      case "PrivateRepositoryForkingEnableAuditEntry": {
        return new InlineFragment(
          new NamedType("PrivateRepositoryForkingEnableAuditEntry") as any,
          new SelectionSet(
            select(PrivateRepositoryForkingEnableAuditEntry as any)
          )
        );
      }

      case "RepoAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAccessAuditEntry") as any,
          new SelectionSet(select(RepoAccessAuditEntry as any))
        );
      }

      case "RepoAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddMemberAuditEntry") as any,
          new SelectionSet(select(RepoAddMemberAuditEntry as any))
        );
      }

      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoArchivedAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoArchivedAuditEntry") as any,
          new SelectionSet(select(RepoArchivedAuditEntry as any))
        );
      }

      case "RepoChangeMergeSettingAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoChangeMergeSettingAuditEntry") as any,
          new SelectionSet(select(RepoChangeMergeSettingAuditEntry as any))
        );
      }

      case "RepoConfigDisableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigDisableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigDisableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigDisableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigDisableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigDisableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableCollaboratorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableCollaboratorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableCollaboratorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableContributorsOnlyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigEnableContributorsOnlyAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigEnableContributorsOnlyAuditEntry as any)
          )
        );
      }

      case "RepoConfigEnableSockpuppetDisallowedAuditEntry": {
        return new InlineFragment(
          new NamedType(
            "RepoConfigEnableSockpuppetDisallowedAuditEntry"
          ) as any,
          new SelectionSet(
            select(RepoConfigEnableSockpuppetDisallowedAuditEntry as any)
          )
        );
      }

      case "RepoConfigLockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigLockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigLockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoConfigUnlockAnonymousGitAccessAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoConfigUnlockAnonymousGitAccessAuditEntry") as any,
          new SelectionSet(
            select(RepoConfigUnlockAnonymousGitAccessAuditEntry as any)
          )
        );
      }

      case "RepoCreateAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoCreateAuditEntry") as any,
          new SelectionSet(select(RepoCreateAuditEntry as any))
        );
      }

      case "RepoDestroyAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoDestroyAuditEntry") as any,
          new SelectionSet(select(RepoDestroyAuditEntry as any))
        );
      }

      case "RepoRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveMemberAuditEntry") as any,
          new SelectionSet(select(RepoRemoveMemberAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IRepositoryCollaboratorConnection {
  edges: IRepositoryCollaboratorEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface RepositoryCollaboratorConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: RepositoryCollaboratorEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const RepositoryCollaboratorConnection: RepositoryCollaboratorConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryCollaboratorEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRepositoryCollaboratorEdge {
  cursor: string;
  node: IUser;
  permission: RepositoryPermission;
  permissionSources: IPermissionSource[];
}

interface RepositoryCollaboratorEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The permission the user has on the repository.
   */

  permission: () => Field<"permission">;

  /**
   * @description A list of sources for the user's access to the repository.
   */

  permissionSources: <T extends Array<Selection>>(
    select: (t: PermissionSourceSelector) => T
  ) => Field<"permissionSources", never, SelectionSet<T>>;
}

export const RepositoryCollaboratorEdge: RepositoryCollaboratorEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The permission the user has on the repository.
   */
  permission: () => new Field("permission"),

  /**
   * @description A list of sources for the user's access to the repository.
   */

  permissionSources: (select) =>
    new Field(
      "permissionSources",
      undefined as never,
      new SelectionSet(select(PermissionSource))
    ),
};

export interface IRepositoryConnection {
  edges: IRepositoryEdge[];
  nodes: IRepository[];
  pageInfo: IPageInfo;
  totalCount: number;
  totalDiskUsage: number;
}

interface RepositoryConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: RepositoryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;

  /**
   * @description The total size in kilobytes of all repositories in the connection.
   */

  totalDiskUsage: () => Field<"totalDiskUsage">;
}

export const RepositoryConnection: RepositoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),

  /**
   * @description The total size in kilobytes of all repositories in the connection.
   */
  totalDiskUsage: () => new Field("totalDiskUsage"),
};

export interface IRepositoryContactLink {
  about: string;
  name: string;
  url: unknown;
}

interface RepositoryContactLinkSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The contact link purpose.
   */

  about: () => Field<"about">;

  /**
   * @description The contact link name.
   */

  name: () => Field<"name">;

  /**
   * @description The contact link URL.
   */

  url: () => Field<"url">;
}

export const RepositoryContactLink: RepositoryContactLinkSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The contact link purpose.
   */
  about: () => new Field("about"),

  /**
   * @description The contact link name.
   */
  name: () => new Field("name"),

  /**
   * @description The contact link URL.
   */
  url: () => new Field("url"),
};

export interface IRepositoryEdge {
  cursor: string;
  node: IRepository;
}

interface RepositoryEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RepositoryEdge: RepositoryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Repository))),
};

export interface IRepositoryInfo {
  __typename: string;
  createdAt: unknown;
  description: string;
  descriptionHTML: unknown;
  forkCount: number;
  hasIssuesEnabled: boolean;
  hasProjectsEnabled: boolean;
  hasWikiEnabled: boolean;
  homepageUrl: unknown;
  isArchived: boolean;
  isFork: boolean;
  isInOrganization: boolean;
  isLocked: boolean;
  isMirror: boolean;
  isPrivate: boolean;
  isTemplate: boolean;
  licenseInfo: ILicense;
  lockReason: RepositoryLockReason;
  mirrorUrl: unknown;
  name: string;
  nameWithOwner: string;
  openGraphImageUrl: unknown;
  owner: IRepositoryOwner;
  pushedAt: unknown;
  resourcePath: unknown;
  shortDescriptionHTML: unknown;
  updatedAt: unknown;
  url: unknown;
  usesCustomOpenGraphImage: boolean;
}

interface RepositoryInfoSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The description of the repository.
   */

  description: () => Field<"description">;

  /**
   * @description The description of the repository rendered to HTML.
   */

  descriptionHTML: () => Field<"descriptionHTML">;

  /**
   * @description Returns how many forks there are of this repository in the whole network.
   */

  forkCount: () => Field<"forkCount">;

  /**
   * @description Indicates if the repository has issues feature enabled.
   */

  hasIssuesEnabled: () => Field<"hasIssuesEnabled">;

  /**
   * @description Indicates if the repository has the Projects feature enabled.
   */

  hasProjectsEnabled: () => Field<"hasProjectsEnabled">;

  /**
   * @description Indicates if the repository has wiki feature enabled.
   */

  hasWikiEnabled: () => Field<"hasWikiEnabled">;

  /**
   * @description The repository's URL.
   */

  homepageUrl: () => Field<"homepageUrl">;

  /**
   * @description Indicates if the repository is unmaintained.
   */

  isArchived: () => Field<"isArchived">;

  /**
   * @description Identifies if the repository is a fork.
   */

  isFork: () => Field<"isFork">;

  /**
   * @description Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
   */

  isInOrganization: () => Field<"isInOrganization">;

  /**
   * @description Indicates if the repository has been locked or not.
   */

  isLocked: () => Field<"isLocked">;

  /**
   * @description Identifies if the repository is a mirror.
   */

  isMirror: () => Field<"isMirror">;

  /**
   * @description Identifies if the repository is private.
   */

  isPrivate: () => Field<"isPrivate">;

  /**
   * @description Identifies if the repository is a template that can be used to generate new repositories.
   */

  isTemplate: () => Field<"isTemplate">;

  /**
   * @description The license associated with the repository
   */

  licenseInfo: <T extends Array<Selection>>(
    select: (t: LicenseSelector) => T
  ) => Field<"licenseInfo", never, SelectionSet<T>>;

  /**
   * @description The reason the repository has been locked.
   */

  lockReason: () => Field<"lockReason">;

  /**
   * @description The repository's original mirror URL.
   */

  mirrorUrl: () => Field<"mirrorUrl">;

  /**
   * @description The name of the repository.
   */

  name: () => Field<"name">;

  /**
   * @description The repository's name with owner.
   */

  nameWithOwner: () => Field<"nameWithOwner">;

  /**
   * @description The image used to represent this repository in Open Graph data.
   */

  openGraphImageUrl: () => Field<"openGraphImageUrl">;

  /**
   * @description The User owner of the repository.
   */

  owner: <T extends Array<Selection>>(
    select: (t: RepositoryOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;

  /**
   * @description Identifies when the repository was last pushed to.
   */

  pushedAt: () => Field<"pushedAt">;

  /**
   * @description The HTTP path for this repository
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description A description of the repository, rendered to HTML without any links in it.
   */

  shortDescriptionHTML: (variables: {
    limit: unknown;
  }) => Field<"shortDescriptionHTML", [/* @todo */]>;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this repository
   */

  url: () => Field<"url">;

  /**
   * @description Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
   */

  usesCustomOpenGraphImage: () => Field<"usesCustomOpenGraphImage">;

  on: <T extends Array<Selection>, F extends "Repository">(
    type: F,
    select: (t: RepositorySelector) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RepositoryInfo: RepositoryInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The description of the repository.
   */
  description: () => new Field("description"),

  /**
   * @description The description of the repository rendered to HTML.
   */
  descriptionHTML: () => new Field("descriptionHTML"),

  /**
   * @description Returns how many forks there are of this repository in the whole network.
   */
  forkCount: () => new Field("forkCount"),

  /**
   * @description Indicates if the repository has issues feature enabled.
   */
  hasIssuesEnabled: () => new Field("hasIssuesEnabled"),

  /**
   * @description Indicates if the repository has the Projects feature enabled.
   */
  hasProjectsEnabled: () => new Field("hasProjectsEnabled"),

  /**
   * @description Indicates if the repository has wiki feature enabled.
   */
  hasWikiEnabled: () => new Field("hasWikiEnabled"),

  /**
   * @description The repository's URL.
   */
  homepageUrl: () => new Field("homepageUrl"),

  /**
   * @description Indicates if the repository is unmaintained.
   */
  isArchived: () => new Field("isArchived"),

  /**
   * @description Identifies if the repository is a fork.
   */
  isFork: () => new Field("isFork"),

  /**
   * @description Indicates if a repository is either owned by an organization, or is a private fork of an organization repository.
   */
  isInOrganization: () => new Field("isInOrganization"),

  /**
   * @description Indicates if the repository has been locked or not.
   */
  isLocked: () => new Field("isLocked"),

  /**
   * @description Identifies if the repository is a mirror.
   */
  isMirror: () => new Field("isMirror"),

  /**
   * @description Identifies if the repository is private.
   */
  isPrivate: () => new Field("isPrivate"),

  /**
   * @description Identifies if the repository is a template that can be used to generate new repositories.
   */
  isTemplate: () => new Field("isTemplate"),

  /**
   * @description The license associated with the repository
   */

  licenseInfo: (select) =>
    new Field(
      "licenseInfo",
      undefined as never,
      new SelectionSet(select(License))
    ),

  /**
   * @description The reason the repository has been locked.
   */
  lockReason: () => new Field("lockReason"),

  /**
   * @description The repository's original mirror URL.
   */
  mirrorUrl: () => new Field("mirrorUrl"),

  /**
   * @description The name of the repository.
   */
  name: () => new Field("name"),

  /**
   * @description The repository's name with owner.
   */
  nameWithOwner: () => new Field("nameWithOwner"),

  /**
   * @description The image used to represent this repository in Open Graph data.
   */
  openGraphImageUrl: () => new Field("openGraphImageUrl"),

  /**
   * @description The User owner of the repository.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(RepositoryOwner))
    ),

  /**
   * @description Identifies when the repository was last pushed to.
   */
  pushedAt: () => new Field("pushedAt"),

  /**
   * @description The HTTP path for this repository
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description A description of the repository, rendered to HTML without any links in it.
   */
  shortDescriptionHTML: (variables) => new Field("shortDescriptionHTML"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this repository
   */
  url: () => new Field("url"),

  /**
   * @description Whether this repository has a custom image to use with Open Graph as opposed to being represented by the owner's avatar.
   */
  usesCustomOpenGraphImage: () => new Field("usesCustomOpenGraphImage"),

  on: (type, select) => {
    switch (type) {
      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IRepositoryInteractionAbility {
  expiresAt: unknown;
  limit: RepositoryInteractionLimit;
  origin: RepositoryInteractionLimitOrigin;
}

interface RepositoryInteractionAbilitySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The time the currently active limit expires.
   */

  expiresAt: () => Field<"expiresAt">;

  /**
   * @description The current limit that is enabled on this object.
   */

  limit: () => Field<"limit">;

  /**
   * @description The origin of the currently active interaction limit.
   */

  origin: () => Field<"origin">;
}

export const RepositoryInteractionAbility: RepositoryInteractionAbilitySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The time the currently active limit expires.
   */
  expiresAt: () => new Field("expiresAt"),

  /**
   * @description The current limit that is enabled on this object.
   */
  limit: () => new Field("limit"),

  /**
   * @description The origin of the currently active interaction limit.
   */
  origin: () => new Field("origin"),
};

export interface IRepositoryInvitation extends INode {
  __typename: "RepositoryInvitation";
  email: string;
  invitee: IUser;
  inviter: IUser;
  permalink: unknown;
  permission: RepositoryPermission;
  repository: IRepositoryInfo;
}

interface RepositoryInvitationSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The email address that received the invitation.
   */

  email: () => Field<"email">;

  id: () => Field<"id">;

  /**
   * @description The user who received the invitation.
   */

  invitee: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"invitee", never, SelectionSet<T>>;

  /**
   * @description The user who created the invitation.
   */

  inviter: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"inviter", never, SelectionSet<T>>;

  /**
   * @description The permalink for this repository invitation.
   */

  permalink: () => Field<"permalink">;

  /**
   * @description The permission granted on this repository by this invitation.
   */

  permission: () => Field<"permission">;

  /**
   * @description The Repository the user is invited to.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositoryInfoSelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isRepositoryInvitation = (
  object: Record<string, any>
): object is Partial<IRepositoryInvitation> => {
  return object.__typename === "RepositoryInvitation";
};

export const RepositoryInvitation: RepositoryInvitationSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The email address that received the invitation.
   */
  email: () => new Field("email"),
  id: () => new Field("id"),

  /**
   * @description The user who received the invitation.
   */

  invitee: (select) =>
    new Field("invitee", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The user who created the invitation.
   */

  inviter: (select) =>
    new Field("inviter", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The permalink for this repository invitation.
   */
  permalink: () => new Field("permalink"),

  /**
   * @description The permission granted on this repository by this invitation.
   */
  permission: () => new Field("permission"),

  /**
   * @description The Repository the user is invited to.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(RepositoryInfo))
    ),
};

export interface IRepositoryInvitationConnection {
  edges: IRepositoryInvitationEdge[];
  nodes: IRepositoryInvitation[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface RepositoryInvitationConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: RepositoryInvitationEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: RepositoryInvitationSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const RepositoryInvitationConnection: RepositoryInvitationConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryInvitationEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(RepositoryInvitation))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRepositoryInvitationEdge {
  cursor: string;
  node: IRepositoryInvitation;
}

interface RepositoryInvitationEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: RepositoryInvitationSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RepositoryInvitationEdge: RepositoryInvitationEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(RepositoryInvitation))
    ),
};

export interface IRepositoryNode {
  __typename: string;
  repository: IRepository;
}

interface RepositoryNodeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The repository associated with this node.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "CommitCommentThread"
      | "Issue"
      | "IssueComment"
      | "PullRequest"
      | "PullRequestCommitCommentThread"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "RepositoryVulnerabilityAlert"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "CommitCommentThread"
        ? CommitCommentThreadSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestCommitCommentThread"
        ? PullRequestCommitCommentThreadSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "RepositoryVulnerabilityAlert"
        ? RepositoryVulnerabilityAlertSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RepositoryNode: RepositoryNodeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The repository associated with this node.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "CommitCommentThread": {
        return new InlineFragment(
          new NamedType("CommitCommentThread") as any,
          new SelectionSet(select(CommitCommentThread as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestCommitCommentThread": {
        return new InlineFragment(
          new NamedType("PullRequestCommitCommentThread") as any,
          new SelectionSet(select(PullRequestCommitCommentThread as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "RepositoryVulnerabilityAlert": {
        return new InlineFragment(
          new NamedType("RepositoryVulnerabilityAlert") as any,
          new SelectionSet(select(RepositoryVulnerabilityAlert as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IRepositoryOwner {
  __typename: string;
  avatarUrl: unknown;
  id: string;
  login: string;
  repositories: IRepositoryConnection;
  repository: IRepository;
  resourcePath: unknown;
  url: unknown;
}

interface RepositoryOwnerSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A URL pointing to the owner's public avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  id: () => Field<"id">;

  /**
   * @description The username used to login.
   */

  login: () => Field<"login">;

  /**
   * @description A list of repositories that the user owns.
   */

  repositories: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isFork?: Variable<"isFork"> | boolean;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isFork", Variable<"isFork"> | boolean>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find Repository.
   */

  repository: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: RepositorySelector) => T
  ) => Field<
    "repository",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP URL for the owner.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for the owner.
   */

  url: () => Field<"url">;

  on: <T extends Array<Selection>, F extends "Organization" | "User">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const RepositoryOwner: RepositoryOwnerSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A URL pointing to the owner's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),
  id: () => new Field("id"),

  /**
   * @description The username used to login.
   */
  login: () => new Field("login"),

  /**
   * @description A list of repositories that the user owns.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isFork", variables.isFork),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description Find Repository.
   */

  repository: (variables, select) =>
    new Field(
      "repository",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP URL for the owner.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for the owner.
   */
  url: () => new Field("url"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IRepositoryTopic extends INode, IUniformResourceLocatable {
  __typename: "RepositoryTopic";
  topic: ITopic;
}

interface RepositoryTopicSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description The HTTP path for this repository-topic.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The topic.
   */

  topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;

  /**
   * @description The HTTP URL for this repository-topic.
   */

  url: () => Field<"url">;
}

export const isRepositoryTopic = (
  object: Record<string, any>
): object is Partial<IRepositoryTopic> => {
  return object.__typename === "RepositoryTopic";
};

export const RepositoryTopic: RepositoryTopicSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description The HTTP path for this repository-topic.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The topic.
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),

  /**
   * @description The HTTP URL for this repository-topic.
   */
  url: () => new Field("url"),
};

export interface IRepositoryTopicConnection {
  edges: IRepositoryTopicEdge[];
  nodes: IRepositoryTopic[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface RepositoryTopicConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: RepositoryTopicEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: RepositoryTopicSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const RepositoryTopicConnection: RepositoryTopicConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryTopicEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(RepositoryTopic))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRepositoryTopicEdge {
  cursor: string;
  node: IRepositoryTopic;
}

interface RepositoryTopicEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: RepositoryTopicSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RepositoryTopicEdge: RepositoryTopicEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(RepositoryTopic))
    ),
};

export interface IRepositoryVisibilityChangeDisableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  __typename: "RepositoryVisibilityChangeDisableAuditEntry";
}

interface RepositoryVisibilityChangeDisableAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  enterpriseUrl: () => Field<"enterpriseUrl">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepositoryVisibilityChangeDisableAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepositoryVisibilityChangeDisableAuditEntry> => {
  return object.__typename === "RepositoryVisibilityChangeDisableAuditEntry";
};

export const RepositoryVisibilityChangeDisableAuditEntry: RepositoryVisibilityChangeDisableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepositoryVisibilityChangeEnableAuditEntry
  extends IAuditEntry,
    IEnterpriseAuditEntryData,
    INode,
    IOrganizationAuditEntryData {
  __typename: "RepositoryVisibilityChangeEnableAuditEntry";
}

interface RepositoryVisibilityChangeEnableAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The HTTP path for this enterprise.
   */

  enterpriseResourcePath: () => Field<"enterpriseResourcePath">;

  /**
   * @description The slug of the enterprise.
   */

  enterpriseSlug: () => Field<"enterpriseSlug">;

  /**
   * @description The HTTP URL for this enterprise.
   */

  enterpriseUrl: () => Field<"enterpriseUrl">;

  id: () => Field<"id">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isRepositoryVisibilityChangeEnableAuditEntry = (
  object: Record<string, any>
): object is Partial<IRepositoryVisibilityChangeEnableAuditEntry> => {
  return object.__typename === "RepositoryVisibilityChangeEnableAuditEntry";
};

export const RepositoryVisibilityChangeEnableAuditEntry: RepositoryVisibilityChangeEnableAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The HTTP path for this enterprise.
   */
  enterpriseResourcePath: () => new Field("enterpriseResourcePath"),

  /**
   * @description The slug of the enterprise.
   */
  enterpriseSlug: () => new Field("enterpriseSlug"),

  /**
   * @description The HTTP URL for this enterprise.
   */
  enterpriseUrl: () => new Field("enterpriseUrl"),
  id: () => new Field("id"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface IRepositoryVulnerabilityAlert extends INode, IRepositoryNode {
  __typename: "RepositoryVulnerabilityAlert";
  createdAt: unknown;
  dismissReason: string;
  dismissedAt: unknown;
  dismisser: IUser;
  securityAdvisory: ISecurityAdvisory;
  securityVulnerability: ISecurityVulnerability;
  vulnerableManifestFilename: string;
  vulnerableManifestPath: string;
  vulnerableRequirements: string;
}

interface RepositoryVulnerabilityAlertSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description When was the alert created?
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The reason the alert was dismissed
   */

  dismissReason: () => Field<"dismissReason">;

  /**
   * @description When was the alert dimissed?
   */

  dismissedAt: () => Field<"dismissedAt">;

  /**
   * @description The user who dismissed the alert
   */

  dismisser: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"dismisser", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description The associated repository
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The associated security advisory
   */

  securityAdvisory: <T extends Array<Selection>>(
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<"securityAdvisory", never, SelectionSet<T>>;

  /**
   * @description The associated security vulnerablity
   */

  securityVulnerability: <T extends Array<Selection>>(
    select: (t: SecurityVulnerabilitySelector) => T
  ) => Field<"securityVulnerability", never, SelectionSet<T>>;

  /**
   * @description The vulnerable manifest filename
   */

  vulnerableManifestFilename: () => Field<"vulnerableManifestFilename">;

  /**
   * @description The vulnerable manifest path
   */

  vulnerableManifestPath: () => Field<"vulnerableManifestPath">;

  /**
   * @description The vulnerable requirements
   */

  vulnerableRequirements: () => Field<"vulnerableRequirements">;
}

export const isRepositoryVulnerabilityAlert = (
  object: Record<string, any>
): object is Partial<IRepositoryVulnerabilityAlert> => {
  return object.__typename === "RepositoryVulnerabilityAlert";
};

export const RepositoryVulnerabilityAlert: RepositoryVulnerabilityAlertSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description When was the alert created?
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The reason the alert was dismissed
   */
  dismissReason: () => new Field("dismissReason"),

  /**
   * @description When was the alert dimissed?
   */
  dismissedAt: () => new Field("dismissedAt"),

  /**
   * @description The user who dismissed the alert
   */

  dismisser: (select) =>
    new Field("dismisser", undefined as never, new SelectionSet(select(User))),

  id: () => new Field("id"),

  /**
   * @description The associated repository
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The associated security advisory
   */

  securityAdvisory: (select) =>
    new Field(
      "securityAdvisory",
      undefined as never,
      new SelectionSet(select(SecurityAdvisory))
    ),

  /**
   * @description The associated security vulnerablity
   */

  securityVulnerability: (select) =>
    new Field(
      "securityVulnerability",
      undefined as never,
      new SelectionSet(select(SecurityVulnerability))
    ),

  /**
   * @description The vulnerable manifest filename
   */
  vulnerableManifestFilename: () => new Field("vulnerableManifestFilename"),

  /**
   * @description The vulnerable manifest path
   */
  vulnerableManifestPath: () => new Field("vulnerableManifestPath"),

  /**
   * @description The vulnerable requirements
   */
  vulnerableRequirements: () => new Field("vulnerableRequirements"),
};

export interface IRepositoryVulnerabilityAlertConnection {
  edges: IRepositoryVulnerabilityAlertEdge[];
  nodes: IRepositoryVulnerabilityAlert[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface RepositoryVulnerabilityAlertConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: RepositoryVulnerabilityAlertEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: RepositoryVulnerabilityAlertSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const RepositoryVulnerabilityAlertConnection: RepositoryVulnerabilityAlertConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(RepositoryVulnerabilityAlertEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(RepositoryVulnerabilityAlert))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IRepositoryVulnerabilityAlertEdge {
  cursor: string;
  node: IRepositoryVulnerabilityAlert;
}

interface RepositoryVulnerabilityAlertEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: RepositoryVulnerabilityAlertSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const RepositoryVulnerabilityAlertEdge: RepositoryVulnerabilityAlertEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(RepositoryVulnerabilityAlert))
    ),
};

export interface IRequestReviewsPayload {
  actor: IActor;
  clientMutationId: string;
  pullRequest: IPullRequest;
  requestedReviewersEdge: IUserEdge;
}

interface RequestReviewsPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The pull request that is getting requests.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The edge from the pull request to the requested reviewers.
   */

  requestedReviewersEdge: <T extends Array<Selection>>(
    select: (t: UserEdgeSelector) => T
  ) => Field<"requestedReviewersEdge", never, SelectionSet<T>>;
}

export const RequestReviewsPayload: RequestReviewsPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The pull request that is getting requests.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The edge from the pull request to the requested reviewers.
   */

  requestedReviewersEdge: (select) =>
    new Field(
      "requestedReviewersEdge",
      undefined as never,
      new SelectionSet(select(UserEdge))
    ),
};

export interface IRerequestCheckSuitePayload {
  checkSuite: ICheckSuite;
  clientMutationId: string;
}

interface RerequestCheckSuitePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The requested check suite.
   */

  checkSuite: <T extends Array<Selection>>(
    select: (t: CheckSuiteSelector) => T
  ) => Field<"checkSuite", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const RerequestCheckSuitePayload: RerequestCheckSuitePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The requested check suite.
   */

  checkSuite: (select) =>
    new Field(
      "checkSuite",
      undefined as never,
      new SelectionSet(select(CheckSuite))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IResolveReviewThreadPayload {
  clientMutationId: string;
  thread: IPullRequestReviewThread;
}

interface ResolveReviewThreadPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The thread to resolve.
   */

  thread: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"thread", never, SelectionSet<T>>;
}

export const ResolveReviewThreadPayload: ResolveReviewThreadPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The thread to resolve.
   */

  thread: (select) =>
    new Field(
      "thread",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),
};

export interface IRestrictedContribution extends IContribution {
  __typename: "RestrictedContribution";
}

interface RestrictedContributionSelector {
  __typename: () => Field<"__typename">;

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */

  isRestricted: () => Field<"isRestricted">;

  /**
   * @description When this contribution was made.
   */

  occurredAt: () => Field<"occurredAt">;

  /**
   * @description The HTTP path for this contribution.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The HTTP URL for this contribution.
   */

  url: () => Field<"url">;

  /**
   * @description The user who made this contribution.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isRestrictedContribution = (
  object: Record<string, any>
): object is Partial<IRestrictedContribution> => {
  return object.__typename === "RestrictedContribution";
};

export const RestrictedContribution: RestrictedContributionSelector = {
  __typename: () => new Field("__typename"),

  /**
     * @description Whether this contribution is associated with a record you do not have access to. For
example, your own 'first issue' contribution may have been made on a repository you can no
longer access.
     */
  isRestricted: () => new Field("isRestricted"),

  /**
   * @description When this contribution was made.
   */
  occurredAt: () => new Field("occurredAt"),

  /**
   * @description The HTTP path for this contribution.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The HTTP URL for this contribution.
   */
  url: () => new Field("url"),

  /**
   * @description The user who made this contribution.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IReviewDismissalAllowance extends INode {
  __typename: "ReviewDismissalAllowance";
  actor: IReviewDismissalAllowanceActor;
  branchProtectionRule: IBranchProtectionRule;
}

interface ReviewDismissalAllowanceSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor that can dismiss.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ReviewDismissalAllowanceActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the branch protection rule associated with the allowed user or team.
   */

  branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  id: () => Field<"id">;
}

export const isReviewDismissalAllowance = (
  object: Record<string, any>
): object is Partial<IReviewDismissalAllowance> => {
  return object.__typename === "ReviewDismissalAllowance";
};

export const ReviewDismissalAllowance: ReviewDismissalAllowanceSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor that can dismiss.
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(ReviewDismissalAllowanceActor))
    ),

  /**
   * @description Identifies the branch protection rule associated with the allowed user or team.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  id: () => new Field("id"),
};

export interface IReviewDismissalAllowanceConnection {
  edges: IReviewDismissalAllowanceEdge[];
  nodes: IReviewDismissalAllowance[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface ReviewDismissalAllowanceConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ReviewDismissalAllowanceEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: ReviewDismissalAllowanceSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const ReviewDismissalAllowanceConnection: ReviewDismissalAllowanceConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReviewDismissalAllowanceEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ReviewDismissalAllowance))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReviewDismissalAllowanceEdge {
  cursor: string;
  node: IReviewDismissalAllowance;
}

interface ReviewDismissalAllowanceEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: ReviewDismissalAllowanceSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReviewDismissalAllowanceEdge: ReviewDismissalAllowanceEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ReviewDismissalAllowance))
    ),
};

export interface IReviewDismissedEvent
  extends INode,
    IUniformResourceLocatable {
  __typename: "ReviewDismissedEvent";
  actor: IActor;
  createdAt: unknown;
  databaseId: number;
  dismissalMessage: string;
  dismissalMessageHTML: string;
  previousReviewState: PullRequestReviewState;
  pullRequest: IPullRequest;
  pullRequestCommit: IPullRequestCommit;
  review: IPullRequestReview;
}

interface ReviewDismissedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description Identifies the optional message associated with the 'review_dismissed' event.
   */

  dismissalMessage: () => Field<"dismissalMessage">;

  /**
   * @description Identifies the optional message associated with the event, rendered to HTML.
   */

  dismissalMessageHTML: () => Field<"dismissalMessageHTML">;

  id: () => Field<"id">;

  /**
   * @description Identifies the previous state of the review with the 'review_dismissed' event.
   */

  previousReviewState: () => Field<"previousReviewState">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the commit which caused the review to become stale.
   */

  pullRequestCommit: <T extends Array<Selection>>(
    select: (t: PullRequestCommitSelector) => T
  ) => Field<"pullRequestCommit", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for this review dismissed event.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the review associated with the 'review_dismissed' event.
   */

  review: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"review", never, SelectionSet<T>>;

  /**
   * @description The HTTP URL for this review dismissed event.
   */

  url: () => Field<"url">;
}

export const isReviewDismissedEvent = (
  object: Record<string, any>
): object is Partial<IReviewDismissedEvent> => {
  return object.__typename === "ReviewDismissedEvent";
};

export const ReviewDismissedEvent: ReviewDismissedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description Identifies the optional message associated with the 'review_dismissed' event.
   */
  dismissalMessage: () => new Field("dismissalMessage"),

  /**
   * @description Identifies the optional message associated with the event, rendered to HTML.
   */
  dismissalMessageHTML: () => new Field("dismissalMessageHTML"),
  id: () => new Field("id"),

  /**
   * @description Identifies the previous state of the review with the 'review_dismissed' event.
   */
  previousReviewState: () => new Field("previousReviewState"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the commit which caused the review to become stale.
   */

  pullRequestCommit: (select) =>
    new Field(
      "pullRequestCommit",
      undefined as never,
      new SelectionSet(select(PullRequestCommit))
    ),

  /**
   * @description The HTTP path for this review dismissed event.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the review associated with the 'review_dismissed' event.
   */

  review: (select) =>
    new Field(
      "review",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),

  /**
   * @description The HTTP URL for this review dismissed event.
   */
  url: () => new Field("url"),
};

export interface IReviewRequest extends INode {
  __typename: "ReviewRequest";
  asCodeOwner: boolean;
  databaseId: number;
  pullRequest: IPullRequest;
  requestedReviewer: IRequestedReviewer;
}

interface ReviewRequestSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Whether this request was created for a code owner
   */

  asCodeOwner: () => Field<"asCodeOwner">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description Identifies the pull request associated with this review request.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description The reviewer that is requested.
   */

  requestedReviewer: <T extends Array<Selection>>(
    select: (t: RequestedReviewerSelector) => T
  ) => Field<"requestedReviewer", never, SelectionSet<T>>;
}

export const isReviewRequest = (
  object: Record<string, any>
): object is Partial<IReviewRequest> => {
  return object.__typename === "ReviewRequest";
};

export const ReviewRequest: ReviewRequestSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Whether this request was created for a code owner
   */
  asCodeOwner: () => new Field("asCodeOwner"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description Identifies the pull request associated with this review request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description The reviewer that is requested.
   */

  requestedReviewer: (select) =>
    new Field(
      "requestedReviewer",
      undefined as never,
      new SelectionSet(select(RequestedReviewer))
    ),
};

export interface IReviewRequestConnection {
  edges: IReviewRequestEdge[];
  nodes: IReviewRequest[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface ReviewRequestConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: ReviewRequestEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: ReviewRequestSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const ReviewRequestConnection: ReviewRequestConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(ReviewRequestEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(ReviewRequest))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IReviewRequestEdge {
  cursor: string;
  node: IReviewRequest;
}

interface ReviewRequestEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: ReviewRequestSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const ReviewRequestEdge: ReviewRequestEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(ReviewRequest))
    ),
};

export interface IReviewRequestRemovedEvent extends INode {
  __typename: "ReviewRequestRemovedEvent";
  actor: IActor;
  createdAt: unknown;
  pullRequest: IPullRequest;
  requestedReviewer: IRequestedReviewer;
}

interface ReviewRequestRemovedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the reviewer whose review request was removed.
   */

  requestedReviewer: <T extends Array<Selection>>(
    select: (t: RequestedReviewerSelector) => T
  ) => Field<"requestedReviewer", never, SelectionSet<T>>;
}

export const isReviewRequestRemovedEvent = (
  object: Record<string, any>
): object is Partial<IReviewRequestRemovedEvent> => {
  return object.__typename === "ReviewRequestRemovedEvent";
};

export const ReviewRequestRemovedEvent: ReviewRequestRemovedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the reviewer whose review request was removed.
   */

  requestedReviewer: (select) =>
    new Field(
      "requestedReviewer",
      undefined as never,
      new SelectionSet(select(RequestedReviewer))
    ),
};

export interface IReviewRequestedEvent extends INode {
  __typename: "ReviewRequestedEvent";
  actor: IActor;
  createdAt: unknown;
  pullRequest: IPullRequest;
  requestedReviewer: IRequestedReviewer;
}

interface ReviewRequestedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;

  /**
   * @description Identifies the reviewer whose review was requested.
   */

  requestedReviewer: <T extends Array<Selection>>(
    select: (t: RequestedReviewerSelector) => T
  ) => Field<"requestedReviewer", never, SelectionSet<T>>;
}

export const isReviewRequestedEvent = (
  object: Record<string, any>
): object is Partial<IReviewRequestedEvent> => {
  return object.__typename === "ReviewRequestedEvent";
};

export const ReviewRequestedEvent: ReviewRequestedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description PullRequest referenced by event.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),

  /**
   * @description Identifies the reviewer whose review was requested.
   */

  requestedReviewer: (select) =>
    new Field(
      "requestedReviewer",
      undefined as never,
      new SelectionSet(select(RequestedReviewer))
    ),
};

export interface IReviewStatusHovercardContext extends IHovercardContext {
  __typename: "ReviewStatusHovercardContext";
  reviewDecision: PullRequestReviewDecision;
}

interface ReviewStatusHovercardContextSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  octicon: () => Field<"octicon">;

  /**
   * @description The current status of the pull request with respect to code review.
   */

  reviewDecision: () => Field<"reviewDecision">;
}

export const isReviewStatusHovercardContext = (
  object: Record<string, any>
): object is Partial<IReviewStatusHovercardContext> => {
  return object.__typename === "ReviewStatusHovercardContext";
};

export const ReviewStatusHovercardContext: ReviewStatusHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  /**
   * @description The current status of the pull request with respect to code review.
   */
  reviewDecision: () => new Field("reviewDecision"),
};

export interface ISavedReply extends INode {
  __typename: "SavedReply";
  body: string;
  bodyHTML: unknown;
  databaseId: number;
  title: string;
  user: IActor;
}

interface SavedReplySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The body of the saved reply.
   */

  body: () => Field<"body">;

  /**
   * @description The saved reply body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  id: () => Field<"id">;

  /**
   * @description The title of the saved reply.
   */

  title: () => Field<"title">;

  /**
   * @description The user that saved this reply.
   */

  user: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isSavedReply = (
  object: Record<string, any>
): object is Partial<ISavedReply> => {
  return object.__typename === "SavedReply";
};

export const SavedReply: SavedReplySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The body of the saved reply.
   */
  body: () => new Field("body"),

  /**
   * @description The saved reply body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),
  id: () => new Field("id"),

  /**
   * @description The title of the saved reply.
   */
  title: () => new Field("title"),

  /**
   * @description The user that saved this reply.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(Actor))),
};

export interface ISavedReplyConnection {
  edges: ISavedReplyEdge[];
  nodes: ISavedReply[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface SavedReplyConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: SavedReplyEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: SavedReplySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const SavedReplyConnection: SavedReplyConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SavedReplyEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SavedReply))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISavedReplyEdge {
  cursor: string;
  node: ISavedReply;
}

interface SavedReplyEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: SavedReplySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SavedReplyEdge: SavedReplyEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(SavedReply))),
};

export interface ISearchResultItemConnection {
  codeCount: number;
  edges: ISearchResultItemEdge[];
  issueCount: number;
  nodes: ISearchResultItem[];
  pageInfo: IPageInfo;
  repositoryCount: number;
  userCount: number;
  wikiCount: number;
}

interface SearchResultItemConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The number of pieces of code that matched the search query.
   */

  codeCount: () => Field<"codeCount">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: SearchResultItemEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description The number of issues that matched the search query.
   */

  issueCount: () => Field<"issueCount">;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: SearchResultItemSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description The number of repositories that matched the search query.
   */

  repositoryCount: () => Field<"repositoryCount">;

  /**
   * @description The number of users that matched the search query.
   */

  userCount: () => Field<"userCount">;

  /**
   * @description The number of wiki pages that matched the search query.
   */

  wikiCount: () => Field<"wikiCount">;
}

export const SearchResultItemConnection: SearchResultItemConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The number of pieces of code that matched the search query.
   */
  codeCount: () => new Field("codeCount"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SearchResultItemEdge))
    ),

  /**
   * @description The number of issues that matched the search query.
   */
  issueCount: () => new Field("issueCount"),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SearchResultItem))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description The number of repositories that matched the search query.
   */
  repositoryCount: () => new Field("repositoryCount"),

  /**
   * @description The number of users that matched the search query.
   */
  userCount: () => new Field("userCount"),

  /**
   * @description The number of wiki pages that matched the search query.
   */
  wikiCount: () => new Field("wikiCount"),
};

export interface ISearchResultItemEdge {
  cursor: string;
  node: ISearchResultItem;
  textMatches: ITextMatch[];
}

interface SearchResultItemEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: SearchResultItemSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description Text matches on the result found.
   */

  textMatches: <T extends Array<Selection>>(
    select: (t: TextMatchSelector) => T
  ) => Field<"textMatches", never, SelectionSet<T>>;
}

export const SearchResultItemEdge: SearchResultItemEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(SearchResultItem))
    ),

  /**
   * @description Text matches on the result found.
   */

  textMatches: (select) =>
    new Field(
      "textMatches",
      undefined as never,
      new SelectionSet(select(TextMatch))
    ),
};

export interface ISecurityAdvisory extends INode {
  __typename: "SecurityAdvisory";
  databaseId: number;
  description: string;
  ghsaId: string;
  identifiers: ISecurityAdvisoryIdentifier[];
  origin: string;
  permalink: unknown;
  publishedAt: unknown;
  references: ISecurityAdvisoryReference[];
  severity: SecurityAdvisorySeverity;
  summary: string;
  updatedAt: unknown;
  vulnerabilities: ISecurityVulnerabilityConnection;
  withdrawnAt: unknown;
}

interface SecurityAdvisorySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description This is a long plaintext description of the advisory
   */

  description: () => Field<"description">;

  /**
   * @description The GitHub Security Advisory ID
   */

  ghsaId: () => Field<"ghsaId">;

  id: () => Field<"id">;

  /**
   * @description A list of identifiers for this advisory
   */

  identifiers: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryIdentifierSelector) => T
  ) => Field<"identifiers", never, SelectionSet<T>>;

  /**
   * @description The organization that originated the advisory
   */

  origin: () => Field<"origin">;

  /**
   * @description The permalink for the advisory
   */

  permalink: () => Field<"permalink">;

  /**
   * @description When the advisory was published
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of references for this advisory
   */

  references: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryReferenceSelector) => T
  ) => Field<"references", never, SelectionSet<T>>;

  /**
   * @description The severity of the advisory
   */

  severity: () => Field<"severity">;

  /**
   * @description A short plaintext summary of the advisory
   */

  summary: () => Field<"summary">;

  /**
   * @description When the advisory was last updated
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description Vulnerabilities associated with this Advisory
   */

  vulnerabilities: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      ecosystem?: Variable<"ecosystem"> | SecurityAdvisoryEcosystem;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SecurityVulnerabilityOrder;
      package?: Variable<"package"> | string;
      severities?: Variable<"severities"> | SecurityAdvisorySeverity;
    },
    select: (t: SecurityVulnerabilityConnectionSelector) => T
  ) => Field<
    "vulnerabilities",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"ecosystem", Variable<"ecosystem"> | SecurityAdvisoryEcosystem>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SecurityVulnerabilityOrder>,
      Argument<"package", Variable<"package"> | string>,
      Argument<"severities", Variable<"severities"> | SecurityAdvisorySeverity>
    ],
    SelectionSet<T>
  >;

  /**
   * @description When the advisory was withdrawn, if it has been withdrawn
   */

  withdrawnAt: () => Field<"withdrawnAt">;
}

export const isSecurityAdvisory = (
  object: Record<string, any>
): object is Partial<ISecurityAdvisory> => {
  return object.__typename === "SecurityAdvisory";
};

export const SecurityAdvisory: SecurityAdvisorySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description This is a long plaintext description of the advisory
   */
  description: () => new Field("description"),

  /**
   * @description The GitHub Security Advisory ID
   */
  ghsaId: () => new Field("ghsaId"),
  id: () => new Field("id"),

  /**
   * @description A list of identifiers for this advisory
   */

  identifiers: (select) =>
    new Field(
      "identifiers",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryIdentifier))
    ),

  /**
   * @description The organization that originated the advisory
   */
  origin: () => new Field("origin"),

  /**
   * @description The permalink for the advisory
   */
  permalink: () => new Field("permalink"),

  /**
   * @description When the advisory was published
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of references for this advisory
   */

  references: (select) =>
    new Field(
      "references",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryReference))
    ),

  /**
   * @description The severity of the advisory
   */
  severity: () => new Field("severity"),

  /**
   * @description A short plaintext summary of the advisory
   */
  summary: () => new Field("summary"),

  /**
   * @description When the advisory was last updated
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description Vulnerabilities associated with this Advisory
   */

  vulnerabilities: (variables, select) =>
    new Field(
      "vulnerabilities",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument(
          "ecosystem",
          variables.ecosystem,
          SecurityAdvisoryEcosystem
        ),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("package", variables.package),
        new Argument(
          "severities",
          variables.severities,
          SecurityAdvisorySeverity
        ),
      ],
      new SelectionSet(select(SecurityVulnerabilityConnection))
    ),

  /**
   * @description When the advisory was withdrawn, if it has been withdrawn
   */
  withdrawnAt: () => new Field("withdrawnAt"),
};

export interface ISecurityAdvisoryConnection {
  edges: ISecurityAdvisoryEdge[];
  nodes: ISecurityAdvisory[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface SecurityAdvisoryConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const SecurityAdvisoryConnection: SecurityAdvisoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SecurityAdvisory))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISecurityAdvisoryEdge {
  cursor: string;
  node: ISecurityAdvisory;
}

interface SecurityAdvisoryEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SecurityAdvisoryEdge: SecurityAdvisoryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(SecurityAdvisory))
    ),
};

export interface ISecurityAdvisoryIdentifier {
  type: string;
  value: string;
}

interface SecurityAdvisoryIdentifierSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The identifier type, e.g. GHSA, CVE
   */

  type: () => Field<"type">;

  /**
   * @description The identifier
   */

  value: () => Field<"value">;
}

export const SecurityAdvisoryIdentifier: SecurityAdvisoryIdentifierSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The identifier type, e.g. GHSA, CVE
   */
  type: () => new Field("type"),

  /**
   * @description The identifier
   */
  value: () => new Field("value"),
};

export interface ISecurityAdvisoryPackage {
  ecosystem: SecurityAdvisoryEcosystem;
  name: string;
}

interface SecurityAdvisoryPackageSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The ecosystem the package belongs to, e.g. RUBYGEMS, NPM
   */

  ecosystem: () => Field<"ecosystem">;

  /**
   * @description The package name
   */

  name: () => Field<"name">;
}

export const SecurityAdvisoryPackage: SecurityAdvisoryPackageSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The ecosystem the package belongs to, e.g. RUBYGEMS, NPM
   */
  ecosystem: () => new Field("ecosystem"),

  /**
   * @description The package name
   */
  name: () => new Field("name"),
};

export interface ISecurityAdvisoryPackageVersion {
  identifier: string;
}

interface SecurityAdvisoryPackageVersionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The package name or version
   */

  identifier: () => Field<"identifier">;
}

export const SecurityAdvisoryPackageVersion: SecurityAdvisoryPackageVersionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The package name or version
   */
  identifier: () => new Field("identifier"),
};

export interface ISecurityAdvisoryReference {
  url: unknown;
}

interface SecurityAdvisoryReferenceSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A publicly accessible reference
   */

  url: () => Field<"url">;
}

export const SecurityAdvisoryReference: SecurityAdvisoryReferenceSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A publicly accessible reference
   */
  url: () => new Field("url"),
};

export interface ISecurityVulnerability {
  advisory: ISecurityAdvisory;
  firstPatchedVersion: ISecurityAdvisoryPackageVersion;
  package: ISecurityAdvisoryPackage;
  severity: SecurityAdvisorySeverity;
  updatedAt: unknown;
  vulnerableVersionRange: string;
}

interface SecurityVulnerabilitySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The Advisory associated with this Vulnerability
   */

  advisory: <T extends Array<Selection>>(
    select: (t: SecurityAdvisorySelector) => T
  ) => Field<"advisory", never, SelectionSet<T>>;

  /**
   * @description The first version containing a fix for the vulnerability
   */

  firstPatchedVersion: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryPackageVersionSelector) => T
  ) => Field<"firstPatchedVersion", never, SelectionSet<T>>;

  /**
   * @description A description of the vulnerable package
   */

  package: <T extends Array<Selection>>(
    select: (t: SecurityAdvisoryPackageSelector) => T
  ) => Field<"package", never, SelectionSet<T>>;

  /**
   * @description The severity of the vulnerability within this package
   */

  severity: () => Field<"severity">;

  /**
   * @description When the vulnerability was last updated
   */

  updatedAt: () => Field<"updatedAt">;

  /**
     * @description A string that describes the vulnerable package versions.
This string follows a basic syntax with a few forms.
+ `= 0.2.0` denotes a single vulnerable version.
+ `<= 1.0.8` denotes a version range up to and including the specified version
+ `< 0.1.11` denotes a version range up to, but excluding, the specified version
+ `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
+ `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
     */

  vulnerableVersionRange: () => Field<"vulnerableVersionRange">;
}

export const SecurityVulnerability: SecurityVulnerabilitySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The Advisory associated with this Vulnerability
   */

  advisory: (select) =>
    new Field(
      "advisory",
      undefined as never,
      new SelectionSet(select(SecurityAdvisory))
    ),

  /**
   * @description The first version containing a fix for the vulnerability
   */

  firstPatchedVersion: (select) =>
    new Field(
      "firstPatchedVersion",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryPackageVersion))
    ),

  /**
   * @description A description of the vulnerable package
   */

  package: (select) =>
    new Field(
      "package",
      undefined as never,
      new SelectionSet(select(SecurityAdvisoryPackage))
    ),

  /**
   * @description The severity of the vulnerability within this package
   */
  severity: () => new Field("severity"),

  /**
   * @description When the vulnerability was last updated
   */
  updatedAt: () => new Field("updatedAt"),

  /**
     * @description A string that describes the vulnerable package versions.
This string follows a basic syntax with a few forms.
+ `= 0.2.0` denotes a single vulnerable version.
+ `<= 1.0.8` denotes a version range up to and including the specified version
+ `< 0.1.11` denotes a version range up to, but excluding, the specified version
+ `>= 4.3.0, < 4.3.5` denotes a version range with a known minimum and maximum version.
+ `>= 0.0.1` denotes a version range with a known minimum, but no known maximum
     */
  vulnerableVersionRange: () => new Field("vulnerableVersionRange"),
};

export interface ISecurityVulnerabilityConnection {
  edges: ISecurityVulnerabilityEdge[];
  nodes: ISecurityVulnerability[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface SecurityVulnerabilityConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: SecurityVulnerabilityEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: SecurityVulnerabilitySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const SecurityVulnerabilityConnection: SecurityVulnerabilityConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SecurityVulnerabilityEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SecurityVulnerability))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISecurityVulnerabilityEdge {
  cursor: string;
  node: ISecurityVulnerability;
}

interface SecurityVulnerabilityEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: SecurityVulnerabilitySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SecurityVulnerabilityEdge: SecurityVulnerabilityEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(SecurityVulnerability))
    ),
};

export interface ISetEnterpriseIdentityProviderPayload {
  clientMutationId: string;
  identityProvider: IEnterpriseIdentityProvider;
}

interface SetEnterpriseIdentityProviderPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The identity provider for the enterprise.
   */

  identityProvider: <T extends Array<Selection>>(
    select: (t: EnterpriseIdentityProviderSelector) => T
  ) => Field<"identityProvider", never, SelectionSet<T>>;
}

export const SetEnterpriseIdentityProviderPayload: SetEnterpriseIdentityProviderPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The identity provider for the enterprise.
   */

  identityProvider: (select) =>
    new Field(
      "identityProvider",
      undefined as never,
      new SelectionSet(select(EnterpriseIdentityProvider))
    ),
};

export interface ISetOrganizationInteractionLimitPayload {
  clientMutationId: string;
  organization: IOrganization;
}

interface SetOrganizationInteractionLimitPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The organization that the interaction limit was set for.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;
}

export const SetOrganizationInteractionLimitPayload: SetOrganizationInteractionLimitPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The organization that the interaction limit was set for.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),
};

export interface ISetRepositoryInteractionLimitPayload {
  clientMutationId: string;
  repository: IRepository;
}

interface SetRepositoryInteractionLimitPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository that the interaction limit was set for.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const SetRepositoryInteractionLimitPayload: SetRepositoryInteractionLimitPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository that the interaction limit was set for.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ISetUserInteractionLimitPayload {
  clientMutationId: string;
  user: IUser;
}

interface SetUserInteractionLimitPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The user that the interaction limit was set for.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const SetUserInteractionLimitPayload: SetUserInteractionLimitPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The user that the interaction limit was set for.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface ISmimeSignature extends IGitSignature {
  __typename: "SmimeSignature";
}

interface SmimeSignatureSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Email used to sign this object.
   */

  email: () => Field<"email">;

  /**
   * @description True if the signature is valid and verified by GitHub.
   */

  isValid: () => Field<"isValid">;

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */

  payload: () => Field<"payload">;

  /**
   * @description ASCII-armored signature header from object.
   */

  signature: () => Field<"signature">;

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"signer", never, SelectionSet<T>>;

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */

  state: () => Field<"state">;

  /**
   * @description True if the signature was made with GitHub's signing key.
   */

  wasSignedByGitHub: () => Field<"wasSignedByGitHub">;
}

export const isSmimeSignature = (
  object: Record<string, any>
): object is Partial<ISmimeSignature> => {
  return object.__typename === "SmimeSignature";
};

export const SmimeSignature: SmimeSignatureSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Email used to sign this object.
   */
  email: () => new Field("email"),

  /**
   * @description True if the signature is valid and verified by GitHub.
   */
  isValid: () => new Field("isValid"),

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */
  payload: () => new Field("payload"),

  /**
   * @description ASCII-armored signature header from object.
   */
  signature: () => new Field("signature"),

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: (select) =>
    new Field("signer", undefined as never, new SelectionSet(select(User))),

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */
  state: () => new Field("state"),

  /**
   * @description True if the signature was made with GitHub's signing key.
   */
  wasSignedByGitHub: () => new Field("wasSignedByGitHub"),
};

export interface ISponsorable {
  __typename: string;
  hasSponsorsListing: boolean;
  isSponsoringViewer: boolean;
  sponsorsListing: ISponsorsListing;
  sponsorshipsAsMaintainer: ISponsorshipConnection;
  sponsorshipsAsSponsor: ISponsorshipConnection;
  viewerCanSponsor: boolean;
  viewerIsSponsoring: boolean;
}

interface SponsorableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */

  hasSponsorsListing: () => Field<"hasSponsorsListing">;

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */

  isSponsoringViewer: () => Field<"isSponsoringViewer">;

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  sponsorsListing: <T extends Array<Selection>>(
    select: (t: SponsorsListingSelector) => T
  ) => Field<"sponsorsListing", never, SelectionSet<T>>;

  /**
   * @description This object's sponsorships as the maintainer.
   */

  sponsorshipsAsMaintainer: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      includePrivate?: Variable<"includePrivate"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsMaintainer",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"includePrivate", Variable<"includePrivate"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description This object's sponsorships as the sponsor.
   */

  sponsorshipsAsSponsor: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsSponsor",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */

  viewerCanSponsor: () => Field<"viewerCanSponsor">;

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */

  viewerIsSponsoring: () => Field<"viewerIsSponsoring">;

  on: <T extends Array<Selection>, F extends "Organization" | "User">(
    type: F,
    select: (
      t: F extends "Organization"
        ? OrganizationSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Sponsorable: SponsorableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */
  hasSponsorsListing: () => new Field("hasSponsorsListing"),

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */
  isSponsoringViewer: () => new Field("isSponsoringViewer"),

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  sponsorsListing: (select) =>
    new Field(
      "sponsorsListing",
      undefined as never,
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description This object's sponsorships as the maintainer.
   */

  sponsorshipsAsMaintainer: (variables, select) =>
    new Field(
      "sponsorshipsAsMaintainer",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("includePrivate", variables.includePrivate),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description This object's sponsorships as the sponsor.
   */

  sponsorshipsAsSponsor: (variables, select) =>
    new Field(
      "sponsorshipsAsSponsor",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */
  viewerCanSponsor: () => new Field("viewerCanSponsor"),

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */
  viewerIsSponsoring: () => new Field("viewerIsSponsoring"),

  on: (type, select) => {
    switch (type) {
      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface ISponsorsListing extends INode {
  __typename: "SponsorsListing";
  createdAt: unknown;
  fullDescription: string;
  fullDescriptionHTML: unknown;
  name: string;
  shortDescription: string;
  slug: string;
  tiers: ISponsorsTierConnection;
}

interface SponsorsListingSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The full description of the listing.
   */

  fullDescription: () => Field<"fullDescription">;

  /**
   * @description The full description of the listing rendered to HTML.
   */

  fullDescriptionHTML: () => Field<"fullDescriptionHTML">;

  id: () => Field<"id">;

  /**
   * @description The listing's full name.
   */

  name: () => Field<"name">;

  /**
   * @description The short description of the listing.
   */

  shortDescription: () => Field<"shortDescription">;

  /**
   * @description The short name of the listing.
   */

  slug: () => Field<"slug">;

  /**
   * @description The published tiers for this GitHub Sponsors listing.
   */

  tiers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorsTierOrder;
    },
    select: (t: SponsorsTierConnectionSelector) => T
  ) => Field<
    "tiers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorsTierOrder>
    ],
    SelectionSet<T>
  >;
}

export const isSponsorsListing = (
  object: Record<string, any>
): object is Partial<ISponsorsListing> => {
  return object.__typename === "SponsorsListing";
};

export const SponsorsListing: SponsorsListingSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The full description of the listing.
   */
  fullDescription: () => new Field("fullDescription"),

  /**
   * @description The full description of the listing rendered to HTML.
   */
  fullDescriptionHTML: () => new Field("fullDescriptionHTML"),
  id: () => new Field("id"),

  /**
   * @description The listing's full name.
   */
  name: () => new Field("name"),

  /**
   * @description The short description of the listing.
   */
  shortDescription: () => new Field("shortDescription"),

  /**
   * @description The short name of the listing.
   */
  slug: () => new Field("slug"),

  /**
   * @description The published tiers for this GitHub Sponsors listing.
   */

  tiers: (variables, select) =>
    new Field(
      "tiers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorsTierConnection))
    ),
};

export interface ISponsorsTier extends INode {
  __typename: "SponsorsTier";
  adminInfo: ISponsorsTierAdminInfo;
  createdAt: unknown;
  description: string;
  descriptionHTML: unknown;
  monthlyPriceInCents: number;
  monthlyPriceInDollars: number;
  name: string;
  sponsorsListing: ISponsorsListing;
  updatedAt: unknown;
}

interface SponsorsTierSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description SponsorsTier information only visible to users that can administer the associated Sponsors listing.
   */

  adminInfo: <T extends Array<Selection>>(
    select: (t: SponsorsTierAdminInfoSelector) => T
  ) => Field<"adminInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The description of the tier.
   */

  description: () => Field<"description">;

  /**
   * @description The tier description rendered to HTML
   */

  descriptionHTML: () => Field<"descriptionHTML">;

  id: () => Field<"id">;

  /**
   * @description How much this tier costs per month in cents.
   */

  monthlyPriceInCents: () => Field<"monthlyPriceInCents">;

  /**
   * @description How much this tier costs per month in dollars.
   */

  monthlyPriceInDollars: () => Field<"monthlyPriceInDollars">;

  /**
   * @description The name of the tier.
   */

  name: () => Field<"name">;

  /**
   * @description The sponsors listing that this tier belongs to.
   */

  sponsorsListing: <T extends Array<Selection>>(
    select: (t: SponsorsListingSelector) => T
  ) => Field<"sponsorsListing", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;
}

export const isSponsorsTier = (
  object: Record<string, any>
): object is Partial<ISponsorsTier> => {
  return object.__typename === "SponsorsTier";
};

export const SponsorsTier: SponsorsTierSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description SponsorsTier information only visible to users that can administer the associated Sponsors listing.
   */

  adminInfo: (select) =>
    new Field(
      "adminInfo",
      undefined as never,
      new SelectionSet(select(SponsorsTierAdminInfo))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The description of the tier.
   */
  description: () => new Field("description"),

  /**
   * @description The tier description rendered to HTML
   */
  descriptionHTML: () => new Field("descriptionHTML"),
  id: () => new Field("id"),

  /**
   * @description How much this tier costs per month in cents.
   */
  monthlyPriceInCents: () => new Field("monthlyPriceInCents"),

  /**
   * @description How much this tier costs per month in dollars.
   */
  monthlyPriceInDollars: () => new Field("monthlyPriceInDollars"),

  /**
   * @description The name of the tier.
   */
  name: () => new Field("name"),

  /**
   * @description The sponsors listing that this tier belongs to.
   */

  sponsorsListing: (select) =>
    new Field(
      "sponsorsListing",
      undefined as never,
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface ISponsorsTierAdminInfo {
  sponsorships: ISponsorshipConnection;
}

interface SponsorsTierAdminInfoSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The sponsorships associated with this tier.
   */

  sponsorships: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      includePrivate?: Variable<"includePrivate"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorships",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"includePrivate", Variable<"includePrivate"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;
}

export const SponsorsTierAdminInfo: SponsorsTierAdminInfoSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The sponsorships associated with this tier.
   */

  sponsorships: (variables, select) =>
    new Field(
      "sponsorships",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("includePrivate", variables.includePrivate),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),
};

export interface ISponsorsTierConnection {
  edges: ISponsorsTierEdge[];
  nodes: ISponsorsTier[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface SponsorsTierConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: SponsorsTierEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: SponsorsTierSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const SponsorsTierConnection: SponsorsTierConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SponsorsTierEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(SponsorsTier))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISponsorsTierEdge {
  cursor: string;
  node: ISponsorsTier;
}

interface SponsorsTierEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: SponsorsTierSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SponsorsTierEdge: SponsorsTierEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(SponsorsTier))
    ),
};

export interface ISponsorship extends INode {
  __typename: "Sponsorship";
  createdAt: unknown;
  maintainer: IUser;
  privacyLevel: SponsorshipPrivacy;
  sponsor: IUser;
  sponsorEntity: ISponsor;
  sponsorable: ISponsorable;
  tier: ISponsorsTier;
}

interface SponsorshipSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */

  maintainer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"maintainer", never, SelectionSet<T>>;

  /**
   * @description The privacy level for this sponsorship.
   */

  privacyLevel: () => Field<"privacyLevel">;

  /**
   * @description The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */

  sponsor: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"sponsor", never, SelectionSet<T>>;

  /**
   * @description The user or organization that is sponsoring, if you have permission to view them.
   */

  sponsorEntity: <T extends Array<Selection>>(
    select: (t: SponsorSelector) => T
  ) => Field<"sponsorEntity", never, SelectionSet<T>>;

  /**
   * @description The entity that is being sponsored
   */

  sponsorable: <T extends Array<Selection>>(
    select: (t: SponsorableSelector) => T
  ) => Field<"sponsorable", never, SelectionSet<T>>;

  /**
   * @description The associated sponsorship tier
   */

  tier: <T extends Array<Selection>>(
    select: (t: SponsorsTierSelector) => T
  ) => Field<"tier", never, SelectionSet<T>>;
}

export const isSponsorship = (
  object: Record<string, any>
): object is Partial<ISponsorship> => {
  return object.__typename === "Sponsorship";
};

export const Sponsorship: SponsorshipSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The entity that is being sponsored
   * @deprecated `Sponsorship.maintainer` will be removed. Use `Sponsorship.sponsorable` instead. Removal on 2020-04-01 UTC.
   */

  maintainer: (select) =>
    new Field("maintainer", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The privacy level for this sponsorship.
   */
  privacyLevel: () => new Field("privacyLevel"),

  /**
   * @description The user that is sponsoring. Returns null if the sponsorship is private or if sponsor is not a user.
   * @deprecated `Sponsorship.sponsor` will be removed. Use `Sponsorship.sponsorEntity` instead. Removal on 2020-10-01 UTC.
   */

  sponsor: (select) =>
    new Field("sponsor", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The user or organization that is sponsoring, if you have permission to view them.
   */

  sponsorEntity: (select) =>
    new Field(
      "sponsorEntity",
      undefined as never,
      new SelectionSet(select(Sponsor))
    ),

  /**
   * @description The entity that is being sponsored
   */

  sponsorable: (select) =>
    new Field(
      "sponsorable",
      undefined as never,
      new SelectionSet(select(Sponsorable))
    ),

  /**
   * @description The associated sponsorship tier
   */

  tier: (select) =>
    new Field(
      "tier",
      undefined as never,
      new SelectionSet(select(SponsorsTier))
    ),
};

export interface ISponsorshipConnection {
  edges: ISponsorshipEdge[];
  nodes: ISponsorship[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface SponsorshipConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: SponsorshipEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: SponsorshipSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const SponsorshipConnection: SponsorshipConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SponsorshipEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Sponsorship))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISponsorshipEdge {
  cursor: string;
  node: ISponsorship;
}

interface SponsorshipEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: SponsorshipSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SponsorshipEdge: SponsorshipEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(Sponsorship))
    ),
};

export interface IStargazerConnection {
  edges: IStargazerEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface StargazerConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: StargazerEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const StargazerConnection: StargazerConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(StargazerEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IStargazerEdge {
  cursor: string;
  node: IUser;
  starredAt: unknown;
}

interface StargazerEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description Identifies when the item was starred.
   */

  starredAt: () => Field<"starredAt">;
}

export const StargazerEdge: StargazerEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Identifies when the item was starred.
   */
  starredAt: () => new Field("starredAt"),
};

export interface IStarrable {
  __typename: string;
  id: string;
  stargazerCount: number;
  stargazers: IStargazerConnection;
  viewerHasStarred: boolean;
}

interface StarrableSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description Returns a count of how many stargazers there are on this object
   */

  stargazerCount: () => Field<"stargazerCount">;

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
    },
    select: (t: StargazerConnectionSelector) => T
  ) => Field<
    "stargazers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */

  viewerHasStarred: () => Field<"viewerHasStarred">;

  on: <T extends Array<Selection>, F extends "Gist" | "Repository" | "Topic">(
    type: F,
    select: (
      t: F extends "Gist"
        ? GistSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "Topic"
        ? TopicSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Starrable: StarrableSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Returns a count of how many stargazers there are on this object
   */
  stargazerCount: () => new Field("stargazerCount"),

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: (variables, select) =>
    new Field(
      "stargazers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(StargazerConnection))
    ),

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */
  viewerHasStarred: () => new Field("viewerHasStarred"),

  on: (type, select) => {
    switch (type) {
      case "Gist": {
        return new InlineFragment(
          new NamedType("Gist") as any,
          new SelectionSet(select(Gist as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "Topic": {
        return new InlineFragment(
          new NamedType("Topic") as any,
          new SelectionSet(select(Topic as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IStarredRepositoryConnection {
  edges: IStarredRepositoryEdge[];
  isOverLimit: boolean;
  nodes: IRepository[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface StarredRepositoryConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: StarredRepositoryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description Is the list of stars for this user truncated? This is true for users that have many stars.
   */

  isOverLimit: () => Field<"isOverLimit">;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const StarredRepositoryConnection: StarredRepositoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(StarredRepositoryEdge))
    ),

  /**
   * @description Is the list of stars for this user truncated? This is true for users that have many stars.
   */
  isOverLimit: () => new Field("isOverLimit"),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IStarredRepositoryEdge {
  cursor: string;
  node: IRepository;
  starredAt: unknown;
}

interface StarredRepositoryEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  node: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description Identifies when the item was starred.
   */

  starredAt: () => Field<"starredAt">;
}

export const StarredRepositoryEdge: StarredRepositoryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Repository))),

  /**
   * @description Identifies when the item was starred.
   */
  starredAt: () => new Field("starredAt"),
};

export interface IStatus extends INode {
  __typename: "Status";
  combinedContexts: IStatusCheckRollupContextConnection;
  commit: ICommit;
  context: IStatusContext;
  contexts: IStatusContext[];
  state: StatusState;
}

interface StatusSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of status contexts and check runs for this commit.
   */

  combinedContexts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: StatusCheckRollupContextConnectionSelector) => T
  ) => Field<
    "combinedContexts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The commit this status is attached to.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description Looks up an individual status context by context name.
   */

  context: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: StatusContextSelector) => T
  ) => Field<
    "context",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The individual status contexts for this commit.
   */

  contexts: <T extends Array<Selection>>(
    select: (t: StatusContextSelector) => T
  ) => Field<"contexts", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description The combined commit status.
   */

  state: () => Field<"state">;
}

export const isStatus = (
  object: Record<string, any>
): object is Partial<IStatus> => {
  return object.__typename === "Status";
};

export const Status: StatusSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of status contexts and check runs for this commit.
   */

  combinedContexts: (variables, select) =>
    new Field(
      "combinedContexts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(StatusCheckRollupContextConnection))
    ),

  /**
   * @description The commit this status is attached to.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description Looks up an individual status context by context name.
   */

  context: (variables, select) =>
    new Field(
      "context",
      [new Argument("name", variables.name)],
      new SelectionSet(select(StatusContext))
    ),

  /**
   * @description The individual status contexts for this commit.
   */

  contexts: (select) =>
    new Field(
      "contexts",
      undefined as never,
      new SelectionSet(select(StatusContext))
    ),

  id: () => new Field("id"),

  /**
   * @description The combined commit status.
   */
  state: () => new Field("state"),
};

export interface IStatusCheckRollup extends INode {
  __typename: "StatusCheckRollup";
  commit: ICommit;
  contexts: IStatusCheckRollupContextConnection;
  state: StatusState;
}

interface StatusCheckRollupSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The commit the status and check runs are attached to.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description A list of status contexts and check runs for this commit.
   */

  contexts: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: StatusCheckRollupContextConnectionSelector) => T
  ) => Field<
    "contexts",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  id: () => Field<"id">;

  /**
   * @description The combined status for the commit.
   */

  state: () => Field<"state">;
}

export const isStatusCheckRollup = (
  object: Record<string, any>
): object is Partial<IStatusCheckRollup> => {
  return object.__typename === "StatusCheckRollup";
};

export const StatusCheckRollup: StatusCheckRollupSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The commit the status and check runs are attached to.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description A list of status contexts and check runs for this commit.
   */

  contexts: (variables, select) =>
    new Field(
      "contexts",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(StatusCheckRollupContextConnection))
    ),

  id: () => new Field("id"),

  /**
   * @description The combined status for the commit.
   */
  state: () => new Field("state"),
};

export interface IStatusCheckRollupContextConnection {
  edges: IStatusCheckRollupContextEdge[];
  nodes: IStatusCheckRollupContext[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface StatusCheckRollupContextConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: StatusCheckRollupContextEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: StatusCheckRollupContextSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const StatusCheckRollupContextConnection: StatusCheckRollupContextConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(StatusCheckRollupContextEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(StatusCheckRollupContext))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IStatusCheckRollupContextEdge {
  cursor: string;
  node: IStatusCheckRollupContext;
}

interface StatusCheckRollupContextEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: StatusCheckRollupContextSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const StatusCheckRollupContextEdge: StatusCheckRollupContextEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(StatusCheckRollupContext))
    ),
};

export interface IStatusContext extends INode {
  __typename: "StatusContext";
  avatarUrl: unknown;
  commit: ICommit;
  context: string;
  createdAt: unknown;
  creator: IActor;
  description: string;
  state: StatusState;
  targetUrl: unknown;
}

interface StatusContextSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The avatar of the OAuth application or the user that created the status
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description This commit this status context is attached to.
   */

  commit: <T extends Array<Selection>>(
    select: (t: CommitSelector) => T
  ) => Field<"commit", never, SelectionSet<T>>;

  /**
   * @description The name of this status context.
   */

  context: () => Field<"context">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The actor who created this status context.
   */

  creator: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"creator", never, SelectionSet<T>>;

  /**
   * @description The description for this status context.
   */

  description: () => Field<"description">;

  id: () => Field<"id">;

  /**
   * @description The state of this status context.
   */

  state: () => Field<"state">;

  /**
   * @description The URL for this status context.
   */

  targetUrl: () => Field<"targetUrl">;
}

export const isStatusContext = (
  object: Record<string, any>
): object is Partial<IStatusContext> => {
  return object.__typename === "StatusContext";
};

export const StatusContext: StatusContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The avatar of the OAuth application or the user that created the status
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description This commit this status context is attached to.
   */

  commit: (select) =>
    new Field("commit", undefined as never, new SelectionSet(select(Commit))),

  /**
   * @description The name of this status context.
   */
  context: () => new Field("context"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The actor who created this status context.
   */

  creator: (select) =>
    new Field("creator", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The description for this status context.
   */
  description: () => new Field("description"),
  id: () => new Field("id"),

  /**
   * @description The state of this status context.
   */
  state: () => new Field("state"),

  /**
   * @description The URL for this status context.
   */
  targetUrl: () => new Field("targetUrl"),
};

export interface ISubmitPullRequestReviewPayload {
  clientMutationId: string;
  pullRequestReview: IPullRequestReview;
}

interface SubmitPullRequestReviewPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The submitted pull request review.
   */

  pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const SubmitPullRequestReviewPayload: SubmitPullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The submitted pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface ISubmodule {
  branch: string;
  gitUrl: unknown;
  name: string;
  path: string;
  subprojectCommitOid: unknown;
}

interface SubmoduleSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The branch of the upstream submodule for tracking updates
   */

  branch: () => Field<"branch">;

  /**
   * @description The git URL of the submodule repository
   */

  gitUrl: () => Field<"gitUrl">;

  /**
   * @description The name of the submodule in .gitmodules
   */

  name: () => Field<"name">;

  /**
   * @description The path in the superproject that this submodule is located in
   */

  path: () => Field<"path">;

  /**
   * @description The commit revision of the subproject repository being tracked by the submodule
   */

  subprojectCommitOid: () => Field<"subprojectCommitOid">;
}

export const Submodule: SubmoduleSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The branch of the upstream submodule for tracking updates
   */
  branch: () => new Field("branch"),

  /**
   * @description The git URL of the submodule repository
   */
  gitUrl: () => new Field("gitUrl"),

  /**
   * @description The name of the submodule in .gitmodules
   */
  name: () => new Field("name"),

  /**
   * @description The path in the superproject that this submodule is located in
   */
  path: () => new Field("path"),

  /**
   * @description The commit revision of the subproject repository being tracked by the submodule
   */
  subprojectCommitOid: () => new Field("subprojectCommitOid"),
};

export interface ISubmoduleConnection {
  edges: ISubmoduleEdge[];
  nodes: ISubmodule[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface SubmoduleConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: SubmoduleEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: SubmoduleSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const SubmoduleConnection: SubmoduleConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(SubmoduleEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Submodule))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ISubmoduleEdge {
  cursor: string;
  node: ISubmodule;
}

interface SubmoduleEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: SubmoduleSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const SubmoduleEdge: SubmoduleEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Submodule))),
};

export interface ISubscribable {
  __typename: string;
  id: string;
  viewerCanSubscribe: boolean;
  viewerSubscription: SubscriptionState;
}

interface SubscribableSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  viewerSubscription: () => Field<"viewerSubscription">;

  on: <
    T extends Array<Selection>,
    F extends
      | "Commit"
      | "Issue"
      | "PullRequest"
      | "Repository"
      | "Team"
      | "TeamDiscussion"
  >(
    type: F,
    select: (
      t: F extends "Commit"
        ? CommitSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "Team"
        ? TeamSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Subscribable: SubscribableSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),

  on: (type, select) => {
    switch (type) {
      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "Team": {
        return new InlineFragment(
          new NamedType("Team") as any,
          new SelectionSet(select(Team as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface ISubscribedEvent extends INode {
  __typename: "SubscribedEvent";
  actor: IActor;
  createdAt: unknown;
  subscribable: ISubscribable;
}

interface SubscribedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Object referenced by event.
   */

  subscribable: <T extends Array<Selection>>(
    select: (t: SubscribableSelector) => T
  ) => Field<"subscribable", never, SelectionSet<T>>;
}

export const isSubscribedEvent = (
  object: Record<string, any>
): object is Partial<ISubscribedEvent> => {
  return object.__typename === "SubscribedEvent";
};

export const SubscribedEvent: SubscribedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Object referenced by event.
   */

  subscribable: (select) =>
    new Field(
      "subscribable",
      undefined as never,
      new SelectionSet(select(Subscribable))
    ),
};

export interface ISuggestedReviewer {
  isAuthor: boolean;
  isCommenter: boolean;
  reviewer: IUser;
}

interface SuggestedReviewerSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Is this suggestion based on past commits?
   */

  isAuthor: () => Field<"isAuthor">;

  /**
   * @description Is this suggestion based on past review comments?
   */

  isCommenter: () => Field<"isCommenter">;

  /**
   * @description Identifies the user suggested to review the pull request.
   */

  reviewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"reviewer", never, SelectionSet<T>>;
}

export const SuggestedReviewer: SuggestedReviewerSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Is this suggestion based on past commits?
   */
  isAuthor: () => new Field("isAuthor"),

  /**
   * @description Is this suggestion based on past review comments?
   */
  isCommenter: () => new Field("isCommenter"),

  /**
   * @description Identifies the user suggested to review the pull request.
   */

  reviewer: (select) =>
    new Field("reviewer", undefined as never, new SelectionSet(select(User))),
};

export interface ITag extends IGitObject, INode {
  __typename: "Tag";
  message: string;
  name: string;
  tagger: IGitActor;
  target: IGitObject;
}

interface TagSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description The HTTP path for this Git object
   */

  commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  commitUrl: () => Field<"commitUrl">;

  id: () => Field<"id">;

  /**
   * @description The Git tag message.
   */

  message: () => Field<"message">;

  /**
   * @description The Git tag name.
   */

  name: () => Field<"name">;

  /**
   * @description The Git object ID
   */

  oid: () => Field<"oid">;

  /**
   * @description The Repository the Git object belongs to
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description Details about the tag author.
   */

  tagger: <T extends Array<Selection>>(
    select: (t: GitActorSelector) => T
  ) => Field<"tagger", never, SelectionSet<T>>;

  /**
   * @description The Git object the tag points to.
   */

  target: <T extends Array<Selection>>(
    select: (t: GitObjectSelector) => T
  ) => Field<"target", never, SelectionSet<T>>;
}

export const isTag = (object: Record<string, any>): object is Partial<ITag> => {
  return object.__typename === "Tag";
};

export const Tag: TagSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),
  id: () => new Field("id"),

  /**
   * @description The Git tag message.
   */
  message: () => new Field("message"),

  /**
   * @description The Git tag name.
   */
  name: () => new Field("name"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The Repository the Git object belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Details about the tag author.
   */

  tagger: (select) =>
    new Field("tagger", undefined as never, new SelectionSet(select(GitActor))),

  /**
   * @description The Git object the tag points to.
   */

  target: (select) =>
    new Field(
      "target",
      undefined as never,
      new SelectionSet(select(GitObject))
    ),
};

export interface ITeam extends IMemberStatusable, INode, ISubscribable {
  __typename: "Team";
  ancestors: ITeamConnection;
  avatarUrl: unknown;
  childTeams: ITeamConnection;
  combinedSlug: string;
  createdAt: unknown;
  databaseId: number;
  description: string;
  discussion: ITeamDiscussion;
  discussions: ITeamDiscussionConnection;
  discussionsResourcePath: unknown;
  discussionsUrl: unknown;
  editTeamResourcePath: unknown;
  editTeamUrl: unknown;
  invitations: IOrganizationInvitationConnection;
  members: ITeamMemberConnection;
  membersResourcePath: unknown;
  membersUrl: unknown;
  name: string;
  newTeamResourcePath: unknown;
  newTeamUrl: unknown;
  organization: IOrganization;
  parentTeam: ITeam;
  privacy: TeamPrivacy;
  repositories: ITeamRepositoryConnection;
  repositoriesResourcePath: unknown;
  repositoriesUrl: unknown;
  resourcePath: unknown;
  slug: string;
  teamsResourcePath: unknown;
  teamsUrl: unknown;
  updatedAt: unknown;
  url: unknown;
  viewerCanAdminister: boolean;
}

interface TeamSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of teams that are ancestors of this team.
   */

  ancestors: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "ancestors",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A URL pointing to the team's avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description List of child teams belonging to this team
   */

  childTeams: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      immediateOnly?: Variable<"immediateOnly"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | TeamOrder;
      userLogins?: Variable<"userLogins"> | string;
    },
    select: (t: TeamConnectionSelector) => T
  ) => Field<
    "childTeams",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"immediateOnly", Variable<"immediateOnly"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | TeamOrder>,
      Argument<"userLogins", Variable<"userLogins"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The slug corresponding to the organization and team.
   */

  combinedSlug: () => Field<"combinedSlug">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The description of the team.
   */

  description: () => Field<"description">;

  /**
   * @description Find a team discussion by its number.
   */

  discussion: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: TeamDiscussionSelector) => T
  ) => Field<
    "discussion",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of team discussions.
   */

  discussions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isPinned?: Variable<"isPinned"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | TeamDiscussionOrder;
    },
    select: (t: TeamDiscussionConnectionSelector) => T
  ) => Field<
    "discussions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isPinned", Variable<"isPinned"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | TeamDiscussionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for team discussions
   */

  discussionsResourcePath: () => Field<"discussionsResourcePath">;

  /**
   * @description The HTTP URL for team discussions
   */

  discussionsUrl: () => Field<"discussionsUrl">;

  /**
   * @description The HTTP path for editing this team
   */

  editTeamResourcePath: () => Field<"editTeamResourcePath">;

  /**
   * @description The HTTP URL for editing this team
   */

  editTeamUrl: () => Field<"editTeamUrl">;

  id: () => Field<"id">;

  /**
   * @description A list of pending invitations for users to this team
   */

  invitations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: OrganizationInvitationConnectionSelector) => T
  ) => Field<
    "invitations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  memberStatuses: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | UserStatusOrder;
    },
    select: (t: UserStatusConnectionSelector) => T
  ) => Field<
    "memberStatuses",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | UserStatusOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users who are members of this team.
   */

  members: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      membership?: Variable<"membership"> | TeamMembershipType;
      orderBy?: Variable<"orderBy"> | TeamMemberOrder;
      query?: Variable<"query"> | string;
      role?: Variable<"role"> | TeamMemberRole;
    },
    select: (t: TeamMemberConnectionSelector) => T
  ) => Field<
    "members",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"membership", Variable<"membership"> | TeamMembershipType>,
      Argument<"orderBy", Variable<"orderBy"> | TeamMemberOrder>,
      Argument<"query", Variable<"query"> | string>,
      Argument<"role", Variable<"role"> | TeamMemberRole>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for the team' members
   */

  membersResourcePath: () => Field<"membersResourcePath">;

  /**
   * @description The HTTP URL for the team' members
   */

  membersUrl: () => Field<"membersUrl">;

  /**
   * @description The name of the team.
   */

  name: () => Field<"name">;

  /**
   * @description The HTTP path creating a new team
   */

  newTeamResourcePath: () => Field<"newTeamResourcePath">;

  /**
   * @description The HTTP URL creating a new team
   */

  newTeamUrl: () => Field<"newTeamUrl">;

  /**
   * @description The organization that owns this team.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The parent team of the team.
   */

  parentTeam: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"parentTeam", never, SelectionSet<T>>;

  /**
   * @description The level of privacy the team has.
   */

  privacy: () => Field<"privacy">;

  /**
   * @description A list of repositories this team has access to.
   */

  repositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | TeamRepositoryOrder;
      query?: Variable<"query"> | string;
    },
    select: (t: TeamRepositoryConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | TeamRepositoryOrder>,
      Argument<"query", Variable<"query"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this team's repositories
   */

  repositoriesResourcePath: () => Field<"repositoriesResourcePath">;

  /**
   * @description The HTTP URL for this team's repositories
   */

  repositoriesUrl: () => Field<"repositoriesUrl">;

  /**
   * @description The HTTP path for this team
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The slug corresponding to the team.
   */

  slug: () => Field<"slug">;

  /**
   * @description The HTTP path for this team's teams
   */

  teamsResourcePath: () => Field<"teamsResourcePath">;

  /**
   * @description The HTTP URL for this team's teams
   */

  teamsUrl: () => Field<"teamsUrl">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this team
   */

  url: () => Field<"url">;

  /**
   * @description Team is adminable by the viewer.
   */

  viewerCanAdminister: () => Field<"viewerCanAdminister">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  viewerSubscription: () => Field<"viewerSubscription">;
}

export const isTeam = (
  object: Record<string, any>
): object is Partial<ITeam> => {
  return object.__typename === "Team";
};

export const Team: TeamSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of teams that are ancestors of this team.
   */

  ancestors: (variables, select) =>
    new Field(
      "ancestors",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description A URL pointing to the team's avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description List of child teams belonging to this team
   */

  childTeams: (variables, select) =>
    new Field(
      "childTeams",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("immediateOnly", variables.immediateOnly),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("userLogins", variables.userLogins),
      ],
      new SelectionSet(select(TeamConnection))
    ),

  /**
   * @description The slug corresponding to the organization and team.
   */
  combinedSlug: () => new Field("combinedSlug"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The description of the team.
   */
  description: () => new Field("description"),

  /**
   * @description Find a team discussion by its number.
   */

  discussion: (variables, select) =>
    new Field(
      "discussion",
      [new Argument("number", variables.number)],
      new SelectionSet(select(TeamDiscussion))
    ),

  /**
   * @description A list of team discussions.
   */

  discussions: (variables, select) =>
    new Field(
      "discussions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isPinned", variables.isPinned),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(TeamDiscussionConnection))
    ),

  /**
   * @description The HTTP path for team discussions
   */
  discussionsResourcePath: () => new Field("discussionsResourcePath"),

  /**
   * @description The HTTP URL for team discussions
   */
  discussionsUrl: () => new Field("discussionsUrl"),

  /**
   * @description The HTTP path for editing this team
   */
  editTeamResourcePath: () => new Field("editTeamResourcePath"),

  /**
   * @description The HTTP URL for editing this team
   */
  editTeamUrl: () => new Field("editTeamUrl"),
  id: () => new Field("id"),

  /**
   * @description A list of pending invitations for users to this team
   */

  invitations: (variables, select) =>
    new Field(
      "invitations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(OrganizationInvitationConnection))
    ),

  /**
   * @description Get the status messages members of this entity have set that are either public or visible only to the organization.
   */

  memberStatuses: (variables, select) =>
    new Field(
      "memberStatuses",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(UserStatusConnection))
    ),

  /**
   * @description A list of users who are members of this team.
   */

  members: (variables, select) =>
    new Field(
      "members",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("membership", variables.membership, TeamMembershipType),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
        new Argument("role", variables.role, TeamMemberRole),
      ],
      new SelectionSet(select(TeamMemberConnection))
    ),

  /**
   * @description The HTTP path for the team' members
   */
  membersResourcePath: () => new Field("membersResourcePath"),

  /**
   * @description The HTTP URL for the team' members
   */
  membersUrl: () => new Field("membersUrl"),

  /**
   * @description The name of the team.
   */
  name: () => new Field("name"),

  /**
   * @description The HTTP path creating a new team
   */
  newTeamResourcePath: () => new Field("newTeamResourcePath"),

  /**
   * @description The HTTP URL creating a new team
   */
  newTeamUrl: () => new Field("newTeamUrl"),

  /**
   * @description The organization that owns this team.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The parent team of the team.
   */

  parentTeam: (select) =>
    new Field("parentTeam", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The level of privacy the team has.
   */
  privacy: () => new Field("privacy"),

  /**
   * @description A list of repositories this team has access to.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("query", variables.query),
      ],
      new SelectionSet(select(TeamRepositoryConnection))
    ),

  /**
   * @description The HTTP path for this team's repositories
   */
  repositoriesResourcePath: () => new Field("repositoriesResourcePath"),

  /**
   * @description The HTTP URL for this team's repositories
   */
  repositoriesUrl: () => new Field("repositoriesUrl"),

  /**
   * @description The HTTP path for this team
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The slug corresponding to the team.
   */
  slug: () => new Field("slug"),

  /**
   * @description The HTTP path for this team's teams
   */
  teamsResourcePath: () => new Field("teamsResourcePath"),

  /**
   * @description The HTTP URL for this team's teams
   */
  teamsUrl: () => new Field("teamsUrl"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this team
   */
  url: () => new Field("url"),

  /**
   * @description Team is adminable by the viewer.
   */
  viewerCanAdminister: () => new Field("viewerCanAdminister"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),
};

export interface ITeamAddMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    ITeamAuditEntryData {
  __typename: "TeamAddMemberAuditEntry";
  isLdapMapped: boolean;
}

interface TeamAddMemberAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The team associated with the action
   */

  team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isTeamAddMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamAddMemberAuditEntry> => {
  return object.__typename === "TeamAddMemberAuditEntry";
};

export const TeamAddMemberAuditEntry: TeamAddMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamAddRepositoryAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData,
    ITeamAuditEntryData {
  __typename: "TeamAddRepositoryAuditEntry";
  isLdapMapped: boolean;
}

interface TeamAddRepositoryAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The team associated with the action
   */

  team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isTeamAddRepositoryAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamAddRepositoryAuditEntry> => {
  return object.__typename === "TeamAddRepositoryAuditEntry";
};

export const TeamAddRepositoryAuditEntry: TeamAddRepositoryAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamAuditEntryData {
  __typename: string;
  team: ITeam;
  teamName: string;
  teamResourcePath: unknown;
  teamUrl: unknown;
}

interface TeamAuditEntryDataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The team associated with the action
   */

  team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  teamUrl: () => Field<"teamUrl">;

  on: <
    T extends Array<Selection>,
    F extends
      | "OrgRestoreMemberMembershipTeamAuditEntryData"
      | "TeamAddMemberAuditEntry"
      | "TeamAddRepositoryAuditEntry"
      | "TeamChangeParentTeamAuditEntry"
      | "TeamRemoveMemberAuditEntry"
      | "TeamRemoveRepositoryAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "OrgRestoreMemberMembershipTeamAuditEntryData"
        ? OrgRestoreMemberMembershipTeamAuditEntryDataSelector
        : F extends "TeamAddMemberAuditEntry"
        ? TeamAddMemberAuditEntrySelector
        : F extends "TeamAddRepositoryAuditEntry"
        ? TeamAddRepositoryAuditEntrySelector
        : F extends "TeamChangeParentTeamAuditEntry"
        ? TeamChangeParentTeamAuditEntrySelector
        : F extends "TeamRemoveMemberAuditEntry"
        ? TeamRemoveMemberAuditEntrySelector
        : F extends "TeamRemoveRepositoryAuditEntry"
        ? TeamRemoveRepositoryAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const TeamAuditEntryData: TeamAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  on: (type, select) => {
    switch (type) {
      case "OrgRestoreMemberMembershipTeamAuditEntryData": {
        return new InlineFragment(
          new NamedType("OrgRestoreMemberMembershipTeamAuditEntryData") as any,
          new SelectionSet(
            select(OrgRestoreMemberMembershipTeamAuditEntryData as any)
          )
        );
      }

      case "TeamAddMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddMemberAuditEntry") as any,
          new SelectionSet(select(TeamAddMemberAuditEntry as any))
        );
      }

      case "TeamAddRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamAddRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamAddRepositoryAuditEntry as any))
        );
      }

      case "TeamChangeParentTeamAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamChangeParentTeamAuditEntry") as any,
          new SelectionSet(select(TeamChangeParentTeamAuditEntry as any))
        );
      }

      case "TeamRemoveMemberAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveMemberAuditEntry") as any,
          new SelectionSet(select(TeamRemoveMemberAuditEntry as any))
        );
      }

      case "TeamRemoveRepositoryAuditEntry": {
        return new InlineFragment(
          new NamedType("TeamRemoveRepositoryAuditEntry") as any,
          new SelectionSet(select(TeamRemoveRepositoryAuditEntry as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface ITeamChangeParentTeamAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    ITeamAuditEntryData {
  __typename: "TeamChangeParentTeamAuditEntry";
  isLdapMapped: boolean;
  parentTeam: ITeam;
  parentTeamName: string;
  parentTeamNameWas: string;
  parentTeamResourcePath: unknown;
  parentTeamUrl: unknown;
  parentTeamWas: ITeam;
  parentTeamWasResourcePath: unknown;
  parentTeamWasUrl: unknown;
}

interface TeamChangeParentTeamAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The new parent team.
   */

  parentTeam: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"parentTeam", never, SelectionSet<T>>;

  /**
   * @description The name of the new parent team
   */

  parentTeamName: () => Field<"parentTeamName">;

  /**
   * @description The name of the former parent team
   */

  parentTeamNameWas: () => Field<"parentTeamNameWas">;

  /**
   * @description The HTTP path for the parent team
   */

  parentTeamResourcePath: () => Field<"parentTeamResourcePath">;

  /**
   * @description The HTTP URL for the parent team
   */

  parentTeamUrl: () => Field<"parentTeamUrl">;

  /**
   * @description The former parent team.
   */

  parentTeamWas: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"parentTeamWas", never, SelectionSet<T>>;

  /**
   * @description The HTTP path for the previous parent team
   */

  parentTeamWasResourcePath: () => Field<"parentTeamWasResourcePath">;

  /**
   * @description The HTTP URL for the previous parent team
   */

  parentTeamWasUrl: () => Field<"parentTeamWasUrl">;

  /**
   * @description The team associated with the action
   */

  team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isTeamChangeParentTeamAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamChangeParentTeamAuditEntry> => {
  return object.__typename === "TeamChangeParentTeamAuditEntry";
};

export const TeamChangeParentTeamAuditEntry: TeamChangeParentTeamAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The new parent team.
   */

  parentTeam: (select) =>
    new Field("parentTeam", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the new parent team
   */
  parentTeamName: () => new Field("parentTeamName"),

  /**
   * @description The name of the former parent team
   */
  parentTeamNameWas: () => new Field("parentTeamNameWas"),

  /**
   * @description The HTTP path for the parent team
   */
  parentTeamResourcePath: () => new Field("parentTeamResourcePath"),

  /**
   * @description The HTTP URL for the parent team
   */
  parentTeamUrl: () => new Field("parentTeamUrl"),

  /**
   * @description The former parent team.
   */

  parentTeamWas: (select) =>
    new Field(
      "parentTeamWas",
      undefined as never,
      new SelectionSet(select(Team))
    ),

  /**
   * @description The HTTP path for the previous parent team
   */
  parentTeamWasResourcePath: () => new Field("parentTeamWasResourcePath"),

  /**
   * @description The HTTP URL for the previous parent team
   */
  parentTeamWasUrl: () => new Field("parentTeamWasUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamConnection {
  edges: ITeamEdge[];
  nodes: ITeam[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface TeamConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: TeamEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const TeamConnection: TeamConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(TeamEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamDiscussion
  extends IComment,
    IDeletable,
    INode,
    IReactable,
    ISubscribable,
    IUniformResourceLocatable,
    IUpdatable,
    IUpdatableComment {
  __typename: "TeamDiscussion";
  bodyVersion: string;
  comments: ITeamDiscussionCommentConnection;
  commentsResourcePath: unknown;
  commentsUrl: unknown;
  isPinned: boolean;
  isPrivate: boolean;
  number: number;
  team: ITeam;
  title: string;
  viewerCanPin: boolean;
}

interface TeamDiscussionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the discussion's team.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The body as Markdown.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description Identifies the discussion body hash.
   */

  bodyVersion: () => Field<"bodyVersion">;

  /**
   * @description A list of comments on this discussion.
   */

  comments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      fromComment?: Variable<"fromComment"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | TeamDiscussionCommentOrder;
    },
    select: (t: TeamDiscussionCommentConnectionSelector) => T
  ) => Field<
    "comments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"fromComment", Variable<"fromComment"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | TeamDiscussionCommentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for discussion comments
   */

  commentsResourcePath: () => Field<"commentsResourcePath">;

  /**
   * @description The HTTP URL for discussion comments
   */

  commentsUrl: () => Field<"commentsUrl">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The actor who edited the comment.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description Whether or not the discussion is pinned.
   */

  isPinned: () => Field<"isPinned">;

  /**
   * @description Whether or not the discussion is only visible to team members and org admins.
   */

  isPrivate: () => Field<"isPrivate">;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Identifies the discussion within its team.
   */

  number: () => Field<"number">;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this discussion
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The team that defines the context of this discussion.
   */

  team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The title of the discussion
   */

  title: () => Field<"title">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this discussion
   */

  url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Whether or not the current viewer can pin this discussion.
   */

  viewerCanPin: () => Field<"viewerCanPin">;

  /**
   * @description Can user react to this subject
   */

  viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */

  viewerCanSubscribe: () => Field<"viewerCanSubscribe">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */

  viewerSubscription: () => Field<"viewerSubscription">;
}

export const isTeamDiscussion = (
  object: Record<string, any>
): object is Partial<ITeamDiscussion> => {
  return object.__typename === "TeamDiscussion";
};

export const TeamDiscussion: TeamDiscussionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the discussion's team.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description Identifies the discussion body hash.
   */
  bodyVersion: () => new Field("bodyVersion"),

  /**
   * @description A list of comments on this discussion.
   */

  comments: (variables, select) =>
    new Field(
      "comments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("fromComment", variables.fromComment),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(TeamDiscussionCommentConnection))
    ),

  /**
   * @description The HTTP path for discussion comments
   */
  commentsResourcePath: () => new Field("commentsResourcePath"),

  /**
   * @description The HTTP URL for discussion comments
   */
  commentsUrl: () => new Field("commentsUrl"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description Whether or not the discussion is pinned.
   */
  isPinned: () => new Field("isPinned"),

  /**
   * @description Whether or not the discussion is only visible to team members and org admins.
   */
  isPrivate: () => new Field("isPrivate"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Identifies the discussion within its team.
   */
  number: () => new Field("number"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The HTTP path for this discussion
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The team that defines the context of this discussion.
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The title of the discussion
   */
  title: () => new Field("title"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this discussion
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Whether or not the current viewer can pin this discussion.
   */
  viewerCanPin: () => new Field("viewerCanPin"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the viewer is able to change their subscription status for the repository.
   */
  viewerCanSubscribe: () => new Field("viewerCanSubscribe"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),

  /**
   * @description Identifies if the viewer is watching, not watching, or ignoring the subscribable entity.
   */
  viewerSubscription: () => new Field("viewerSubscription"),
};

export interface ITeamDiscussionComment
  extends IComment,
    IDeletable,
    INode,
    IReactable,
    IUniformResourceLocatable,
    IUpdatable,
    IUpdatableComment {
  __typename: "TeamDiscussionComment";
  bodyVersion: string;
  discussion: ITeamDiscussion;
  number: number;
}

interface TeamDiscussionCommentSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The actor who authored the comment.
   */

  author: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"author", never, SelectionSet<T>>;

  /**
   * @description Author's association with the comment's team.
   */

  authorAssociation: () => Field<"authorAssociation">;

  /**
   * @description The body as Markdown.
   */

  body: () => Field<"body">;

  /**
   * @description The body rendered to HTML.
   */

  bodyHTML: () => Field<"bodyHTML">;

  /**
   * @description The body rendered to text.
   */

  bodyText: () => Field<"bodyText">;

  /**
   * @description The current version of the body content.
   */

  bodyVersion: () => Field<"bodyVersion">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Check if this comment was created via an email reply.
   */

  createdViaEmail: () => Field<"createdViaEmail">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The discussion this comment is about.
   */

  discussion: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"discussion", never, SelectionSet<T>>;

  /**
   * @description The actor who edited the comment.
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */

  includesCreatedEdit: () => Field<"includesCreatedEdit">;

  /**
   * @description The moment the editor made the last edit
   */

  lastEditedAt: () => Field<"lastEditedAt">;

  /**
   * @description Identifies the comment number.
   */

  number: () => Field<"number">;

  /**
   * @description Identifies when the comment was published at.
   */

  publishedAt: () => Field<"publishedAt">;

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: <T extends Array<Selection>>(
    select: (t: ReactionGroupSelector) => T
  ) => Field<"reactionGroups", never, SelectionSet<T>>;

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      content?: Variable<"content"> | ReactionContent;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ReactionOrder;
    },
    select: (t: ReactionConnectionSelector) => T
  ) => Field<
    "reactions",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"content", Variable<"content"> | ReactionContent>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ReactionOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this comment
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this comment
   */

  url: () => Field<"url">;

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: UserContentEditConnectionSelector) => T
  ) => Field<
    "userContentEdits",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Check if the current viewer can delete this object.
   */

  viewerCanDelete: () => Field<"viewerCanDelete">;

  /**
   * @description Can user react to this subject
   */

  viewerCanReact: () => Field<"viewerCanReact">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  /**
   * @description Did the viewer author this comment.
   */

  viewerDidAuthor: () => Field<"viewerDidAuthor">;
}

export const isTeamDiscussionComment = (
  object: Record<string, any>
): object is Partial<ITeamDiscussionComment> => {
  return object.__typename === "TeamDiscussionComment";
};

export const TeamDiscussionComment: TeamDiscussionCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The actor who authored the comment.
   */

  author: (select) =>
    new Field("author", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Author's association with the comment's team.
   */
  authorAssociation: () => new Field("authorAssociation"),

  /**
   * @description The body as Markdown.
   */
  body: () => new Field("body"),

  /**
   * @description The body rendered to HTML.
   */
  bodyHTML: () => new Field("bodyHTML"),

  /**
   * @description The body rendered to text.
   */
  bodyText: () => new Field("bodyText"),

  /**
   * @description The current version of the body content.
   */
  bodyVersion: () => new Field("bodyVersion"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Check if this comment was created via an email reply.
   */
  createdViaEmail: () => new Field("createdViaEmail"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The discussion this comment is about.
   */

  discussion: (select) =>
    new Field(
      "discussion",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),

  /**
   * @description The actor who edited the comment.
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Check if this comment was edited and includes an edit with the creation data
   */
  includesCreatedEdit: () => new Field("includesCreatedEdit"),

  /**
   * @description The moment the editor made the last edit
   */
  lastEditedAt: () => new Field("lastEditedAt"),

  /**
   * @description Identifies the comment number.
   */
  number: () => new Field("number"),

  /**
   * @description Identifies when the comment was published at.
   */
  publishedAt: () => new Field("publishedAt"),

  /**
   * @description A list of reactions grouped by content left on the subject.
   */

  reactionGroups: (select) =>
    new Field(
      "reactionGroups",
      undefined as never,
      new SelectionSet(select(ReactionGroup))
    ),

  /**
   * @description A list of Reactions left on the Issue.
   */

  reactions: (variables, select) =>
    new Field(
      "reactions",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("content", variables.content, ReactionContent),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(ReactionConnection))
    ),

  /**
   * @description The HTTP path for this comment
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this comment
   */
  url: () => new Field("url"),

  /**
   * @description A list of edits to this content.
   */

  userContentEdits: (variables, select) =>
    new Field(
      "userContentEdits",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(UserContentEditConnection))
    ),

  /**
   * @description Check if the current viewer can delete this object.
   */
  viewerCanDelete: () => new Field("viewerCanDelete"),

  /**
   * @description Can user react to this subject
   */
  viewerCanReact: () => new Field("viewerCanReact"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  /**
   * @description Did the viewer author this comment.
   */
  viewerDidAuthor: () => new Field("viewerDidAuthor"),
};

export interface ITeamDiscussionCommentConnection {
  edges: ITeamDiscussionCommentEdge[];
  nodes: ITeamDiscussionComment[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface TeamDiscussionCommentConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const TeamDiscussionCommentConnection: TeamDiscussionCommentConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(TeamDiscussionCommentEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(TeamDiscussionComment))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamDiscussionCommentEdge {
  cursor: string;
  node: ITeamDiscussionComment;
}

interface TeamDiscussionCommentEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const TeamDiscussionCommentEdge: TeamDiscussionCommentEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(TeamDiscussionComment))
    ),
};

export interface ITeamDiscussionConnection {
  edges: ITeamDiscussionEdge[];
  nodes: ITeamDiscussion[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface TeamDiscussionConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: TeamDiscussionEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const TeamDiscussionConnection: TeamDiscussionConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(TeamDiscussionEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamDiscussionEdge {
  cursor: string;
  node: ITeamDiscussion;
}

interface TeamDiscussionEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const TeamDiscussionEdge: TeamDiscussionEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),
};

export interface ITeamEdge {
  cursor: string;
  node: ITeam;
}

interface TeamEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const TeamEdge: TeamEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Team))),
};

export interface ITeamMemberConnection {
  edges: ITeamMemberEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface TeamMemberConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: TeamMemberEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const TeamMemberConnection: TeamMemberConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(TeamMemberEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamMemberEdge {
  cursor: string;
  memberAccessResourcePath: unknown;
  memberAccessUrl: unknown;
  node: IUser;
  role: TeamMemberRole;
}

interface TeamMemberEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The HTTP path to the organization's member access page.
   */

  memberAccessResourcePath: () => Field<"memberAccessResourcePath">;

  /**
   * @description The HTTP URL to the organization's member access page.
   */

  memberAccessUrl: () => Field<"memberAccessUrl">;

  node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The role the member has on the team.
   */

  role: () => Field<"role">;
}

export const TeamMemberEdge: TeamMemberEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The HTTP path to the organization's member access page.
   */
  memberAccessResourcePath: () => new Field("memberAccessResourcePath"),

  /**
   * @description The HTTP URL to the organization's member access page.
   */
  memberAccessUrl: () => new Field("memberAccessUrl"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),

  /**
   * @description The role the member has on the team.
   */
  role: () => new Field("role"),
};

export interface ITeamRemoveMemberAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    ITeamAuditEntryData {
  __typename: "TeamRemoveMemberAuditEntry";
  isLdapMapped: boolean;
}

interface TeamRemoveMemberAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The team associated with the action
   */

  team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isTeamRemoveMemberAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamRemoveMemberAuditEntry> => {
  return object.__typename === "TeamRemoveMemberAuditEntry";
};

export const TeamRemoveMemberAuditEntry: TeamRemoveMemberAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamRemoveRepositoryAuditEntry
  extends IAuditEntry,
    INode,
    IOrganizationAuditEntryData,
    IRepositoryAuditEntryData,
    ITeamAuditEntryData {
  __typename: "TeamRemoveRepositoryAuditEntry";
  isLdapMapped: boolean;
}

interface TeamRemoveRepositoryAuditEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The action name
   */

  action: () => Field<"action">;

  /**
   * @description The user who initiated the action
   */

  actor: <T extends Array<Selection>>(
    select: (t: AuditEntryActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The IP address of the actor
   */

  actorIp: () => Field<"actorIp">;

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: <T extends Array<Selection>>(
    select: (t: ActorLocationSelector) => T
  ) => Field<"actorLocation", never, SelectionSet<T>>;

  /**
   * @description The username of the user who initiated the action
   */

  actorLogin: () => Field<"actorLogin">;

  /**
   * @description The HTTP path for the actor.
   */

  actorResourcePath: () => Field<"actorResourcePath">;

  /**
   * @description The HTTP URL for the actor.
   */

  actorUrl: () => Field<"actorUrl">;

  /**
   * @description The time the action was initiated
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */

  isLdapMapped: () => Field<"isLdapMapped">;

  /**
   * @description The corresponding operation type for the action
   */

  operationType: () => Field<"operationType">;

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description The name of the Organization.
   */

  organizationName: () => Field<"organizationName">;

  /**
   * @description The HTTP path for the organization
   */

  organizationResourcePath: () => Field<"organizationResourcePath">;

  /**
   * @description The HTTP URL for the organization
   */

  organizationUrl: () => Field<"organizationUrl">;

  /**
   * @description The repository associated with the action
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description The name of the repository
   */

  repositoryName: () => Field<"repositoryName">;

  /**
   * @description The HTTP path for the repository
   */

  repositoryResourcePath: () => Field<"repositoryResourcePath">;

  /**
   * @description The HTTP URL for the repository
   */

  repositoryUrl: () => Field<"repositoryUrl">;

  /**
   * @description The team associated with the action
   */

  team: <T extends Array<Selection>>(
    select: (t: TeamSelector) => T
  ) => Field<"team", never, SelectionSet<T>>;

  /**
   * @description The name of the team
   */

  teamName: () => Field<"teamName">;

  /**
   * @description The HTTP path for this team
   */

  teamResourcePath: () => Field<"teamResourcePath">;

  /**
   * @description The HTTP URL for this team
   */

  teamUrl: () => Field<"teamUrl">;

  /**
   * @description The user affected by the action
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */

  userLogin: () => Field<"userLogin">;

  /**
   * @description The HTTP path for the user.
   */

  userResourcePath: () => Field<"userResourcePath">;

  /**
   * @description The HTTP URL for the user.
   */

  userUrl: () => Field<"userUrl">;
}

export const isTeamRemoveRepositoryAuditEntry = (
  object: Record<string, any>
): object is Partial<ITeamRemoveRepositoryAuditEntry> => {
  return object.__typename === "TeamRemoveRepositoryAuditEntry";
};

export const TeamRemoveRepositoryAuditEntry: TeamRemoveRepositoryAuditEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The action name
   */
  action: () => new Field("action"),

  /**
   * @description The user who initiated the action
   */

  actor: (select) =>
    new Field(
      "actor",
      undefined as never,
      new SelectionSet(select(AuditEntryActor))
    ),

  /**
   * @description The IP address of the actor
   */
  actorIp: () => new Field("actorIp"),

  /**
   * @description A readable representation of the actor's location
   */

  actorLocation: (select) =>
    new Field(
      "actorLocation",
      undefined as never,
      new SelectionSet(select(ActorLocation))
    ),

  /**
   * @description The username of the user who initiated the action
   */
  actorLogin: () => new Field("actorLogin"),

  /**
   * @description The HTTP path for the actor.
   */
  actorResourcePath: () => new Field("actorResourcePath"),

  /**
   * @description The HTTP URL for the actor.
   */
  actorUrl: () => new Field("actorUrl"),

  /**
   * @description The time the action was initiated
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Whether the team was mapped to an LDAP Group.
   */
  isLdapMapped: () => new Field("isLdapMapped"),

  /**
   * @description The corresponding operation type for the action
   */
  operationType: () => new Field("operationType"),

  /**
   * @description The Organization associated with the Audit Entry.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description The name of the Organization.
   */
  organizationName: () => new Field("organizationName"),

  /**
   * @description The HTTP path for the organization
   */
  organizationResourcePath: () => new Field("organizationResourcePath"),

  /**
   * @description The HTTP URL for the organization
   */
  organizationUrl: () => new Field("organizationUrl"),

  /**
   * @description The repository associated with the action
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The name of the repository
   */
  repositoryName: () => new Field("repositoryName"),

  /**
   * @description The HTTP path for the repository
   */
  repositoryResourcePath: () => new Field("repositoryResourcePath"),

  /**
   * @description The HTTP URL for the repository
   */
  repositoryUrl: () => new Field("repositoryUrl"),

  /**
   * @description The team associated with the action
   */

  team: (select) =>
    new Field("team", undefined as never, new SelectionSet(select(Team))),

  /**
   * @description The name of the team
   */
  teamName: () => new Field("teamName"),

  /**
   * @description The HTTP path for this team
   */
  teamResourcePath: () => new Field("teamResourcePath"),

  /**
   * @description The HTTP URL for this team
   */
  teamUrl: () => new Field("teamUrl"),

  /**
   * @description The user affected by the action
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),

  /**
   * @description For actions involving two users, the actor is the initiator and the user is the affected user.
   */
  userLogin: () => new Field("userLogin"),

  /**
   * @description The HTTP path for the user.
   */
  userResourcePath: () => new Field("userResourcePath"),

  /**
   * @description The HTTP URL for the user.
   */
  userUrl: () => new Field("userUrl"),
};

export interface ITeamRepositoryConnection {
  edges: ITeamRepositoryEdge[];
  nodes: IRepository[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface TeamRepositoryConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: TeamRepositoryEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const TeamRepositoryConnection: TeamRepositoryConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(TeamRepositoryEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface ITeamRepositoryEdge {
  cursor: string;
  node: IRepository;
  permission: RepositoryPermission;
}

interface TeamRepositoryEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  node: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"node", never, SelectionSet<T>>;

  /**
   * @description The permission level the team has on the repository
   */

  permission: () => Field<"permission">;
}

export const TeamRepositoryEdge: TeamRepositoryEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(Repository))),

  /**
   * @description The permission level the team has on the repository
   */
  permission: () => new Field("permission"),
};

export interface ITextMatch {
  fragment: string;
  highlights: ITextMatchHighlight[];
  property: string;
}

interface TextMatchSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The specific text fragment within the property matched on.
   */

  fragment: () => Field<"fragment">;

  /**
   * @description Highlights within the matched fragment.
   */

  highlights: <T extends Array<Selection>>(
    select: (t: TextMatchHighlightSelector) => T
  ) => Field<"highlights", never, SelectionSet<T>>;

  /**
   * @description The property matched on.
   */

  property: () => Field<"property">;
}

export const TextMatch: TextMatchSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The specific text fragment within the property matched on.
   */
  fragment: () => new Field("fragment"),

  /**
   * @description Highlights within the matched fragment.
   */

  highlights: (select) =>
    new Field(
      "highlights",
      undefined as never,
      new SelectionSet(select(TextMatchHighlight))
    ),

  /**
   * @description The property matched on.
   */
  property: () => new Field("property"),
};

export interface ITextMatchHighlight {
  beginIndice: number;
  endIndice: number;
  text: string;
}

interface TextMatchHighlightSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The indice in the fragment where the matched text begins.
   */

  beginIndice: () => Field<"beginIndice">;

  /**
   * @description The indice in the fragment where the matched text ends.
   */

  endIndice: () => Field<"endIndice">;

  /**
   * @description The text matched.
   */

  text: () => Field<"text">;
}

export const TextMatchHighlight: TextMatchHighlightSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The indice in the fragment where the matched text begins.
   */
  beginIndice: () => new Field("beginIndice"),

  /**
   * @description The indice in the fragment where the matched text ends.
   */
  endIndice: () => new Field("endIndice"),

  /**
   * @description The text matched.
   */
  text: () => new Field("text"),
};

export interface ITopic extends INode, IStarrable {
  __typename: "Topic";
  name: string;
  relatedTopics: ITopic[];
}

interface TopicSelector {
  __typename: () => Field<"__typename">;

  id: () => Field<"id">;

  /**
   * @description The topic's name.
   */

  name: () => Field<"name">;

  /**
     * @description A list of related topics, including aliases of this topic, sorted with the most relevant
first. Returns up to 10 Topics.
     */

  relatedTopics: <T extends Array<Selection>>(
    variables: { first?: Variable<"first"> | number },
    select: (t: TopicSelector) => T
  ) => Field<
    "relatedTopics",
    [Argument<"first", Variable<"first"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description Returns a count of how many stargazers there are on this object
   */

  stargazerCount: () => Field<"stargazerCount">;

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
    },
    select: (t: StargazerConnectionSelector) => T
  ) => Field<
    "stargazers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */

  viewerHasStarred: () => Field<"viewerHasStarred">;
}

export const isTopic = (
  object: Record<string, any>
): object is Partial<ITopic> => {
  return object.__typename === "Topic";
};

export const Topic: TopicSelector = {
  __typename: () => new Field("__typename"),

  id: () => new Field("id"),

  /**
   * @description The topic's name.
   */
  name: () => new Field("name"),

  /**
     * @description A list of related topics, including aliases of this topic, sorted with the most relevant
first. Returns up to 10 Topics.
     */

  relatedTopics: (variables, select) =>
    new Field(
      "relatedTopics",
      [new Argument("first", variables.first)],
      new SelectionSet(select(Topic))
    ),

  /**
   * @description Returns a count of how many stargazers there are on this object
   */
  stargazerCount: () => new Field("stargazerCount"),

  /**
   * @description A list of users who have starred this starrable.
   */

  stargazers: (variables, select) =>
    new Field(
      "stargazers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(StargazerConnection))
    ),

  /**
   * @description Returns a boolean indicating whether the viewing user has starred this starrable.
   */
  viewerHasStarred: () => new Field("viewerHasStarred"),
};

export interface ITopicAuditEntryData {
  __typename: string;
  topic: ITopic;
  topicName: string;
}

interface TopicAuditEntryDataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The name of the topic added to the repository
   */

  topic: <T extends Array<Selection>>(
    select: (t: TopicSelector) => T
  ) => Field<"topic", never, SelectionSet<T>>;

  /**
   * @description The name of the topic added to the repository
   */

  topicName: () => Field<"topicName">;

  on: <
    T extends Array<Selection>,
    F extends "RepoAddTopicAuditEntry" | "RepoRemoveTopicAuditEntry"
  >(
    type: F,
    select: (
      t: F extends "RepoAddTopicAuditEntry"
        ? RepoAddTopicAuditEntrySelector
        : F extends "RepoRemoveTopicAuditEntry"
        ? RepoRemoveTopicAuditEntrySelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const TopicAuditEntryData: TopicAuditEntryDataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The name of the topic added to the repository
   */

  topic: (select) =>
    new Field("topic", undefined as never, new SelectionSet(select(Topic))),

  /**
   * @description The name of the topic added to the repository
   */
  topicName: () => new Field("topicName"),

  on: (type, select) => {
    switch (type) {
      case "RepoAddTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoAddTopicAuditEntry") as any,
          new SelectionSet(select(RepoAddTopicAuditEntry as any))
        );
      }

      case "RepoRemoveTopicAuditEntry": {
        return new InlineFragment(
          new NamedType("RepoRemoveTopicAuditEntry") as any,
          new SelectionSet(select(RepoRemoveTopicAuditEntry as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface ITransferIssuePayload {
  clientMutationId: string;
  issue: IIssue;
}

interface TransferIssuePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue that was transferred
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const TransferIssuePayload: TransferIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue that was transferred
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface ITransferredEvent extends INode {
  __typename: "TransferredEvent";
  actor: IActor;
  createdAt: unknown;
  fromRepository: IRepository;
  issue: IIssue;
}

interface TransferredEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The repository this came from
   */

  fromRepository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"fromRepository", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Identifies the issue associated with the event.
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const isTransferredEvent = (
  object: Record<string, any>
): object is Partial<ITransferredEvent> => {
  return object.__typename === "TransferredEvent";
};

export const TransferredEvent: TransferredEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The repository this came from
   */

  fromRepository: (select) =>
    new Field(
      "fromRepository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  id: () => new Field("id"),

  /**
   * @description Identifies the issue associated with the event.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface ITree extends IGitObject, INode {
  __typename: "Tree";
  entries: ITreeEntry[];
}

interface TreeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description An abbreviated version of the Git object ID
   */

  abbreviatedOid: () => Field<"abbreviatedOid">;

  /**
   * @description The HTTP path for this Git object
   */

  commitResourcePath: () => Field<"commitResourcePath">;

  /**
   * @description The HTTP URL for this Git object
   */

  commitUrl: () => Field<"commitUrl">;

  /**
   * @description A list of tree entries.
   */

  entries: <T extends Array<Selection>>(
    select: (t: TreeEntrySelector) => T
  ) => Field<"entries", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description The Git object ID
   */

  oid: () => Field<"oid">;

  /**
   * @description The Repository the Git object belongs to
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const isTree = (
  object: Record<string, any>
): object is Partial<ITree> => {
  return object.__typename === "Tree";
};

export const Tree: TreeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description An abbreviated version of the Git object ID
   */
  abbreviatedOid: () => new Field("abbreviatedOid"),

  /**
   * @description The HTTP path for this Git object
   */
  commitResourcePath: () => new Field("commitResourcePath"),

  /**
   * @description The HTTP URL for this Git object
   */
  commitUrl: () => new Field("commitUrl"),

  /**
   * @description A list of tree entries.
   */

  entries: (select) =>
    new Field(
      "entries",
      undefined as never,
      new SelectionSet(select(TreeEntry))
    ),

  id: () => new Field("id"),

  /**
   * @description The Git object ID
   */
  oid: () => new Field("oid"),

  /**
   * @description The Repository the Git object belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface ITreeEntry {
  extension: string;
  isGenerated: boolean;
  mode: number;
  name: string;
  object: IGitObject;
  oid: unknown;
  path: string;
  repository: IRepository;
  submodule: ISubmodule;
  type: string;
}

interface TreeEntrySelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The extension of the file
   */

  extension: () => Field<"extension">;

  /**
   * @description Whether or not this tree entry is generated
   */

  isGenerated: () => Field<"isGenerated">;

  /**
   * @description Entry file mode.
   */

  mode: () => Field<"mode">;

  /**
   * @description Entry file name.
   */

  name: () => Field<"name">;

  /**
   * @description Entry file object.
   */

  object: <T extends Array<Selection>>(
    select: (t: GitObjectSelector) => T
  ) => Field<"object", never, SelectionSet<T>>;

  /**
   * @description Entry file Git object ID.
   */

  oid: () => Field<"oid">;

  /**
   * @description The full path of the file.
   */

  path: () => Field<"path">;

  /**
   * @description The Repository the tree entry belongs to
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;

  /**
   * @description If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule
   */

  submodule: <T extends Array<Selection>>(
    select: (t: SubmoduleSelector) => T
  ) => Field<"submodule", never, SelectionSet<T>>;

  /**
   * @description Entry file type.
   */

  type: () => Field<"type">;
}

export const TreeEntry: TreeEntrySelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The extension of the file
   */
  extension: () => new Field("extension"),

  /**
   * @description Whether or not this tree entry is generated
   */
  isGenerated: () => new Field("isGenerated"),

  /**
   * @description Entry file mode.
   */
  mode: () => new Field("mode"),

  /**
   * @description Entry file name.
   */
  name: () => new Field("name"),

  /**
   * @description Entry file object.
   */

  object: (select) =>
    new Field(
      "object",
      undefined as never,
      new SelectionSet(select(GitObject))
    ),

  /**
   * @description Entry file Git object ID.
   */
  oid: () => new Field("oid"),

  /**
   * @description The full path of the file.
   */
  path: () => new Field("path"),

  /**
   * @description The Repository the tree entry belongs to
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),

  /**
   * @description If the TreeEntry is for a directory occupied by a submodule project, this returns the corresponding submodule
   */

  submodule: (select) =>
    new Field(
      "submodule",
      undefined as never,
      new SelectionSet(select(Submodule))
    ),

  /**
   * @description Entry file type.
   */
  type: () => new Field("type"),
};

export interface IUnarchiveRepositoryPayload {
  clientMutationId: string;
  repository: IRepository;
}

interface UnarchiveRepositoryPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The repository that was unarchived.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UnarchiveRepositoryPayload: UnarchiveRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The repository that was unarchived.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUnassignedEvent extends INode {
  __typename: "UnassignedEvent";
  actor: IActor;
  assignable: IAssignable;
  assignee: IAssignee;
  createdAt: unknown;
  user: IUser;
}

interface UnassignedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the assignable associated with the event.
   */

  assignable: <T extends Array<Selection>>(
    select: (t: AssignableSelector) => T
  ) => Field<"assignable", never, SelectionSet<T>>;

  /**
   * @description Identifies the user or mannequin that was unassigned.
   */

  assignee: <T extends Array<Selection>>(
    select: (t: AssigneeSelector) => T
  ) => Field<"assignee", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isUnassignedEvent = (
  object: Record<string, any>
): object is Partial<IUnassignedEvent> => {
  return object.__typename === "UnassignedEvent";
};

export const UnassignedEvent: UnassignedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the assignable associated with the event.
   */

  assignable: (select) =>
    new Field(
      "assignable",
      undefined as never,
      new SelectionSet(select(Assignable))
    ),

  /**
   * @description Identifies the user or mannequin that was unassigned.
   */

  assignee: (select) =>
    new Field(
      "assignee",
      undefined as never,
      new SelectionSet(select(Assignee))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the subject (user) who was unassigned.
   * @deprecated Assignees can now be mannequins. Use the `assignee` field instead. Removal on 2020-01-01 UTC.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IUnfollowUserPayload {
  clientMutationId: string;
  user: IUser;
}

interface UnfollowUserPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The user that was unfollowed.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const UnfollowUserPayload: UnfollowUserPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The user that was unfollowed.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IUniformResourceLocatable {
  __typename: string;
  resourcePath: unknown;
  url: unknown;
}

interface UniformResourceLocatableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The HTML path to this resource.
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description The URL to this resource.
   */

  url: () => Field<"url">;

  on: <
    T extends Array<Selection>,
    F extends
      | "Bot"
      | "CheckRun"
      | "ClosedEvent"
      | "Commit"
      | "ConvertToDraftEvent"
      | "CrossReferencedEvent"
      | "Gist"
      | "Issue"
      | "Mannequin"
      | "MergedEvent"
      | "Milestone"
      | "Organization"
      | "PullRequest"
      | "PullRequestCommit"
      | "ReadyForReviewEvent"
      | "Release"
      | "Repository"
      | "RepositoryTopic"
      | "ReviewDismissedEvent"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
      | "User"
  >(
    type: F,
    select: (
      t: F extends "Bot"
        ? BotSelector
        : F extends "CheckRun"
        ? CheckRunSelector
        : F extends "ClosedEvent"
        ? ClosedEventSelector
        : F extends "Commit"
        ? CommitSelector
        : F extends "ConvertToDraftEvent"
        ? ConvertToDraftEventSelector
        : F extends "CrossReferencedEvent"
        ? CrossReferencedEventSelector
        : F extends "Gist"
        ? GistSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "Mannequin"
        ? MannequinSelector
        : F extends "MergedEvent"
        ? MergedEventSelector
        : F extends "Milestone"
        ? MilestoneSelector
        : F extends "Organization"
        ? OrganizationSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestCommit"
        ? PullRequestCommitSelector
        : F extends "ReadyForReviewEvent"
        ? ReadyForReviewEventSelector
        : F extends "Release"
        ? ReleaseSelector
        : F extends "Repository"
        ? RepositorySelector
        : F extends "RepositoryTopic"
        ? RepositoryTopicSelector
        : F extends "ReviewDismissedEvent"
        ? ReviewDismissedEventSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : F extends "User"
        ? UserSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const UniformResourceLocatable: UniformResourceLocatableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The HTML path to this resource.
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description The URL to this resource.
   */
  url: () => new Field("url"),

  on: (type, select) => {
    switch (type) {
      case "Bot": {
        return new InlineFragment(
          new NamedType("Bot") as any,
          new SelectionSet(select(Bot as any))
        );
      }

      case "CheckRun": {
        return new InlineFragment(
          new NamedType("CheckRun") as any,
          new SelectionSet(select(CheckRun as any))
        );
      }

      case "ClosedEvent": {
        return new InlineFragment(
          new NamedType("ClosedEvent") as any,
          new SelectionSet(select(ClosedEvent as any))
        );
      }

      case "Commit": {
        return new InlineFragment(
          new NamedType("Commit") as any,
          new SelectionSet(select(Commit as any))
        );
      }

      case "ConvertToDraftEvent": {
        return new InlineFragment(
          new NamedType("ConvertToDraftEvent") as any,
          new SelectionSet(select(ConvertToDraftEvent as any))
        );
      }

      case "CrossReferencedEvent": {
        return new InlineFragment(
          new NamedType("CrossReferencedEvent") as any,
          new SelectionSet(select(CrossReferencedEvent as any))
        );
      }

      case "Gist": {
        return new InlineFragment(
          new NamedType("Gist") as any,
          new SelectionSet(select(Gist as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "Mannequin": {
        return new InlineFragment(
          new NamedType("Mannequin") as any,
          new SelectionSet(select(Mannequin as any))
        );
      }

      case "MergedEvent": {
        return new InlineFragment(
          new NamedType("MergedEvent") as any,
          new SelectionSet(select(MergedEvent as any))
        );
      }

      case "Milestone": {
        return new InlineFragment(
          new NamedType("Milestone") as any,
          new SelectionSet(select(Milestone as any))
        );
      }

      case "Organization": {
        return new InlineFragment(
          new NamedType("Organization") as any,
          new SelectionSet(select(Organization as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestCommit": {
        return new InlineFragment(
          new NamedType("PullRequestCommit") as any,
          new SelectionSet(select(PullRequestCommit as any))
        );
      }

      case "ReadyForReviewEvent": {
        return new InlineFragment(
          new NamedType("ReadyForReviewEvent") as any,
          new SelectionSet(select(ReadyForReviewEvent as any))
        );
      }

      case "Release": {
        return new InlineFragment(
          new NamedType("Release") as any,
          new SelectionSet(select(Release as any))
        );
      }

      case "Repository": {
        return new InlineFragment(
          new NamedType("Repository") as any,
          new SelectionSet(select(Repository as any))
        );
      }

      case "RepositoryTopic": {
        return new InlineFragment(
          new NamedType("RepositoryTopic") as any,
          new SelectionSet(select(RepositoryTopic as any))
        );
      }

      case "ReviewDismissedEvent": {
        return new InlineFragment(
          new NamedType("ReviewDismissedEvent") as any,
          new SelectionSet(select(ReviewDismissedEvent as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      case "User": {
        return new InlineFragment(
          new NamedType("User") as any,
          new SelectionSet(select(User as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IUnknownSignature extends IGitSignature {
  __typename: "UnknownSignature";
}

interface UnknownSignatureSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Email used to sign this object.
   */

  email: () => Field<"email">;

  /**
   * @description True if the signature is valid and verified by GitHub.
   */

  isValid: () => Field<"isValid">;

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */

  payload: () => Field<"payload">;

  /**
   * @description ASCII-armored signature header from object.
   */

  signature: () => Field<"signature">;

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"signer", never, SelectionSet<T>>;

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */

  state: () => Field<"state">;

  /**
   * @description True if the signature was made with GitHub's signing key.
   */

  wasSignedByGitHub: () => Field<"wasSignedByGitHub">;
}

export const isUnknownSignature = (
  object: Record<string, any>
): object is Partial<IUnknownSignature> => {
  return object.__typename === "UnknownSignature";
};

export const UnknownSignature: UnknownSignatureSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Email used to sign this object.
   */
  email: () => new Field("email"),

  /**
   * @description True if the signature is valid and verified by GitHub.
   */
  isValid: () => new Field("isValid"),

  /**
   * @description Payload for GPG signing object. Raw ODB object without the signature header.
   */
  payload: () => new Field("payload"),

  /**
   * @description ASCII-armored signature header from object.
   */
  signature: () => new Field("signature"),

  /**
   * @description GitHub user corresponding to the email signing this commit.
   */

  signer: (select) =>
    new Field("signer", undefined as never, new SelectionSet(select(User))),

  /**
     * @description The state of this signature. `VALID` if signature is valid and verified by
GitHub, otherwise represents reason why signature is considered invalid.
     */
  state: () => new Field("state"),

  /**
   * @description True if the signature was made with GitHub's signing key.
   */
  wasSignedByGitHub: () => new Field("wasSignedByGitHub"),
};

export interface IUnlabeledEvent extends INode {
  __typename: "UnlabeledEvent";
  actor: IActor;
  createdAt: unknown;
  label: ILabel;
  labelable: ILabelable;
}

interface UnlabeledEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Identifies the label associated with the 'unlabeled' event.
   */

  label: <T extends Array<Selection>>(
    select: (t: LabelSelector) => T
  ) => Field<"label", never, SelectionSet<T>>;

  /**
   * @description Identifies the `Labelable` associated with the event.
   */

  labelable: <T extends Array<Selection>>(
    select: (t: LabelableSelector) => T
  ) => Field<"labelable", never, SelectionSet<T>>;
}

export const isUnlabeledEvent = (
  object: Record<string, any>
): object is Partial<IUnlabeledEvent> => {
  return object.__typename === "UnlabeledEvent";
};

export const UnlabeledEvent: UnlabeledEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the label associated with the 'unlabeled' event.
   */

  label: (select) =>
    new Field("label", undefined as never, new SelectionSet(select(Label))),

  /**
   * @description Identifies the `Labelable` associated with the event.
   */

  labelable: (select) =>
    new Field(
      "labelable",
      undefined as never,
      new SelectionSet(select(Labelable))
    ),
};

export interface IUnlinkRepositoryFromProjectPayload {
  clientMutationId: string;
  project: IProject;
  repository: IRepository;
}

interface UnlinkRepositoryFromProjectPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The linked Project.
   */

  project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;

  /**
   * @description The linked Repository.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UnlinkRepositoryFromProjectPayload: UnlinkRepositoryFromProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The linked Project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),

  /**
   * @description The linked Repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUnlockLockablePayload {
  actor: IActor;
  clientMutationId: string;
  unlockedRecord: ILockable;
}

interface UnlockLockablePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The item that was unlocked.
   */

  unlockedRecord: <T extends Array<Selection>>(
    select: (t: LockableSelector) => T
  ) => Field<"unlockedRecord", never, SelectionSet<T>>;
}

export const UnlockLockablePayload: UnlockLockablePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The item that was unlocked.
   */

  unlockedRecord: (select) =>
    new Field(
      "unlockedRecord",
      undefined as never,
      new SelectionSet(select(Lockable))
    ),
};

export interface IUnlockedEvent extends INode {
  __typename: "UnlockedEvent";
  actor: IActor;
  createdAt: unknown;
  lockable: ILockable;
}

interface UnlockedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Object that was unlocked.
   */

  lockable: <T extends Array<Selection>>(
    select: (t: LockableSelector) => T
  ) => Field<"lockable", never, SelectionSet<T>>;
}

export const isUnlockedEvent = (
  object: Record<string, any>
): object is Partial<IUnlockedEvent> => {
  return object.__typename === "UnlockedEvent";
};

export const UnlockedEvent: UnlockedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Object that was unlocked.
   */

  lockable: (select) =>
    new Field(
      "lockable",
      undefined as never,
      new SelectionSet(select(Lockable))
    ),
};

export interface IUnmarkFileAsViewedPayload {
  clientMutationId: string;
  pullRequest: IPullRequest;
}

interface UnmarkFileAsViewedPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated pull request.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const UnmarkFileAsViewedPayload: UnmarkFileAsViewedPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated pull request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IUnmarkIssueAsDuplicatePayload {
  clientMutationId: string;
  duplicate: IIssueOrPullRequest;
}

interface UnmarkIssueAsDuplicatePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue or pull request that was marked as a duplicate.
   */

  duplicate: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"duplicate", never, SelectionSet<T>>;
}

export const UnmarkIssueAsDuplicatePayload: UnmarkIssueAsDuplicatePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue or pull request that was marked as a duplicate.
   */

  duplicate: (select) =>
    new Field(
      "duplicate",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),
};

export interface IUnmarkedAsDuplicateEvent extends INode {
  __typename: "UnmarkedAsDuplicateEvent";
  actor: IActor;
  canonical: IIssueOrPullRequest;
  createdAt: unknown;
  duplicate: IIssueOrPullRequest;
  isCrossRepository: boolean;
}

interface UnmarkedAsDuplicateEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description The authoritative issue or pull request which has been duplicated by another.
   */

  canonical: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"canonical", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description The issue or pull request which has been marked as a duplicate of another.
   */

  duplicate: <T extends Array<Selection>>(
    select: (t: IssueOrPullRequestSelector) => T
  ) => Field<"duplicate", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Canonical and duplicate belong to different repositories.
   */

  isCrossRepository: () => Field<"isCrossRepository">;
}

export const isUnmarkedAsDuplicateEvent = (
  object: Record<string, any>
): object is Partial<IUnmarkedAsDuplicateEvent> => {
  return object.__typename === "UnmarkedAsDuplicateEvent";
};

export const UnmarkedAsDuplicateEvent: UnmarkedAsDuplicateEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description The authoritative issue or pull request which has been duplicated by another.
   */

  canonical: (select) =>
    new Field(
      "canonical",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description The issue or pull request which has been marked as a duplicate of another.
   */

  duplicate: (select) =>
    new Field(
      "duplicate",
      undefined as never,
      new SelectionSet(select(IssueOrPullRequest))
    ),

  id: () => new Field("id"),

  /**
   * @description Canonical and duplicate belong to different repositories.
   */
  isCrossRepository: () => new Field("isCrossRepository"),
};

export interface IUnminimizeCommentPayload {
  clientMutationId: string;
  unminimizedComment: IMinimizable;
}

interface UnminimizeCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The comment that was unminimized.
   */

  unminimizedComment: <T extends Array<Selection>>(
    select: (t: MinimizableSelector) => T
  ) => Field<"unminimizedComment", never, SelectionSet<T>>;
}

export const UnminimizeCommentPayload: UnminimizeCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The comment that was unminimized.
   */

  unminimizedComment: (select) =>
    new Field(
      "unminimizedComment",
      undefined as never,
      new SelectionSet(select(Minimizable))
    ),
};

export interface IUnpinnedEvent extends INode {
  __typename: "UnpinnedEvent";
  actor: IActor;
  createdAt: unknown;
  issue: IIssue;
}

interface UnpinnedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Identifies the issue associated with the event.
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const isUnpinnedEvent = (
  object: Record<string, any>
): object is Partial<IUnpinnedEvent> => {
  return object.__typename === "UnpinnedEvent";
};

export const UnpinnedEvent: UnpinnedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Identifies the issue associated with the event.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IUnresolveReviewThreadPayload {
  clientMutationId: string;
  thread: IPullRequestReviewThread;
}

interface UnresolveReviewThreadPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The thread to resolve.
   */

  thread: <T extends Array<Selection>>(
    select: (t: PullRequestReviewThreadSelector) => T
  ) => Field<"thread", never, SelectionSet<T>>;
}

export const UnresolveReviewThreadPayload: UnresolveReviewThreadPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The thread to resolve.
   */

  thread: (select) =>
    new Field(
      "thread",
      undefined as never,
      new SelectionSet(select(PullRequestReviewThread))
    ),
};

export interface IUnsubscribedEvent extends INode {
  __typename: "UnsubscribedEvent";
  actor: IActor;
  createdAt: unknown;
  subscribable: ISubscribable;
}

interface UnsubscribedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description Object referenced by event.
   */

  subscribable: <T extends Array<Selection>>(
    select: (t: SubscribableSelector) => T
  ) => Field<"subscribable", never, SelectionSet<T>>;
}

export const isUnsubscribedEvent = (
  object: Record<string, any>
): object is Partial<IUnsubscribedEvent> => {
  return object.__typename === "UnsubscribedEvent";
};

export const UnsubscribedEvent: UnsubscribedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description Object referenced by event.
   */

  subscribable: (select) =>
    new Field(
      "subscribable",
      undefined as never,
      new SelectionSet(select(Subscribable))
    ),
};

export interface IUpdatable {
  __typename: string;
  viewerCanUpdate: boolean;
}

interface UpdatableSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Check if the current viewer can update this object.
   */

  viewerCanUpdate: () => Field<"viewerCanUpdate">;

  on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "Issue"
      | "IssueComment"
      | "Project"
      | "PullRequest"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "Project"
        ? ProjectSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const Updatable: UpdatableSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Check if the current viewer can update this object.
   */
  viewerCanUpdate: () => new Field("viewerCanUpdate"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "Project": {
        return new InlineFragment(
          new NamedType("Project") as any,
          new SelectionSet(select(Project as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IUpdatableComment {
  __typename: string;
  viewerCannotUpdateReasons: CommentCannotUpdateReason[];
}

interface UpdatableCommentSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Reasons why the current viewer can not update this comment.
   */

  viewerCannotUpdateReasons: () => Field<"viewerCannotUpdateReasons">;

  on: <
    T extends Array<Selection>,
    F extends
      | "CommitComment"
      | "GistComment"
      | "Issue"
      | "IssueComment"
      | "PullRequest"
      | "PullRequestReview"
      | "PullRequestReviewComment"
      | "TeamDiscussion"
      | "TeamDiscussionComment"
  >(
    type: F,
    select: (
      t: F extends "CommitComment"
        ? CommitCommentSelector
        : F extends "GistComment"
        ? GistCommentSelector
        : F extends "Issue"
        ? IssueSelector
        : F extends "IssueComment"
        ? IssueCommentSelector
        : F extends "PullRequest"
        ? PullRequestSelector
        : F extends "PullRequestReview"
        ? PullRequestReviewSelector
        : F extends "PullRequestReviewComment"
        ? PullRequestReviewCommentSelector
        : F extends "TeamDiscussion"
        ? TeamDiscussionSelector
        : F extends "TeamDiscussionComment"
        ? TeamDiscussionCommentSelector
        : never
    ) => T
  ) => InlineFragment<NamedType<F, any>, SelectionSet<T>>;
}

export const UpdatableComment: UpdatableCommentSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Reasons why the current viewer can not update this comment.
   */
  viewerCannotUpdateReasons: () => new Field("viewerCannotUpdateReasons"),

  on: (type, select) => {
    switch (type) {
      case "CommitComment": {
        return new InlineFragment(
          new NamedType("CommitComment") as any,
          new SelectionSet(select(CommitComment as any))
        );
      }

      case "GistComment": {
        return new InlineFragment(
          new NamedType("GistComment") as any,
          new SelectionSet(select(GistComment as any))
        );
      }

      case "Issue": {
        return new InlineFragment(
          new NamedType("Issue") as any,
          new SelectionSet(select(Issue as any))
        );
      }

      case "IssueComment": {
        return new InlineFragment(
          new NamedType("IssueComment") as any,
          new SelectionSet(select(IssueComment as any))
        );
      }

      case "PullRequest": {
        return new InlineFragment(
          new NamedType("PullRequest") as any,
          new SelectionSet(select(PullRequest as any))
        );
      }

      case "PullRequestReview": {
        return new InlineFragment(
          new NamedType("PullRequestReview") as any,
          new SelectionSet(select(PullRequestReview as any))
        );
      }

      case "PullRequestReviewComment": {
        return new InlineFragment(
          new NamedType("PullRequestReviewComment") as any,
          new SelectionSet(select(PullRequestReviewComment as any))
        );
      }

      case "TeamDiscussion": {
        return new InlineFragment(
          new NamedType("TeamDiscussion") as any,
          new SelectionSet(select(TeamDiscussion as any))
        );
      }

      case "TeamDiscussionComment": {
        return new InlineFragment(
          new NamedType("TeamDiscussionComment") as any,
          new SelectionSet(select(TeamDiscussionComment as any))
        );
      }

      default:
        throw new Error("Unknown type!");
    }
  },
};

export interface IUpdateBranchProtectionRulePayload {
  branchProtectionRule: IBranchProtectionRule;
  clientMutationId: string;
}

interface UpdateBranchProtectionRulePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The newly created BranchProtectionRule.
   */

  branchProtectionRule: <T extends Array<Selection>>(
    select: (t: BranchProtectionRuleSelector) => T
  ) => Field<"branchProtectionRule", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const UpdateBranchProtectionRulePayload: UpdateBranchProtectionRulePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The newly created BranchProtectionRule.
   */

  branchProtectionRule: (select) =>
    new Field(
      "branchProtectionRule",
      undefined as never,
      new SelectionSet(select(BranchProtectionRule))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IUpdateCheckRunPayload {
  checkRun: ICheckRun;
  clientMutationId: string;
}

interface UpdateCheckRunPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description The updated check run.
   */

  checkRun: <T extends Array<Selection>>(
    select: (t: CheckRunSelector) => T
  ) => Field<"checkRun", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;
}

export const UpdateCheckRunPayload: UpdateCheckRunPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description The updated check run.
   */

  checkRun: (select) =>
    new Field(
      "checkRun",
      undefined as never,
      new SelectionSet(select(CheckRun))
    ),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),
};

export interface IUpdateCheckSuitePreferencesPayload {
  clientMutationId: string;
  repository: IRepository;
}

interface UpdateCheckSuitePreferencesPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated repository.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UpdateCheckSuitePreferencesPayload: UpdateCheckSuitePreferencesPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUpdateEnterpriseAdministratorRolePayload {
  clientMutationId: string;
  message: string;
}

interface UpdateEnterpriseAdministratorRolePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description A message confirming the result of changing the administrator's role.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseAdministratorRolePayload: UpdateEnterpriseAdministratorRolePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description A message confirming the result of changing the administrator's role.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated allow private repository forking setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the allow private repository forking setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayload: UpdateEnterpriseAllowPrivateRepositoryForkingSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated allow private repository forking setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the allow private repository forking setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseDefaultRepositoryPermissionSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated default repository permission setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the default repository permission setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseDefaultRepositoryPermissionSettingPayload: UpdateEnterpriseDefaultRepositoryPermissionSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated default repository permission setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the default repository permission setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can change repository visibility setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can change repository visibility setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayload: UpdateEnterpriseMembersCanChangeRepositoryVisibilitySettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can change repository visibility setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can change repository visibility setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanCreateRepositoriesSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can create repositories setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can create repositories setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanCreateRepositoriesSettingPayload: UpdateEnterpriseMembersCanCreateRepositoriesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can create repositories setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can create repositories setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanDeleteIssuesSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can delete issues setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can delete issues setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanDeleteIssuesSettingPayload: UpdateEnterpriseMembersCanDeleteIssuesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can delete issues setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can delete issues setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can delete repositories setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can delete repositories setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayload: UpdateEnterpriseMembersCanDeleteRepositoriesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can delete repositories setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can delete repositories setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can invite collaborators setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can invite collaborators setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayload: UpdateEnterpriseMembersCanInviteCollaboratorsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can invite collaborators setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can invite collaborators setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanMakePurchasesSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseMembersCanMakePurchasesSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can make purchases setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can make purchases setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanMakePurchasesSettingPayload: UpdateEnterpriseMembersCanMakePurchasesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can make purchases setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can make purchases setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can update protected branches setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can update protected branches setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayload: UpdateEnterpriseMembersCanUpdateProtectedBranchesSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can update protected branches setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can update protected branches setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated members can view dependency insights setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the members can view dependency insights setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayload: UpdateEnterpriseMembersCanViewDependencyInsightsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated members can view dependency insights setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the members can view dependency insights setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseOrganizationProjectsSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseOrganizationProjectsSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated organization projects setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the organization projects setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseOrganizationProjectsSettingPayload: UpdateEnterpriseOrganizationProjectsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated organization projects setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the organization projects setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseProfilePayload {
  clientMutationId: string;
  enterprise: IEnterprise;
}

interface UpdateEnterpriseProfilePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated enterprise.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;
}

export const UpdateEnterpriseProfilePayload: UpdateEnterpriseProfilePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated enterprise.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),
};

export interface IUpdateEnterpriseRepositoryProjectsSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseRepositoryProjectsSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated repository projects setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the repository projects setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseRepositoryProjectsSettingPayload: UpdateEnterpriseRepositoryProjectsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated repository projects setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the repository projects setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseTeamDiscussionsSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseTeamDiscussionsSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated team discussions setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the team discussions setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseTeamDiscussionsSettingPayload: UpdateEnterpriseTeamDiscussionsSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated team discussions setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the team discussions setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload {
  clientMutationId: string;
  enterprise: IEnterprise;
  message: string;
}

interface UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The enterprise with the updated two factor authentication required setting.
   */

  enterprise: <T extends Array<Selection>>(
    select: (t: EnterpriseSelector) => T
  ) => Field<"enterprise", never, SelectionSet<T>>;

  /**
   * @description A message confirming the result of updating the two factor authentication required setting.
   */

  message: () => Field<"message">;
}

export const UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayload: UpdateEnterpriseTwoFactorAuthenticationRequiredSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The enterprise with the updated two factor authentication required setting.
   */

  enterprise: (select) =>
    new Field(
      "enterprise",
      undefined as never,
      new SelectionSet(select(Enterprise))
    ),

  /**
   * @description A message confirming the result of updating the two factor authentication required setting.
   */
  message: () => new Field("message"),
};

export interface IUpdateIpAllowListEnabledSettingPayload {
  clientMutationId: string;
  owner: IIpAllowListOwner;
}

interface UpdateIpAllowListEnabledSettingPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The IP allow list owner on which the setting was updated.
   */

  owner: <T extends Array<Selection>>(
    select: (t: IpAllowListOwnerSelector) => T
  ) => Field<"owner", never, SelectionSet<T>>;
}

export const UpdateIpAllowListEnabledSettingPayload: UpdateIpAllowListEnabledSettingPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The IP allow list owner on which the setting was updated.
   */

  owner: (select) =>
    new Field(
      "owner",
      undefined as never,
      new SelectionSet(select(IpAllowListOwner))
    ),
};

export interface IUpdateIpAllowListEntryPayload {
  clientMutationId: string;
  ipAllowListEntry: IIpAllowListEntry;
}

interface UpdateIpAllowListEntryPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The IP allow list entry that was updated.
   */

  ipAllowListEntry: <T extends Array<Selection>>(
    select: (t: IpAllowListEntrySelector) => T
  ) => Field<"ipAllowListEntry", never, SelectionSet<T>>;
}

export const UpdateIpAllowListEntryPayload: UpdateIpAllowListEntryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The IP allow list entry that was updated.
   */

  ipAllowListEntry: (select) =>
    new Field(
      "ipAllowListEntry",
      undefined as never,
      new SelectionSet(select(IpAllowListEntry))
    ),
};

export interface IUpdateIssueCommentPayload {
  clientMutationId: string;
  issueComment: IIssueComment;
}

interface UpdateIssueCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated comment.
   */

  issueComment: <T extends Array<Selection>>(
    select: (t: IssueCommentSelector) => T
  ) => Field<"issueComment", never, SelectionSet<T>>;
}

export const UpdateIssueCommentPayload: UpdateIssueCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated comment.
   */

  issueComment: (select) =>
    new Field(
      "issueComment",
      undefined as never,
      new SelectionSet(select(IssueComment))
    ),
};

export interface IUpdateIssuePayload {
  actor: IActor;
  clientMutationId: string;
  issue: IIssue;
}

interface UpdateIssuePayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The issue.
   */

  issue: <T extends Array<Selection>>(
    select: (t: IssueSelector) => T
  ) => Field<"issue", never, SelectionSet<T>>;
}

export const UpdateIssuePayload: UpdateIssuePayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The issue.
   */

  issue: (select) =>
    new Field("issue", undefined as never, new SelectionSet(select(Issue))),
};

export interface IUpdateProjectCardPayload {
  clientMutationId: string;
  projectCard: IProjectCard;
}

interface UpdateProjectCardPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated ProjectCard.
   */

  projectCard: <T extends Array<Selection>>(
    select: (t: ProjectCardSelector) => T
  ) => Field<"projectCard", never, SelectionSet<T>>;
}

export const UpdateProjectCardPayload: UpdateProjectCardPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated ProjectCard.
   */

  projectCard: (select) =>
    new Field(
      "projectCard",
      undefined as never,
      new SelectionSet(select(ProjectCard))
    ),
};

export interface IUpdateProjectColumnPayload {
  clientMutationId: string;
  projectColumn: IProjectColumn;
}

interface UpdateProjectColumnPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated project column.
   */

  projectColumn: <T extends Array<Selection>>(
    select: (t: ProjectColumnSelector) => T
  ) => Field<"projectColumn", never, SelectionSet<T>>;
}

export const UpdateProjectColumnPayload: UpdateProjectColumnPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated project column.
   */

  projectColumn: (select) =>
    new Field(
      "projectColumn",
      undefined as never,
      new SelectionSet(select(ProjectColumn))
    ),
};

export interface IUpdateProjectPayload {
  clientMutationId: string;
  project: IProject;
}

interface UpdateProjectPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated project.
   */

  project: <T extends Array<Selection>>(
    select: (t: ProjectSelector) => T
  ) => Field<"project", never, SelectionSet<T>>;
}

export const UpdateProjectPayload: UpdateProjectPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated project.
   */

  project: (select) =>
    new Field("project", undefined as never, new SelectionSet(select(Project))),
};

export interface IUpdatePullRequestPayload {
  actor: IActor;
  clientMutationId: string;
  pullRequest: IPullRequest;
}

interface UpdatePullRequestPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated pull request.
   */

  pullRequest: <T extends Array<Selection>>(
    select: (t: PullRequestSelector) => T
  ) => Field<"pullRequest", never, SelectionSet<T>>;
}

export const UpdatePullRequestPayload: UpdatePullRequestPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated pull request.
   */

  pullRequest: (select) =>
    new Field(
      "pullRequest",
      undefined as never,
      new SelectionSet(select(PullRequest))
    ),
};

export interface IUpdatePullRequestReviewCommentPayload {
  clientMutationId: string;
  pullRequestReviewComment: IPullRequestReviewComment;
}

interface UpdatePullRequestReviewCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated comment.
   */

  pullRequestReviewComment: <T extends Array<Selection>>(
    select: (t: PullRequestReviewCommentSelector) => T
  ) => Field<"pullRequestReviewComment", never, SelectionSet<T>>;
}

export const UpdatePullRequestReviewCommentPayload: UpdatePullRequestReviewCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated comment.
   */

  pullRequestReviewComment: (select) =>
    new Field(
      "pullRequestReviewComment",
      undefined as never,
      new SelectionSet(select(PullRequestReviewComment))
    ),
};

export interface IUpdatePullRequestReviewPayload {
  clientMutationId: string;
  pullRequestReview: IPullRequestReview;
}

interface UpdatePullRequestReviewPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated pull request review.
   */

  pullRequestReview: <T extends Array<Selection>>(
    select: (t: PullRequestReviewSelector) => T
  ) => Field<"pullRequestReview", never, SelectionSet<T>>;
}

export const UpdatePullRequestReviewPayload: UpdatePullRequestReviewPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated pull request review.
   */

  pullRequestReview: (select) =>
    new Field(
      "pullRequestReview",
      undefined as never,
      new SelectionSet(select(PullRequestReview))
    ),
};

export interface IUpdateRefPayload {
  clientMutationId: string;
  ref: IRef;
}

interface UpdateRefPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated Ref.
   */

  ref: <T extends Array<Selection>>(
    select: (t: RefSelector) => T
  ) => Field<"ref", never, SelectionSet<T>>;
}

export const UpdateRefPayload: UpdateRefPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated Ref.
   */

  ref: (select) =>
    new Field("ref", undefined as never, new SelectionSet(select(Ref))),
};

export interface IUpdateRepositoryPayload {
  clientMutationId: string;
  repository: IRepository;
}

interface UpdateRepositoryPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated repository.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UpdateRepositoryPayload: UpdateRepositoryPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUpdateSubscriptionPayload {
  clientMutationId: string;
  subscribable: ISubscribable;
}

interface UpdateSubscriptionPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The input subscribable entity.
   */

  subscribable: <T extends Array<Selection>>(
    select: (t: SubscribableSelector) => T
  ) => Field<"subscribable", never, SelectionSet<T>>;
}

export const UpdateSubscriptionPayload: UpdateSubscriptionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The input subscribable entity.
   */

  subscribable: (select) =>
    new Field(
      "subscribable",
      undefined as never,
      new SelectionSet(select(Subscribable))
    ),
};

export interface IUpdateTeamDiscussionCommentPayload {
  clientMutationId: string;
  teamDiscussionComment: ITeamDiscussionComment;
}

interface UpdateTeamDiscussionCommentPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated comment.
   */

  teamDiscussionComment: <T extends Array<Selection>>(
    select: (t: TeamDiscussionCommentSelector) => T
  ) => Field<"teamDiscussionComment", never, SelectionSet<T>>;
}

export const UpdateTeamDiscussionCommentPayload: UpdateTeamDiscussionCommentPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated comment.
   */

  teamDiscussionComment: (select) =>
    new Field(
      "teamDiscussionComment",
      undefined as never,
      new SelectionSet(select(TeamDiscussionComment))
    ),
};

export interface IUpdateTeamDiscussionPayload {
  clientMutationId: string;
  teamDiscussion: ITeamDiscussion;
}

interface UpdateTeamDiscussionPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description The updated discussion.
   */

  teamDiscussion: <T extends Array<Selection>>(
    select: (t: TeamDiscussionSelector) => T
  ) => Field<"teamDiscussion", never, SelectionSet<T>>;
}

export const UpdateTeamDiscussionPayload: UpdateTeamDiscussionPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description The updated discussion.
   */

  teamDiscussion: (select) =>
    new Field(
      "teamDiscussion",
      undefined as never,
      new SelectionSet(select(TeamDiscussion))
    ),
};

export interface IUpdateTopicsPayload {
  clientMutationId: string;
  invalidTopicNames: string[];
  repository: IRepository;
}

interface UpdateTopicsPayloadSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A unique identifier for the client performing the mutation.
   */

  clientMutationId: () => Field<"clientMutationId">;

  /**
   * @description Names of the provided topics that are not valid.
   */

  invalidTopicNames: () => Field<"invalidTopicNames">;

  /**
   * @description The updated repository.
   */

  repository: <T extends Array<Selection>>(
    select: (t: RepositorySelector) => T
  ) => Field<"repository", never, SelectionSet<T>>;
}

export const UpdateTopicsPayload: UpdateTopicsPayloadSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A unique identifier for the client performing the mutation.
   */
  clientMutationId: () => new Field("clientMutationId"),

  /**
   * @description Names of the provided topics that are not valid.
   */
  invalidTopicNames: () => new Field("invalidTopicNames"),

  /**
   * @description The updated repository.
   */

  repository: (select) =>
    new Field(
      "repository",
      undefined as never,
      new SelectionSet(select(Repository))
    ),
};

export interface IUser
  extends IActor,
    INode,
    IPackageOwner,
    IProfileOwner,
    IProjectOwner,
    IRepositoryOwner,
    ISponsorable,
    IUniformResourceLocatable {
  __typename: "User";
  bio: string;
  bioHTML: unknown;
  commitComments: ICommitCommentConnection;
  company: string;
  companyHTML: unknown;
  contributionsCollection: IContributionsCollection;
  createdAt: unknown;
  databaseId: number;
  followers: IFollowerConnection;
  following: IFollowingConnection;
  gist: IGist;
  gistComments: IGistCommentConnection;
  gists: IGistConnection;
  hovercard: IHovercard;
  interactionAbility: IRepositoryInteractionAbility;
  isBountyHunter: boolean;
  isCampusExpert: boolean;
  isDeveloperProgramMember: boolean;
  isEmployee: boolean;
  isHireable: boolean;
  isSiteAdmin: boolean;
  isViewer: boolean;
  issueComments: IIssueCommentConnection;
  issues: IIssueConnection;
  organization: IOrganization;
  organizationVerifiedDomainEmails: string[];
  organizations: IOrganizationConnection;
  publicKeys: IPublicKeyConnection;
  pullRequests: IPullRequestConnection;
  repositoriesContributedTo: IRepositoryConnection;
  savedReplies: ISavedReplyConnection;
  starredRepositories: IStarredRepositoryConnection;
  status: IUserStatus;
  topRepositories: IRepositoryConnection;
  twitterUsername: string;
  updatedAt: unknown;
  viewerCanFollow: boolean;
  viewerIsFollowing: boolean;
  watching: IRepositoryConnection;
}

interface UserSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */

  anyPinnableItems: (variables: {
    type: unknown;
  }) => Field<"anyPinnableItems", [/* @todo */]>;

  /**
   * @description A URL pointing to the user's public avatar.
   */

  avatarUrl: (variables: {
    size: unknown;
  }) => Field<"avatarUrl", [/* @todo */]>;

  /**
   * @description The user's public profile bio.
   */

  bio: () => Field<"bio">;

  /**
   * @description The user's public profile bio as HTML.
   */

  bioHTML: () => Field<"bioHTML">;

  /**
   * @description A list of commit comments made by this user.
   */

  commitComments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: CommitCommentConnectionSelector) => T
  ) => Field<
    "commitComments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The user's public profile company.
   */

  company: () => Field<"company">;

  /**
   * @description The user's public profile company as HTML.
   */

  companyHTML: () => Field<"companyHTML">;

  /**
   * @description The collection of contributions this user has made to different repositories.
   */

  contributionsCollection: <T extends Array<Selection>>(
    variables: {
      from?: Variable<"from"> | unknown;
      organizationID?: Variable<"organizationID"> | string;
      to?: Variable<"to"> | unknown;
    },
    select: (t: ContributionsCollectionSelector) => T
  ) => Field<
    "contributionsCollection",
    [
      Argument<"from", Variable<"from"> | unknown>,
      Argument<"organizationID", Variable<"organizationID"> | string>,
      Argument<"to", Variable<"to"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the primary key from the database.
   */

  databaseId: () => Field<"databaseId">;

  /**
   * @description The user's publicly visible profile email.
   */

  email: () => Field<"email">;

  /**
   * @description A list of users the given user is followed by.
   */

  followers: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: FollowerConnectionSelector) => T
  ) => Field<
    "followers",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of users the given user is following.
   */

  following: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: FollowingConnectionSelector) => T
  ) => Field<
    "following",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find gist by repo name.
   */

  gist: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: GistSelector) => T
  ) => Field<
    "gist",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description A list of gist comments made by this user.
   */

  gistComments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: GistCommentConnectionSelector) => T
  ) => Field<
    "gistComments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of the Gists the user has created.
   */

  gists: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | GistOrder;
      privacy?: Variable<"privacy"> | GistPrivacy;
    },
    select: (t: GistConnectionSelector) => T
  ) => Field<
    "gists",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | GistOrder>,
      Argument<"privacy", Variable<"privacy"> | GistPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */

  hasSponsorsListing: () => Field<"hasSponsorsListing">;

  /**
   * @description The hovercard information for this user in a given context
   */

  hovercard: <T extends Array<Selection>>(
    variables: { primarySubjectId?: Variable<"primarySubjectId"> | string },
    select: (t: HovercardSelector) => T
  ) => Field<
    "hovercard",
    [Argument<"primarySubjectId", Variable<"primarySubjectId"> | string>],
    SelectionSet<T>
  >;

  id: () => Field<"id">;

  /**
   * @description The interaction ability settings for this user.
   */

  interactionAbility: <T extends Array<Selection>>(
    select: (t: RepositoryInteractionAbilitySelector) => T
  ) => Field<"interactionAbility", never, SelectionSet<T>>;

  /**
   * @description Whether or not this user is a participant in the GitHub Security Bug Bounty.
   */

  isBountyHunter: () => Field<"isBountyHunter">;

  /**
   * @description Whether or not this user is a participant in the GitHub Campus Experts Program.
   */

  isCampusExpert: () => Field<"isCampusExpert">;

  /**
   * @description Whether or not this user is a GitHub Developer Program member.
   */

  isDeveloperProgramMember: () => Field<"isDeveloperProgramMember">;

  /**
   * @description Whether or not this user is a GitHub employee.
   */

  isEmployee: () => Field<"isEmployee">;

  /**
   * @description Whether or not the user has marked themselves as for hire.
   */

  isHireable: () => Field<"isHireable">;

  /**
   * @description Whether or not this user is a site administrator.
   */

  isSiteAdmin: () => Field<"isSiteAdmin">;

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */

  isSponsoringViewer: () => Field<"isSponsoringViewer">;

  /**
   * @description Whether or not this user is the viewing user.
   */

  isViewer: () => Field<"isViewer">;

  /**
   * @description A list of issue comments made by this user.
   */

  issueComments: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueCommentOrder;
    },
    select: (t: IssueCommentConnectionSelector) => T
  ) => Field<
    "issueComments",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueCommentOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of issues associated with this user.
   */

  issues: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      filterBy?: Variable<"filterBy"> | IssueFilters;
      first?: Variable<"first"> | number;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | IssueState;
    },
    select: (t: IssueConnectionSelector) => T
  ) => Field<
    "issues",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"filterBy", Variable<"filterBy"> | IssueFilters>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | IssueState>
    ],
    SelectionSet<T>
  >;

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  itemShowcase: <T extends Array<Selection>>(
    select: (t: ProfileItemShowcaseSelector) => T
  ) => Field<"itemShowcase", never, SelectionSet<T>>;

  /**
   * @description The user's public profile location.
   */

  location: () => Field<"location">;

  /**
   * @description The username used to login.
   */

  login: () => Field<"login">;

  /**
   * @description The user's public profile name.
   */

  name: () => Field<"name">;

  /**
   * @description Find an organization by its login that the user belongs to.
   */

  organization: <T extends Array<Selection>>(
    variables: { login?: Variable<"login"> | string },
    select: (t: OrganizationSelector) => T
  ) => Field<
    "organization",
    [Argument<"login", Variable<"login"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description Verified email addresses that match verified domains for a specified organization the user is a member of.
   */

  organizationVerifiedDomainEmails: (variables: {
    login: unknown;
  }) => Field<"organizationVerifiedDomainEmails", [/* @todo */]>;

  /**
   * @description A list of organizations the user belongs to.
   */

  organizations: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: OrganizationConnectionSelector) => T
  ) => Field<
    "organizations",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of packages under the owner.
   */

  packages: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      names?: Variable<"names"> | string;
      orderBy?: Variable<"orderBy"> | PackageOrder;
      packageType?: Variable<"packageType"> | PackageType;
      repositoryId?: Variable<"repositoryId"> | string;
    },
    select: (t: PackageConnectionSelector) => T
  ) => Field<
    "packages",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"names", Variable<"names"> | string>,
      Argument<"orderBy", Variable<"orderBy"> | PackageOrder>,
      Argument<"packageType", Variable<"packageType"> | PackageType>,
      Argument<"repositoryId", Variable<"repositoryId"> | string>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  pinnableItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnableItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  pinnedItems: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      types?: Variable<"types"> | PinnableItemType;
    },
    select: (t: PinnableItemConnectionSelector) => T
  ) => Field<
    "pinnedItems",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"types", Variable<"types"> | PinnableItemType>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */

  pinnedItemsRemaining: () => Field<"pinnedItemsRemaining">;

  /**
   * @description Find project by number.
   */

  project: <T extends Array<Selection>>(
    variables: { number?: Variable<"number"> | number },
    select: (t: ProjectSelector) => T
  ) => Field<
    "project",
    [Argument<"number", Variable<"number"> | number>],
    SelectionSet<T>
  >;

  /**
   * @description A list of projects under the owner.
   */

  projects: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | ProjectOrder;
      search?: Variable<"search"> | string;
      states?: Variable<"states"> | ProjectState;
    },
    select: (t: ProjectConnectionSelector) => T
  ) => Field<
    "projects",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | ProjectOrder>,
      Argument<"search", Variable<"search"> | string>,
      Argument<"states", Variable<"states"> | ProjectState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path listing user's projects
   */

  projectsResourcePath: () => Field<"projectsResourcePath">;

  /**
   * @description The HTTP URL listing user's projects
   */

  projectsUrl: () => Field<"projectsUrl">;

  /**
   * @description A list of public keys associated with this user.
   */

  publicKeys: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
    },
    select: (t: PublicKeyConnectionSelector) => T
  ) => Field<
    "publicKeys",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of pull requests associated with this user.
   */

  pullRequests: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      baseRefName?: Variable<"baseRefName"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      headRefName?: Variable<"headRefName"> | string;
      labels?: Variable<"labels"> | string;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | IssueOrder;
      states?: Variable<"states"> | PullRequestState;
    },
    select: (t: PullRequestConnectionSelector) => T
  ) => Field<
    "pullRequests",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"baseRefName", Variable<"baseRefName"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"headRefName", Variable<"headRefName"> | string>,
      Argument<"labels", Variable<"labels"> | string>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | IssueOrder>,
      Argument<"states", Variable<"states"> | PullRequestState>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories that the user owns.
   */

  repositories: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isFork?: Variable<"isFork"> | boolean;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "repositories",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isFork", Variable<"isFork"> | boolean>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A list of repositories that the user recently contributed to.
   */

  repositoriesContributedTo: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      contributionTypes?:
        | Variable<"contributionTypes">
        | RepositoryContributionType;
      first?: Variable<"first"> | number;
      includeUserRepositories?: Variable<"includeUserRepositories"> | boolean;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "repositoriesContributedTo",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<
        "contributionTypes",
        Variable<"contributionTypes"> | RepositoryContributionType
      >,
      Argument<"first", Variable<"first"> | number>,
      Argument<
        "includeUserRepositories",
        Variable<"includeUserRepositories"> | boolean
      >,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Find Repository.
   */

  repository: <T extends Array<Selection>>(
    variables: { name?: Variable<"name"> | string },
    select: (t: RepositorySelector) => T
  ) => Field<
    "repository",
    [Argument<"name", Variable<"name"> | string>],
    SelectionSet<T>
  >;

  /**
   * @description The HTTP path for this user
   */

  resourcePath: () => Field<"resourcePath">;

  /**
   * @description Replies this user has saved
   */

  savedReplies: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SavedReplyOrder;
    },
    select: (t: SavedReplyConnectionSelector) => T
  ) => Field<
    "savedReplies",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SavedReplyOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  sponsorsListing: <T extends Array<Selection>>(
    select: (t: SponsorsListingSelector) => T
  ) => Field<"sponsorsListing", never, SelectionSet<T>>;

  /**
   * @description This object's sponsorships as the maintainer.
   */

  sponsorshipsAsMaintainer: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      includePrivate?: Variable<"includePrivate"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsMaintainer",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"includePrivate", Variable<"includePrivate"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description This object's sponsorships as the sponsor.
   */

  sponsorshipsAsSponsor: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | SponsorshipOrder;
    },
    select: (t: SponsorshipConnectionSelector) => T
  ) => Field<
    "sponsorshipsAsSponsor",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | SponsorshipOrder>
    ],
    SelectionSet<T>
  >;

  /**
   * @description Repositories the user has starred.
   */

  starredRepositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | StarOrder;
      ownedByViewer?: Variable<"ownedByViewer"> | boolean;
    },
    select: (t: StarredRepositoryConnectionSelector) => T
  ) => Field<
    "starredRepositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | StarOrder>,
      Argument<"ownedByViewer", Variable<"ownedByViewer"> | boolean>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The user's description of what they're currently doing.
   */

  status: <T extends Array<Selection>>(
    select: (t: UserStatusSelector) => T
  ) => Field<"status", never, SelectionSet<T>>;

  /**
   * @description Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created
   */

  topRepositories: <T extends Array<Selection>>(
    variables: {
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      since?: Variable<"since"> | unknown;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "topRepositories",
    [
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<"since", Variable<"since"> | unknown>
    ],
    SelectionSet<T>
  >;

  /**
   * @description The user's Twitter username.
   */

  twitterUsername: () => Field<"twitterUsername">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The HTTP URL for this user
   */

  url: () => Field<"url">;

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */

  viewerCanChangePinnedItems: () => Field<"viewerCanChangePinnedItems">;

  /**
   * @description Can the current viewer create new projects on this owner.
   */

  viewerCanCreateProjects: () => Field<"viewerCanCreateProjects">;

  /**
   * @description Whether or not the viewer is able to follow the user.
   */

  viewerCanFollow: () => Field<"viewerCanFollow">;

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */

  viewerCanSponsor: () => Field<"viewerCanSponsor">;

  /**
   * @description Whether or not this user is followed by the viewer.
   */

  viewerIsFollowing: () => Field<"viewerIsFollowing">;

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */

  viewerIsSponsoring: () => Field<"viewerIsSponsoring">;

  /**
   * @description A list of repositories the given user is watching.
   */

  watching: <T extends Array<Selection>>(
    variables: {
      affiliations?: Variable<"affiliations"> | RepositoryAffiliation;
      after?: Variable<"after"> | string;
      before?: Variable<"before"> | string;
      first?: Variable<"first"> | number;
      isLocked?: Variable<"isLocked"> | boolean;
      last?: Variable<"last"> | number;
      orderBy?: Variable<"orderBy"> | RepositoryOrder;
      ownerAffiliations?: Variable<"ownerAffiliations"> | RepositoryAffiliation;
      privacy?: Variable<"privacy"> | RepositoryPrivacy;
    },
    select: (t: RepositoryConnectionSelector) => T
  ) => Field<
    "watching",
    [
      Argument<
        "affiliations",
        Variable<"affiliations"> | RepositoryAffiliation
      >,
      Argument<"after", Variable<"after"> | string>,
      Argument<"before", Variable<"before"> | string>,
      Argument<"first", Variable<"first"> | number>,
      Argument<"isLocked", Variable<"isLocked"> | boolean>,
      Argument<"last", Variable<"last"> | number>,
      Argument<"orderBy", Variable<"orderBy"> | RepositoryOrder>,
      Argument<
        "ownerAffiliations",
        Variable<"ownerAffiliations"> | RepositoryAffiliation
      >,
      Argument<"privacy", Variable<"privacy"> | RepositoryPrivacy>
    ],
    SelectionSet<T>
  >;

  /**
   * @description A URL pointing to the user's public website/blog.
   */

  websiteUrl: () => Field<"websiteUrl">;
}

export const isUser = (
  object: Record<string, any>
): object is Partial<IUser> => {
  return object.__typename === "User";
};

export const User: UserSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Determine if this repository owner has any items that can be pinned to their profile.
   */
  anyPinnableItems: (variables) => new Field("anyPinnableItems"),

  /**
   * @description A URL pointing to the user's public avatar.
   */
  avatarUrl: (variables) => new Field("avatarUrl"),

  /**
   * @description The user's public profile bio.
   */
  bio: () => new Field("bio"),

  /**
   * @description The user's public profile bio as HTML.
   */
  bioHTML: () => new Field("bioHTML"),

  /**
   * @description A list of commit comments made by this user.
   */

  commitComments: (variables, select) =>
    new Field(
      "commitComments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(CommitCommentConnection))
    ),

  /**
   * @description The user's public profile company.
   */
  company: () => new Field("company"),

  /**
   * @description The user's public profile company as HTML.
   */
  companyHTML: () => new Field("companyHTML"),

  /**
   * @description The collection of contributions this user has made to different repositories.
   */

  contributionsCollection: (variables, select) =>
    new Field(
      "contributionsCollection",
      [
        new Argument("from", variables.from),
        new Argument("organizationID", variables.organizationID),
        new Argument("to", variables.to),
      ],
      new SelectionSet(select(ContributionsCollection))
    ),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the primary key from the database.
   */
  databaseId: () => new Field("databaseId"),

  /**
   * @description The user's publicly visible profile email.
   */
  email: () => new Field("email"),

  /**
   * @description A list of users the given user is followed by.
   */

  followers: (variables, select) =>
    new Field(
      "followers",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(FollowerConnection))
    ),

  /**
   * @description A list of users the given user is following.
   */

  following: (variables, select) =>
    new Field(
      "following",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(FollowingConnection))
    ),

  /**
   * @description Find gist by repo name.
   */

  gist: (variables, select) =>
    new Field(
      "gist",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Gist))
    ),

  /**
   * @description A list of gist comments made by this user.
   */

  gistComments: (variables, select) =>
    new Field(
      "gistComments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(GistCommentConnection))
    ),

  /**
   * @description A list of the Gists the user has created.
   */

  gists: (variables, select) =>
    new Field(
      "gists",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("privacy", variables.privacy, GistPrivacy),
      ],
      new SelectionSet(select(GistConnection))
    ),

  /**
   * @description True if this user/organization has a GitHub Sponsors listing.
   */
  hasSponsorsListing: () => new Field("hasSponsorsListing"),

  /**
   * @description The hovercard information for this user in a given context
   */

  hovercard: (variables, select) =>
    new Field(
      "hovercard",
      [new Argument("primarySubjectId", variables.primarySubjectId)],
      new SelectionSet(select(Hovercard))
    ),

  id: () => new Field("id"),

  /**
   * @description The interaction ability settings for this user.
   */

  interactionAbility: (select) =>
    new Field(
      "interactionAbility",
      undefined as never,
      new SelectionSet(select(RepositoryInteractionAbility))
    ),

  /**
   * @description Whether or not this user is a participant in the GitHub Security Bug Bounty.
   */
  isBountyHunter: () => new Field("isBountyHunter"),

  /**
   * @description Whether or not this user is a participant in the GitHub Campus Experts Program.
   */
  isCampusExpert: () => new Field("isCampusExpert"),

  /**
   * @description Whether or not this user is a GitHub Developer Program member.
   */
  isDeveloperProgramMember: () => new Field("isDeveloperProgramMember"),

  /**
   * @description Whether or not this user is a GitHub employee.
   */
  isEmployee: () => new Field("isEmployee"),

  /**
   * @description Whether or not the user has marked themselves as for hire.
   */
  isHireable: () => new Field("isHireable"),

  /**
   * @description Whether or not this user is a site administrator.
   */
  isSiteAdmin: () => new Field("isSiteAdmin"),

  /**
   * @description True if the viewer is sponsored by this user/organization.
   */
  isSponsoringViewer: () => new Field("isSponsoringViewer"),

  /**
   * @description Whether or not this user is the viewing user.
   */
  isViewer: () => new Field("isViewer"),

  /**
   * @description A list of issue comments made by this user.
   */

  issueComments: (variables, select) =>
    new Field(
      "issueComments",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(IssueCommentConnection))
    ),

  /**
   * @description A list of issues associated with this user.
   */

  issues: (variables, select) =>
    new Field(
      "issues",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("filterBy", variables.filterBy),
        new Argument("first", variables.first),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, IssueState),
      ],
      new SelectionSet(select(IssueConnection))
    ),

  /**
     * @description Showcases a selection of repositories and gists that the profile owner has
either curated or that have been selected automatically based on popularity.
     */

  itemShowcase: (select) =>
    new Field(
      "itemShowcase",
      undefined as never,
      new SelectionSet(select(ProfileItemShowcase))
    ),

  /**
   * @description The user's public profile location.
   */
  location: () => new Field("location"),

  /**
   * @description The username used to login.
   */
  login: () => new Field("login"),

  /**
   * @description The user's public profile name.
   */
  name: () => new Field("name"),

  /**
   * @description Find an organization by its login that the user belongs to.
   */

  organization: (variables, select) =>
    new Field(
      "organization",
      [new Argument("login", variables.login)],
      new SelectionSet(select(Organization))
    ),

  /**
   * @description Verified email addresses that match verified domains for a specified organization the user is a member of.
   */
  organizationVerifiedDomainEmails: (variables) =>
    new Field("organizationVerifiedDomainEmails"),

  /**
   * @description A list of organizations the user belongs to.
   */

  organizations: (variables, select) =>
    new Field(
      "organizations",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(OrganizationConnection))
    ),

  /**
   * @description A list of packages under the owner.
   */

  packages: (variables, select) =>
    new Field(
      "packages",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("names", variables.names),
        new Argument("orderBy", variables.orderBy),
        new Argument("packageType", variables.packageType, PackageType),
        new Argument("repositoryId", variables.repositoryId),
      ],
      new SelectionSet(select(PackageConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner can pin to their profile.
   */

  pinnableItems: (variables, select) =>
    new Field(
      "pinnableItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description A list of repositories and gists this profile owner has pinned to their profile
   */

  pinnedItems: (variables, select) =>
    new Field(
      "pinnedItems",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("types", variables.types, PinnableItemType),
      ],
      new SelectionSet(select(PinnableItemConnection))
    ),

  /**
   * @description Returns how many more items this profile owner can pin to their profile.
   */
  pinnedItemsRemaining: () => new Field("pinnedItemsRemaining"),

  /**
   * @description Find project by number.
   */

  project: (variables, select) =>
    new Field(
      "project",
      [new Argument("number", variables.number)],
      new SelectionSet(select(Project))
    ),

  /**
   * @description A list of projects under the owner.
   */

  projects: (variables, select) =>
    new Field(
      "projects",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("search", variables.search),
        new Argument("states", variables.states, ProjectState),
      ],
      new SelectionSet(select(ProjectConnection))
    ),

  /**
   * @description The HTTP path listing user's projects
   */
  projectsResourcePath: () => new Field("projectsResourcePath"),

  /**
   * @description The HTTP URL listing user's projects
   */
  projectsUrl: () => new Field("projectsUrl"),

  /**
   * @description A list of public keys associated with this user.
   */

  publicKeys: (variables, select) =>
    new Field(
      "publicKeys",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
      ],
      new SelectionSet(select(PublicKeyConnection))
    ),

  /**
   * @description A list of pull requests associated with this user.
   */

  pullRequests: (variables, select) =>
    new Field(
      "pullRequests",
      [
        new Argument("after", variables.after),
        new Argument("baseRefName", variables.baseRefName),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("headRefName", variables.headRefName),
        new Argument("labels", variables.labels),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("states", variables.states, PullRequestState),
      ],
      new SelectionSet(select(PullRequestConnection))
    ),

  /**
   * @description A list of repositories that the user owns.
   */

  repositories: (variables, select) =>
    new Field(
      "repositories",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isFork", variables.isFork),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description A list of repositories that the user recently contributed to.
   */

  repositoriesContributedTo: (variables, select) =>
    new Field(
      "repositoriesContributedTo",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument(
          "contributionTypes",
          variables.contributionTypes,
          RepositoryContributionType
        ),
        new Argument("first", variables.first),
        new Argument(
          "includeUserRepositories",
          variables.includeUserRepositories
        ),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description Find Repository.
   */

  repository: (variables, select) =>
    new Field(
      "repository",
      [new Argument("name", variables.name)],
      new SelectionSet(select(Repository))
    ),

  /**
   * @description The HTTP path for this user
   */
  resourcePath: () => new Field("resourcePath"),

  /**
   * @description Replies this user has saved
   */

  savedReplies: (variables, select) =>
    new Field(
      "savedReplies",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SavedReplyConnection))
    ),

  /**
   * @description The GitHub Sponsors listing for this user or organization.
   */

  sponsorsListing: (select) =>
    new Field(
      "sponsorsListing",
      undefined as never,
      new SelectionSet(select(SponsorsListing))
    ),

  /**
   * @description This object's sponsorships as the maintainer.
   */

  sponsorshipsAsMaintainer: (variables, select) =>
    new Field(
      "sponsorshipsAsMaintainer",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("includePrivate", variables.includePrivate),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description This object's sponsorships as the sponsor.
   */

  sponsorshipsAsSponsor: (variables, select) =>
    new Field(
      "sponsorshipsAsSponsor",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
      ],
      new SelectionSet(select(SponsorshipConnection))
    ),

  /**
   * @description Repositories the user has starred.
   */

  starredRepositories: (variables, select) =>
    new Field(
      "starredRepositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("ownedByViewer", variables.ownedByViewer),
      ],
      new SelectionSet(select(StarredRepositoryConnection))
    ),

  /**
   * @description The user's description of what they're currently doing.
   */

  status: (select) =>
    new Field(
      "status",
      undefined as never,
      new SelectionSet(select(UserStatus))
    ),

  /**
   * @description Repositories the user has contributed to, ordered by contribution rank, plus repositories the user has created
   */

  topRepositories: (variables, select) =>
    new Field(
      "topRepositories",
      [
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument("since", variables.since),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description The user's Twitter username.
   */
  twitterUsername: () => new Field("twitterUsername"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The HTTP URL for this user
   */
  url: () => new Field("url"),

  /**
   * @description Can the viewer pin repositories and gists to the profile?
   */
  viewerCanChangePinnedItems: () => new Field("viewerCanChangePinnedItems"),

  /**
   * @description Can the current viewer create new projects on this owner.
   */
  viewerCanCreateProjects: () => new Field("viewerCanCreateProjects"),

  /**
   * @description Whether or not the viewer is able to follow the user.
   */
  viewerCanFollow: () => new Field("viewerCanFollow"),

  /**
   * @description Whether or not the viewer is able to sponsor this user/organization.
   */
  viewerCanSponsor: () => new Field("viewerCanSponsor"),

  /**
   * @description Whether or not this user is followed by the viewer.
   */
  viewerIsFollowing: () => new Field("viewerIsFollowing"),

  /**
   * @description True if the viewer is sponsoring this user/organization.
   */
  viewerIsSponsoring: () => new Field("viewerIsSponsoring"),

  /**
   * @description A list of repositories the given user is watching.
   */

  watching: (variables, select) =>
    new Field(
      "watching",
      [
        new Argument(
          "affiliations",
          variables.affiliations,
          RepositoryAffiliation
        ),
        new Argument("after", variables.after),
        new Argument("before", variables.before),
        new Argument("first", variables.first),
        new Argument("isLocked", variables.isLocked),
        new Argument("last", variables.last),
        new Argument("orderBy", variables.orderBy),
        new Argument(
          "ownerAffiliations",
          variables.ownerAffiliations,
          RepositoryAffiliation
        ),
        new Argument("privacy", variables.privacy, RepositoryPrivacy),
      ],
      new SelectionSet(select(RepositoryConnection))
    ),

  /**
   * @description A URL pointing to the user's public website/blog.
   */
  websiteUrl: () => new Field("websiteUrl"),
};

export interface IUserBlockedEvent extends INode {
  __typename: "UserBlockedEvent";
  actor: IActor;
  blockDuration: UserBlockDuration;
  createdAt: unknown;
  subject: IUser;
}

interface UserBlockedEventSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"actor", never, SelectionSet<T>>;

  /**
   * @description Number of days that the user was blocked for.
   */

  blockDuration: () => Field<"blockDuration">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  id: () => Field<"id">;

  /**
   * @description The user who was blocked.
   */

  subject: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"subject", never, SelectionSet<T>>;
}

export const isUserBlockedEvent = (
  object: Record<string, any>
): object is Partial<IUserBlockedEvent> => {
  return object.__typename === "UserBlockedEvent";
};

export const UserBlockedEvent: UserBlockedEventSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the actor who performed the event.
   */

  actor: (select) =>
    new Field("actor", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description Number of days that the user was blocked for.
   */
  blockDuration: () => new Field("blockDuration"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),
  id: () => new Field("id"),

  /**
   * @description The user who was blocked.
   */

  subject: (select) =>
    new Field("subject", undefined as never, new SelectionSet(select(User))),
};

export interface IUserConnection {
  edges: IUserEdge[];
  nodes: IUser[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface UserConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: UserEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const UserConnection: UserConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field("edges", undefined as never, new SelectionSet(select(UserEdge))),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field("nodes", undefined as never, new SelectionSet(select(User))),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IUserContentEdit extends INode {
  __typename: "UserContentEdit";
  createdAt: unknown;
  deletedAt: unknown;
  deletedBy: IActor;
  diff: string;
  editedAt: unknown;
  editor: IActor;
  updatedAt: unknown;
}

interface UserContentEditSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description Identifies the date and time when the object was deleted.
   */

  deletedAt: () => Field<"deletedAt">;

  /**
   * @description The actor who deleted this content
   */

  deletedBy: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"deletedBy", never, SelectionSet<T>>;

  /**
   * @description A summary of the changes for this edit
   */

  diff: () => Field<"diff">;

  /**
   * @description When this content was edited
   */

  editedAt: () => Field<"editedAt">;

  /**
   * @description The actor who edited this content
   */

  editor: <T extends Array<Selection>>(
    select: (t: ActorSelector) => T
  ) => Field<"editor", never, SelectionSet<T>>;

  id: () => Field<"id">;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;
}

export const isUserContentEdit = (
  object: Record<string, any>
): object is Partial<IUserContentEdit> => {
  return object.__typename === "UserContentEdit";
};

export const UserContentEdit: UserContentEditSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description Identifies the date and time when the object was deleted.
   */
  deletedAt: () => new Field("deletedAt"),

  /**
   * @description The actor who deleted this content
   */

  deletedBy: (select) =>
    new Field("deletedBy", undefined as never, new SelectionSet(select(Actor))),

  /**
   * @description A summary of the changes for this edit
   */
  diff: () => new Field("diff"),

  /**
   * @description When this content was edited
   */
  editedAt: () => new Field("editedAt"),

  /**
   * @description The actor who edited this content
   */

  editor: (select) =>
    new Field("editor", undefined as never, new SelectionSet(select(Actor))),

  id: () => new Field("id"),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),
};

export interface IUserContentEditConnection {
  edges: IUserContentEditEdge[];
  nodes: IUserContentEdit[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface UserContentEditConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: UserContentEditEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserContentEditSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const UserContentEditConnection: UserContentEditConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(UserContentEditEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(UserContentEdit))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IUserContentEditEdge {
  cursor: string;
  node: IUserContentEdit;
}

interface UserContentEditEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: UserContentEditSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const UserContentEditEdge: UserContentEditEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field(
      "node",
      undefined as never,
      new SelectionSet(select(UserContentEdit))
    ),
};

export interface IUserEdge {
  cursor: string;
  node: IUser;
}

interface UserEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const UserEdge: UserEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(User))),
};

export interface IUserEmailMetadata {
  primary: boolean;
  type: string;
  value: string;
}

interface UserEmailMetadataSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Boolean to identify primary emails
   */

  primary: () => Field<"primary">;

  /**
   * @description Type of email
   */

  type: () => Field<"type">;

  /**
   * @description Email id
   */

  value: () => Field<"value">;
}

export const UserEmailMetadata: UserEmailMetadataSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Boolean to identify primary emails
   */
  primary: () => new Field("primary"),

  /**
   * @description Type of email
   */
  type: () => new Field("type"),

  /**
   * @description Email id
   */
  value: () => new Field("value"),
};

export interface IUserStatus extends INode {
  __typename: "UserStatus";
  createdAt: unknown;
  emoji: string;
  emojiHTML: unknown;
  expiresAt: unknown;
  indicatesLimitedAvailability: boolean;
  message: string;
  organization: IOrganization;
  updatedAt: unknown;
  user: IUser;
}

interface UserStatusSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description Identifies the date and time when the object was created.
   */

  createdAt: () => Field<"createdAt">;

  /**
   * @description An emoji summarizing the user's status.
   */

  emoji: () => Field<"emoji">;

  /**
   * @description The status emoji as HTML.
   */

  emojiHTML: () => Field<"emojiHTML">;

  /**
   * @description If set, the status will not be shown after this date.
   */

  expiresAt: () => Field<"expiresAt">;

  /**
   * @description ID of the object.
   */

  id: () => Field<"id">;

  /**
   * @description Whether this status indicates the user is not fully available on GitHub.
   */

  indicatesLimitedAvailability: () => Field<"indicatesLimitedAvailability">;

  /**
   * @description A brief message describing what the user is doing.
   */

  message: () => Field<"message">;

  /**
   * @description The organization whose members can see this status. If null, this status is publicly visible.
   */

  organization: <T extends Array<Selection>>(
    select: (t: OrganizationSelector) => T
  ) => Field<"organization", never, SelectionSet<T>>;

  /**
   * @description Identifies the date and time when the object was last updated.
   */

  updatedAt: () => Field<"updatedAt">;

  /**
   * @description The user who has this status.
   */

  user: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"user", never, SelectionSet<T>>;
}

export const isUserStatus = (
  object: Record<string, any>
): object is Partial<IUserStatus> => {
  return object.__typename === "UserStatus";
};

export const UserStatus: UserStatusSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description Identifies the date and time when the object was created.
   */
  createdAt: () => new Field("createdAt"),

  /**
   * @description An emoji summarizing the user's status.
   */
  emoji: () => new Field("emoji"),

  /**
   * @description The status emoji as HTML.
   */
  emojiHTML: () => new Field("emojiHTML"),

  /**
   * @description If set, the status will not be shown after this date.
   */
  expiresAt: () => new Field("expiresAt"),

  /**
   * @description ID of the object.
   */
  id: () => new Field("id"),

  /**
   * @description Whether this status indicates the user is not fully available on GitHub.
   */
  indicatesLimitedAvailability: () => new Field("indicatesLimitedAvailability"),

  /**
   * @description A brief message describing what the user is doing.
   */
  message: () => new Field("message"),

  /**
   * @description The organization whose members can see this status. If null, this status is publicly visible.
   */

  organization: (select) =>
    new Field(
      "organization",
      undefined as never,
      new SelectionSet(select(Organization))
    ),

  /**
   * @description Identifies the date and time when the object was last updated.
   */
  updatedAt: () => new Field("updatedAt"),

  /**
   * @description The user who has this status.
   */

  user: (select) =>
    new Field("user", undefined as never, new SelectionSet(select(User))),
};

export interface IUserStatusConnection {
  edges: IUserStatusEdge[];
  nodes: IUserStatus[];
  pageInfo: IPageInfo;
  totalCount: number;
}

interface UserStatusConnectionSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A list of edges.
   */

  edges: <T extends Array<Selection>>(
    select: (t: UserStatusEdgeSelector) => T
  ) => Field<"edges", never, SelectionSet<T>>;

  /**
   * @description A list of nodes.
   */

  nodes: <T extends Array<Selection>>(
    select: (t: UserStatusSelector) => T
  ) => Field<"nodes", never, SelectionSet<T>>;

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: <T extends Array<Selection>>(
    select: (t: PageInfoSelector) => T
  ) => Field<"pageInfo", never, SelectionSet<T>>;

  /**
   * @description Identifies the total count of items in the connection.
   */

  totalCount: () => Field<"totalCount">;
}

export const UserStatusConnection: UserStatusConnectionSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A list of edges.
   */

  edges: (select) =>
    new Field(
      "edges",
      undefined as never,
      new SelectionSet(select(UserStatusEdge))
    ),

  /**
   * @description A list of nodes.
   */

  nodes: (select) =>
    new Field(
      "nodes",
      undefined as never,
      new SelectionSet(select(UserStatus))
    ),

  /**
   * @description Information to aid in pagination.
   */

  pageInfo: (select) =>
    new Field(
      "pageInfo",
      undefined as never,
      new SelectionSet(select(PageInfo))
    ),

  /**
   * @description Identifies the total count of items in the connection.
   */
  totalCount: () => new Field("totalCount"),
};

export interface IUserStatusEdge {
  cursor: string;
  node: IUserStatus;
}

interface UserStatusEdgeSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A cursor for use in pagination.
   */

  cursor: () => Field<"cursor">;

  /**
   * @description The item at the end of the edge.
   */

  node: <T extends Array<Selection>>(
    select: (t: UserStatusSelector) => T
  ) => Field<"node", never, SelectionSet<T>>;
}

export const UserStatusEdge: UserStatusEdgeSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A cursor for use in pagination.
   */
  cursor: () => new Field("cursor"),

  /**
   * @description The item at the end of the edge.
   */

  node: (select) =>
    new Field("node", undefined as never, new SelectionSet(select(UserStatus))),
};

export interface IViewerHovercardContext extends IHovercardContext {
  __typename: "ViewerHovercardContext";
  viewer: IUser;
}

interface ViewerHovercardContextSelector {
  __typename: () => Field<"__typename">;

  /**
   * @description A string describing this context
   */

  message: () => Field<"message">;

  /**
   * @description An octicon to accompany this context
   */

  octicon: () => Field<"octicon">;

  /**
   * @description Identifies the user who is related to this context.
   */

  viewer: <T extends Array<Selection>>(
    select: (t: UserSelector) => T
  ) => Field<"viewer", never, SelectionSet<T>>;
}

export const isViewerHovercardContext = (
  object: Record<string, any>
): object is Partial<IViewerHovercardContext> => {
  return object.__typename === "ViewerHovercardContext";
};

export const ViewerHovercardContext: ViewerHovercardContextSelector = {
  __typename: () => new Field("__typename"),

  /**
   * @description A string describing this context
   */
  message: () => new Field("message"),

  /**
   * @description An octicon to accompany this context
   */
  octicon: () => new Field("octicon"),

  /**
   * @description Identifies the user who is related to this context.
   */

  viewer: (select) =>
    new Field("viewer", undefined as never, new SelectionSet(select(User))),
};

export const query = <T extends Array<Selection>>(
  name: string,
  select: (t: typeof Query) => T
): Operation<SelectionSet<T>> =>
  new Operation(name, "query", new SelectionSet(select(Query)));

export const mutation = <T extends Array<Selection>>(
  name: string,
  select: (t: typeof Mutation) => T
): Operation<SelectionSet<T>> =>
  new Operation(name, "mutation", new SelectionSet(select(Mutation)));
